-- MySQL dump 10.13  Distrib 5.6.30, for linux-glibc2.5 (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.6.30-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` varchar(40) NOT NULL,
  `title` varchar(50) DEFAULT NULL,
  `brief` varchar(300) DEFAULT NULL,
  `content` text,
  `date` varchar(30) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `page_views` int(11) DEFAULT NULL,
  `image` varchar(60) DEFAULT NULL,
  `user_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  KEY `user_id` (`user_id`),
  KEY `ix_article_title` (`title`),
  KEY `ix_article_brief` (`brief`(255)),
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`),
  CONSTRAINT `article_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES ('019037c1-901f-466d-9039-29ca381789aa','vue-route+webpack部署单页路由项目，访问刷新出现404问题','vue-route+webpack部署单页路由项目，访问刷新出现404问题','<p>\r\n	问题描述：前端同事使用Vue.js框架，利用vue-route结合webpack编写了一个单页路由项目，运维协助在服务器端配置nginx。部署完成后，访问首页没问题，从首页里打开二级页面没问题，但是所有的二级页面打开后，再次刷新，就会出现404现象！如下：\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	问题原因：刷新页面时访问的资源在服务端找不到，因为vue-router设置的路径不是真实存在的路径。如上的404现象，是因为在nginx配置的根目录/Data/app/xqsj_wx/dist下面压根没有loading这个真实资源存在，这些访问资源都是在js里渲染的。\r\n</p>\r\n<p>\r\n	服务端nginx的一开始配置如下（假设域名为：testwx.wangshibo.com）：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cat /Data/app/nginx/conf/vhosts/testwx.wangshibo.com.conf &nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;server {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;listen       80;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; server_name  testwx.wangshibo.com;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;root  /Data/app/xqsj_wx/dist;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; index index.html;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; access_log  /var/log/testwx.log  main;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如上出现404的原因是由于在这个域名根目录/Data/app/xqsj_wx/dist下面压根就没有loading这个真实目录存在。\r\n</p>\r\n<p>\r\n	问题解决：在nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下（添加下面标红内容）：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cat /Data/app/nginx/conf/vhosts/testwx.wangshibo.com.conf&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;server {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen       80;\r\n</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_name  testwx.wangshibo.com;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root  /Data/app/xqsj_wx/dist;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;index index.html;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; access_log  /var/log/testwx.log  main;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location / {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try_files $uri $uri/ @router;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index  index.html;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;location @router {&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite ^.*$ /index.html last;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	重启nginx后，问题就迎刃而解了。\r\n</p>\r\n<p>\r\n	[总结：nginx配置文件里一定要定义access和error日志，出现问题要第一时间查看日志(error)]\r\n</p>','2017-07-31 17:16:48',1,3,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('05109d93-27e8-4c30-9221-78eef40758b6','mysql操作命令梳理（4）-中文乱码问题','mysql操作命令梳理（4）-中文乱码问题','<p>\r\n	在平时的mysql运维操作中，经常会碰到插入中文字段后出现乱码的情况，产生中文乱码的原因一般有：\r\n</p>\r\n<p>\r\n	1）mysql的编码格式不对，是latin1编码。强烈推荐将mysql下的编码格式都改为utf8，因为它兼容世界上所有字符！\r\n</p>\r\n<p>\r\n	2）mysql的表的语系设定问题(包含character与collation)\r\n</p>\r\n<p>\r\n	3）客户端程式(例如php)的连线语系设定问题\r\n</p>\r\n<p>\r\n	下面就对Mysql下处理数据表中中文字段乱码问题的操作做一记录：为了防止后续操作出现乱码现象，最好在创建库或数据表的时候就设置正确的编码。 &nbsp; &nbsp; 创建数据库的时候,设置编码格式\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE DATABASE hqsb\r\n</p>\r\n<p>\r\n	-&gt; CHARACTER SET utf8\r\n</p>\r\n<p>\r\n	-&gt; COLLATE utf8_general_ci;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	创建表的时候，设置编码格式\r\n</p>\r\n<p>\r\n	mysql&gt; use hqsb;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt;   CREATE TABLE haha (\r\n</p>\r\n<p>\r\n	-&gt;   id int(10) PRIMARY KEY AUTO_INCREMENT,\r\n</p>\r\n<p>\r\n	-&gt;   name varchar(64) NOT NULL\r\n</p>\r\n<p>\r\n	-&gt;   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	这3个设置好了，基本就不会出问题了,即建库和建表时都使用相同的编码格式。\r\n</p>\r\n<p>\r\n	如果在建库建表的时候没有指明编码格式导致中文乱码，可以通过以下方式进行查询。\r\n</p>\r\n<p>\r\n	1）查看mysql系统默认的编码格式（保证下面查询结果中的所有编码格式都是utf8，有不是的就手动修改！）:\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%char%\";\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name            | Value                            |\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| character_set_client     | gbk                             |\r\n</p>\r\n<p>\r\n	| character_set_connection | gbk                              |\r\n</p>\r\n<p>\r\n	| character_set_database   | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_filesystem | binary                           |\r\n</p>\r\n<p>\r\n	| character_set_results    | gbk                              |\r\n</p>\r\n<p>\r\n	| character_set_server     | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_system     | utf8                             |\r\n</p>\r\n<p>\r\n	| character_sets_dir       | /usr/local/mysql/share/charsets/ |\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	8 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	手动进行修改：\r\n</p>\r\n<p>\r\n	mysql&gt; SET character_set_filesystem=\'utf8\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	再次查看是否已修改：\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%char%\";\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name            | Value                            |\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| character_set_client     | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_connection | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_database   | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_filesystem | utf8                           |\r\n</p>\r\n<p>\r\n	| character_set_results    | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_server     | utf8                             |\r\n</p>\r\n<p>\r\n	| character_set_system     | utf8                             |\r\n</p>\r\n<p>\r\n	| character_sets_dir       | /usr/local/mysql/share/charsets/ |\r\n</p>\r\n<p>\r\n	+--------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	8 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	2）查看数据库（比如hqsb）的编码格式:\r\n</p>\r\n<p>\r\n	mysql&gt; show create database hqsb;\r\n</p>\r\n<p>\r\n	+----------+---------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Database | Create Database                                               |\r\n</p>\r\n<p>\r\n	+----------+---------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| hqsb     | CREATE DATABASE `hqsb` /*!40100 DEFAULT CHARACTER SET utf8 */ |\r\n</p>\r\n<p>\r\n	+----------+---------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	如果数据库的编码格式不正确，可以手动修改：\r\n</p>\r\n<p>\r\n	mysql&gt; ALTER DATABASE hqsb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	3）查看数据表（比如haha）的编码格式:\r\n</p>\r\n<p>\r\n	mysql&gt; show create table haha;\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Table | Create Table                                                                                                                                           |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| haha  | CREATE TABLE `haha` (\r\n</p>\r\n<p>\r\n	`id` int(10) NOT NULL AUTO_INCREMENT,\r\n</p>\r\n<p>\r\n	`name` varchar(64) NOT NULL,\r\n</p>\r\n<p>\r\n	PRIMARY KEY (`id`)\r\n</p>\r\n<p>\r\n	) ENGINE=InnoDB DEFAULT CHARSET=utf8 |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	如果数据表的编码格式不正确，可以手动修改：\r\n</p>\r\n<p>\r\n	mysql&gt; ALTER TABLE haha DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	注意：在客户端（比如xshell）里连接mysql插入数据，最好事先确保编码格式为Utf-8。\r\n</p>\r\n<p>\r\n	解决网页中乱码的问题\r\n</p>\r\n<p>\r\n	1）将网站编码设为utf-8。\r\n</p>\r\n<p>\r\n	2）如果网站已运作了好久,并有很多旧数据,不能再更改简体中文的设定,那么建议将页面的编码设为GBK。   GBK与GB2312的区别就在于:GBK能比GB2312显示更多的字符,要显示简体码的繁体字,就只能用GBK。\r\n</p>\r\n<p>\r\n	3）编辑/etc/my.cnf　,在[mysql]段加入default_character_set=utf8;\r\n</p>\r\n<p>\r\n	4）在编写Connection URL时，加上?useUnicode=true&amp;characterEncoding=utf-8参数;5）在网页代码中加上一个\"set names utf8\"或者\"set names gbk\"的指令，告诉MySQL连线内容都要使用utf8或者gbk;\r\n</p>','2017-07-31 17:32:24',3,6,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('0bb7bfcd-b787-4f94-88ac-988d89c3f237','nginx反向代理+缓存开启+url重写+负载均衡(带健康探测)的部署记录','nginx反向代理+缓存开启+url重写+负载均衡(带健康探测)的部署记录','<p>\r\n	在日常运维工作中，运维人员会时常使用到nginx的反向代理，负载均衡以及缓存等功能来优化web服务性能。废话不多说，下面对测试环境下的nginx反向代理+缓存开启+url重写+负载均衡(带健康探测)搭建过程做一记录：\r\n</p>\r\n<p>\r\n	一、后端的Real Server的准备\r\n</p>\r\n<p>\r\n	两台RS服务器(192.168.1.104/192.168.1.105)要事先配置好nginx。并且nginx访问均是用ip访问即可，方便实验效果！\r\n</p>\r\n<p>\r\n	二、nginx代理服务器192.168.1.103（假设外网ip是111.112.114.23）的配置\r\n</p>\r\n<p>\r\n	1.nginx反向代理和缓存\r\n</p>\r\n<p>\r\n	0）安装依赖软件（如果是ubuntu系统，则sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get install libpcre3 libpcre3-dev zlib1g-dev libssl-dev build-essential openssl libssl0.9.8 libssl-dev）[root@node1 ~]# yum install -y pcre pcre-devel openssl openssl-devel gcc\r\n</p>\r\n<p>\r\n	1）首先添加用户nginx，实现以之运行nginx服务进程：[root@node1 ~]# groupadd -r nginx[root@node1 ~]# useradd -r -g nginx -s /bin/false -M nginx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#-M参数表示创建用户时不创建用户家目录\r\n</p>\r\n<p>\r\n	2）接着开始编译和安装：[root@node1 ~]# cd /usr/loca/src\r\n</p>\r\n<p>\r\n	[root@node1 src]# wget http://nginx.org/download/nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@node1 src]# tar -zxvf nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@node1 src]# cd nginx-1.8.0\r\n</p>\r\n<p>\r\n	[root@node1 nginx-1.8.0]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre\r\n</p>\r\n<p>\r\n	&nbsp;[root@node1 src]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	#以上编译安装nginx后，--http-client-body-temp-path、--http-proxy-temp-path、--http-fastcgi-temp-path、--http-uwsgi-temp-path、--http-scgi-temp-path默认的路径就在/usr/local/nginx下，分别是client_body_temp、proxy_temp、fastcgi_temp、scgi_temp、uwsgi_temp\r\n</p>\r\n<p>\r\n	[root@node1 src]# cd /usr/local/nginx/\r\n</p>\r\n<p>\r\n	[root@node1 nginx]# lsconf  html  logs  sbin\r\n</p>\r\n<p>\r\n	[root@node1 nginx]# /usr/local/nginx/sbin/nginx &nbsp; &nbsp; //nginx启动后，就会出现下面的目录\r\n</p>\r\n<p>\r\n	[root@node1 nginx]# ls /usr/local/nginx/client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  uwsgi_temp\r\n</p>\r\n<p>\r\n	3）反代的实现，和缓存的开启（可参考：nginx缓存配置的操作记录梳理）\r\n</p>\r\n<p>\r\n	[root@node1 src]# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	&nbsp; worker_processes  1;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; events {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; worker_connections  1024;\r\n</p>\r\n<p>\r\n	&nbsp; }&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; http {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; include       mime.types;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp;&nbsp;default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; sendfile        on;\r\n</p>\r\n<p>\r\n	&nbsp;　 &nbsp;keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	#要想开启nginx的缓存功能，需要添加此处的两行内容！\r\n</p>\r\n<p>\r\n	#这一行分别表示：定义缓存存储目录,手动创建；缓存级别,表示缓存目录的第一级目录是1个字符，第二级目录是2个字符；内核中建立用于缓存缓存数据源数据的空间，查找缓存的时候，先从这个内核空间中找到，缓存数据的源数据，然后再到对应目录中查找缓存；这一行分别表示：缓存空间最大值；缓存的数据，60分钟内没有被访问过就删除&nbsp;　　proxy_cache_path /var/www/cache  levels=1:2 keys_zone=mycache:20m&nbsp;max_size=2048m inactive=60m;\r\n</p>\r\n<p>\r\n	#这一行分别表示：创建缓存的时候可能生成一些临时文件存放的位置，自动创建 　　proxy_temp_path /var/www/cache/tmp;\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	&nbsp;listen       80;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;server_name  localhost;\r\n</p>\r\n<p>\r\n	&nbsp;location / {&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp;#root   html;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp;#index  index.html index.htm;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp;proxy_pass http://192.168.1.104/; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #代理哪个web服务器&nbsp;\r\n</p>\r\n<p>\r\n	proxy_cache mycache; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#内存缓存源数据空间名字，对应我们前面的设定\r\n</p>\r\n<p>\r\n	&nbsp;　 &nbsp; proxy_cache_valid 200 302 60m; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#页面返回码为200 302 的缓存60分\r\n</p>\r\n<p>\r\n	&nbsp;　　proxy_cache_valid 404 1m; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #页面错误响应吗404缓存时间1分&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	&nbsp;error_page   500 502 503 504  /50x.html;\r\n</p>\r\n<p>\r\n	&nbsp;location = /50x.html&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp;{&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; root   html;&nbsp;\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp;}&nbsp;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@node1 src]# mkdir /var/www/cache [root@node1 src]# /usr/local/nginx/sbin/nginx\r\n</p>\r\n<p>\r\n	4）验证结果访问http://111.112.114.23，则显示的是http://192.168.1.104的访问结果（如上配置，RS2的反向代理类似）\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------------再看如下的一个实例配置（nginx.conf文件中已开启缓存功能）\r\n</p>\r\n<p>\r\n	upstream LB-WWW {\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	server 192.168.1.101:80 max_fails=3 fail_timeout=30s weight=100;   #max_fails = 3 为允许失败的次数，默认值为1\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80 max_fails=3 fail_timeout=30s weight=100;   #fail_timeout = 30s（也可以是fail_timeout = 30，即后面的秒单位不带） 当max_fails次失败后，暂停将请求分发到该后端服务器的时间\r\n</p>\r\n<p>\r\n	server 192.168.1.118:80 max_fails=3 fail_timeout=30s weight=50;    #由于这三台机器中，前两台配置高，后一台118机器配置低点，三台机器开启的nginx线上数是一样的，所以118机器设置的weight权重低。\r\n</p>\r\n<p>\r\n	}                                                                    #weight权限设置低，命中率就会低，这样机器压力就会减轻（若是权重不设置低点，也可以通过减少nginx线程数来减少机器压力）；\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/www-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/www-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-WWW;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;             #跟后端服务器连接超时时间，发起握手等候响应时间\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;                #后端服务器回传时间，就是在规定时间内后端服务器必须传完所有数据\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;                #连接成功后等待后端服务器的响应时间，已经进入后端的排队之中等候处理\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;                #代理请求缓冲区,会保存用户的头信息以供nginx进行处理\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;                  #同上，告诉nginx保存单个用几个buffer最大用多少空间\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;          #如果系统很忙时候可以申请最大的proxy_buffers\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;       #proxy缓存临时文件的大小\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;                   #内存缓存源数据空间名字，对应我们前面的设定\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	proxy_set_header参数解释\r\n</p>\r\n<p>\r\n	1）proxy_redirect off\r\n</p>\r\n<p>\r\n	语法：proxy_redirect [ default|off|redirect replacement ]\r\n</p>\r\n<p>\r\n	默认值：proxy_redirect default\r\n</p>\r\n<p>\r\n	使用字段：http, server, location\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	proxy_redirect功能比较强大,其作用是对发送给客户端的URL进行修改。\r\n</p>\r\n<p>\r\n	如果需要修改从被代理服务器传来的应答头中的\"Location\"和\"Refresh\"字段，可以用这个指令设置。\r\n</p>\r\n<p>\r\n	设置为off，表示禁止所有的proxy_redirect指令.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	假设被代理服务器返回Location字段为：http://localhost:8000/two/some/uri/\r\n</p>\r\n<p>\r\n	这个指令：\r\n</p>\r\n<p>\r\n	proxy_redirect http://localhost:8000/two/ http://frontend/one/;\r\n</p>\r\n<p>\r\n	将Location字段重写为http://frontend/one/some/uri/。\r\n</p>\r\n<p>\r\n	在代替的字段中可以不写服务器名：\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	proxy_redirect http://localhost:8000/two/ /;\r\n</p>\r\n<p>\r\n	这样就使用服务器的基本名称和端口，即使它来自非80端口。\r\n</p>\r\n<p>\r\n	如果使用“default”参数，将根据location和proxy_pass参数的设置来决定。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	例如下列两个配置等效：\r\n</p>\r\n<p>\r\n	location /one/ {\r\n</p>\r\n<p>\r\n	proxy_pass  http://upstream:port/two/;\r\n</p>\r\n<p>\r\n	proxy_redirect   default;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /one/ {\r\n</p>\r\n<p>\r\n	proxy_pass  http://upstream:port/two/;\r\n</p>\r\n<p>\r\n	proxy_redirect  http://upstream:port/two/ /one/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在指令中可以使用一些变量：\r\n</p>\r\n<p>\r\n	proxy_redirect  http://localhost:8000/ http://$host:$server_port/;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这个指令有时可以重复：\r\n</p>\r\n<p>\r\n	proxy_redirect   default;\r\n</p>\r\n<p>\r\n	proxy_redirect   http://localhost:8000/  /;\r\n</p>\r\n<p>\r\n	proxy_redirect   ;\r\n</p>\r\n<p>\r\n	/;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	参数off将在这个字段中禁止所有的proxy_redirect指令：\r\n</p>\r\n<p>\r\n	proxy_redirect   off;\r\n</p>\r\n<p>\r\n	proxy_redirect   default;\r\n</p>\r\n<p>\r\n	proxy_redirect   http://localhost:8000/  /;\r\n</p>\r\n<p>\r\n	proxy_redirect   ;\r\n</p>\r\n<p>\r\n	/;\r\n</p>\r\n<p>\r\n	利用这个指令可以为被代理服务器发出的相对重定向增加主机名：\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	实例说明：\r\n</p>\r\n<p>\r\n	比如在做nginx反向代理时出了一点点问题，原来后端节点用的端口是8080，通过反向代理后，使用wireshark抓包发现location头域数值为http://192.168.1.154:8080/huihui/，\r\n</p>\r\n<p>\r\n	如果把这个返回给客户端肯定是不可以的，看起来别扭而且还暴露了后端节点的具体信息。所以在这里用到了nginx的proxy_redirect指定修改被代理服务器返回的响应头中的location头域跟refresh头域数值。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	前期配置（暴露了后端节点信息）\r\n</p>\r\n<p>\r\n	[root@localhost nginx]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.154:8080;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	此时我们通过curl查看结果得出\r\n</p>\r\n<p>\r\n	[root@localhost nginx]# curl -I http://www.wangshibo.com/huihui\r\n</p>\r\n<p>\r\n	HTTP/1.1 301 Moved Permanently\r\n</p>\r\n<p>\r\n	Server: nginx\r\n</p>\r\n<p>\r\n	Date: Thu, 24 Dec 2015 12:02:00 GMT\r\n</p>\r\n<p>\r\n	Content-Type: text/html; charset=iso-8859-1\r\n</p>\r\n<p>\r\n	Connection: keep-alive\r\n</p>\r\n<p>\r\n	Location: http://192.168.1.154:8080/huihui/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这里location为带有后端服务器实际地址跟端口的响应头信息，这样在实际线上是不允许的。\r\n</p>\r\n<p>\r\n	所以这里需要通过proxy_redirect将被代理服务器的响应头中的location字段进行修改后返回给客户端\r\n</p>\r\n<p>\r\n	修改后的配置：\r\n</p>\r\n<p>\r\n	[root@localhost nginx]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.154:8080;\r\n</p>\r\n<p>\r\n	proxy_redirect http://192.168.1.154:8080/huihui/  http://www.wangshibo.com/huihui/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.154:8080;\r\n</p>\r\n<p>\r\n	proxy_redirect ~^http://192.168.1.154:8080(.*)   http://www.wangshibo.com$1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	则curl查看返回结果\r\n</p>\r\n<p>\r\n	[root@localhost nginx]# curl -I http://www.wangshibo.com/huihui\r\n</p>\r\n<p>\r\n	HTTP/1.1 301 Moved Permanently\r\n</p>\r\n<p>\r\n	Server: nginx\r\n</p>\r\n<p>\r\n	Date: Thu, 24 Dec 2015 12:08:34 GMT\r\n</p>\r\n<p>\r\n	Content-Type: text/html; charset=iso-8859-1\r\n</p>\r\n<p>\r\n	Connection: keep-alive\r\n</p>\r\n<p>\r\n	Location: http://www.wangshibo.com/huihui/\r\n</p>\r\n<p>\r\n	此时查看location已经变成了我们想要的结果了。 此时通过replacement 301重定向到了我们新的页面\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	允许重新定义或添加字段传递给代理服务器的请求头。该值可以包含文本、变量和它们的组合。在没有定义proxy_set_header时会继承之前定义的值。\r\n</p>\r\n<p>\r\n	默认情况下，只有两个字段被重定义：\r\n</p>\r\n<p>\r\n	proxy_set_header Host       $proxy_host;\r\n</p>\r\n<p>\r\n	proxy_set_header Connection close;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	实例说明：\r\n</p>\r\n<p>\r\n	nginx对于upstream默认使用的是基于IP的转发，如下配置：\r\n</p>\r\n<p>\r\n	[root@localhost nginx]# cat test.conf\r\n</p>\r\n<p>\r\n	upstream backend {\r\n</p>\r\n<p>\r\n	server 127.0.0.1:8080;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream china {\r\n</p>\r\n<p>\r\n	server china.wangshibo.com;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $http_host;\r\n</p>\r\n<p>\r\n	proxy_set_header x-forwarded-for  $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_buffer_size         64k;\r\n</p>\r\n<p>\r\n	proxy_buffers             32 64k;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  logs/host.access.log  main;\r\n</p>\r\n<p>\r\n	location = /50x.html {\r\n</p>\r\n<p>\r\n	root   html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass backend ;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location = /customer/straightcustomer/download {\r\n</p>\r\n<p>\r\n	proxy_pass http://china;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $proxy_host;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	当匹配到/customer/straightcustomer/download时，使用china处理，到upstream就匹配到china.wangshibo.com，这里直接转换成IP进行转发了。\r\n</p>\r\n<p>\r\n	假如china.wangshibo.com是在另一台nginx下配置的，ip为10.22.10.116，则$proxy_host则对应为10.22.10.116。\r\n</p>\r\n<p>\r\n	此时相当于设置了Host为10.22.10.116。如果想让Host是china.wangshibo.com，则进行如下设置：\r\n</p>\r\n<p>\r\n	proxy_set_header Host china.wangshibo.com;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	如果不想改变请求头“Host”的值，可以这样来设置：\r\n</p>\r\n<p>\r\n	proxy_set_header Host       $http_host;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。 这种情况下，更好的方式是使用$host变量——它的值在请求包含“Host”请求头时为“Host”字段的值，在请求未携带“Host”请求头时为虚拟主机的主域名：\r\n</p>\r\n<p>\r\n	proxy_set_header Host       $host;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	此外，服务器名可以和后端服务器的端口一起传送：\r\n</p>\r\n<p>\r\n	proxy_set_header Host       $host:$proxy_port;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	如果某个请求头的值为空，那么这个请求头将不会传送给后端服务器：\r\n</p>\r\n<p>\r\n	proxy_set_header Accept-Encoding \"\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	3）有了下面三行配置，就可以在web的后端节点服务器端获得客户端用户的真实ip。\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;      //后端节点机器获取客户端真实ip的第一种方案\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    //后端节点机器获取客户端真实ip的第二中方案。当然这两种方案也可以一起配置！\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	其中这个X-real-ip是一个自定义的变量名，名字可以随意取，这样做完之后，用户的真实ip就被放在X-real-ip这个变量里了，然后，在web端可以这样获取：\r\n</p>\r\n<p>\r\n	request.getAttribute(\"X-real-ip\")\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	remote_addr  代表客户端的ip，但它的值不是由客户端提供的，而是服务器端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（比如nginx）就会把remote_addr设置为\r\n</p>\r\n<p>\r\n	你的机器ip；如果你使用了代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的ip。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	x_forwarded_for  正如上面所述，当你使用了代理时，web服务器就不知道你的真实ip了。为了避免这个情况，代理服务器通常会增加一个叫做x_forwarded_for的头消息，把连接它的客户端ip（即你的上网机器的ip）\r\n</p>\r\n<p>\r\n	加到这个头消息里，这样就能保证网站的web服务器能获得真实ip。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	使用haproxy做反向代理\r\n</p>\r\n<p>\r\n	通常网站为了支撑更大的访问，会增加很多web服务器，并在这些服务器前面增加一个反向代理（如haproxy）它可以把负载均衡的分布到这些服务器上。你的浏览器访问的首先是这台反向代理服务器，它再把\r\n</p>\r\n<p>\r\n	你的请求转发到后面的web服务器上，这就使得web服务器会把remote_addr设为这台反向代理服务器的ip，为了能让你的程序获得真实的客户端ip，就需要给haproxy增加下面的配置：\r\n</p>\r\n<p>\r\n	option  forwardfor\r\n</p>\r\n<p>\r\n	它的作用就像上面说的，增加一个x_forwarded_for的头信息，把你上网机器的ip添加进去。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------\r\n</p>\r\n<p>\r\n	实际上要获得用户的真实ip，不是只有这一个方法，下面我们继续看\r\n</p>\r\n<p>\r\n	proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	这里有个X-Forwarded-For变量，这是一个squid开发的，用于识别通过HTTP代理或负载平衡器原始IP一个连接到Web服务器的客户机地址的非rfc标准，如果有做X-Forwarded-For设置的话,\r\n</p>\r\n<p>\r\n	每次经过proxy转发都会有记录,格式就是client1, proxy1, proxy2,以逗号隔开各个地址，由于他是非rfc标准，所以默认是没有的，需要强制添加，在默认情况下经过proxy转发的请求，\r\n</p>\r\n<p>\r\n	在后端看来远程地址都是proxy端的ip 。也就是说在默认情况下我们使用request.getAttribute(\"X-Forwarded-For\")获取不到用户的ip，如果我们想要通过这个变量获得用户的ip，\r\n</p>\r\n<p>\r\n	这样配置的意思是：\r\n</p>\r\n<p>\r\n	增加一个$proxy_add_x_forwarded_for到X-Forwarded-For里去，注意是增加，而不是覆盖，当然由于默认的X-Forwarded-For值是空的，所以我们总感觉X-Forwarded-For的值就等于$proxy_add_x_forwarded_for的值，\r\n</p>\r\n<p>\r\n	实际上当你搭建两台nginx在不同的ip上，并且都使用了这段配置，那你会发现在web服务器端通过request.getAttribute(\"X-Forwarded-For\")获得的将会是客户端ip和第一台nginx的ip。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	那么$proxy_add_x_forwarded_for又是什么？\r\n</p>\r\n<p>\r\n	$proxy_add_x_forwarded_for变量包含客户端请求头中的\"X-Forwarded-For\"，与$remote_addr两部分，他们之间用逗号分开。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	举个例子，有一个web应用，在它之前通过了两个nginx转发，www.linuxidc.com 即用户访问该web通过两台nginx。\r\n</p>\r\n<p>\r\n	在第一台nginx中,使用\r\n</p>\r\n<p>\r\n	proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	现在的$proxy_add_x_forwarded_for变量的\"X-Forwarded-For\"部分是空的，所以只有$remote_addr，而$remote_addr的值是用户的ip，于是赋值以后，X-Forwarded-For变量的值就是用户的真实的ip地址了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	到了第二台nginx，使用\r\n</p>\r\n<p>\r\n	proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	现在的$proxy_add_x_forwarded_for变量，X-Forwarded-For部分包含的是用户的真实ip，$remote_addr部分的值是上一台nginx的ip地址，于是通过这个赋值以后现在的X-Forwarded-For的值就变成了“用户的真实ip，\r\n</p>\r\n<p>\r\n	第一台nginx的ip”，这样就清楚了吧。最后我们看到还有一个$http_x_forwarded_for变量，这个变量就是X-Forwarded-For，由于之前我们说了，默认的这个X-Forwarded-For是为空的，\r\n</p>\r\n<p>\r\n	所以当我们直接使用proxy_set_header   X-Forwarded-For $http_x_forwarded_for时会发现，web服务器端使用request.getAttribute(\"X-Forwarded-For\")获得的值是null。如果想要通过request.getAttribute(\"X-Forwarded-For\")获得用户ip，就必须先使用proxy_set_header\r\n</p>\r\n<p>\r\n	X-Forwarded-For $proxy_add_x_forwarded_for;这样就可以获得用户真实ip。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2.url的重写\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------介绍下url重写的格式，写在配置文件中\r\n</p>\r\n<p>\r\n	rewrite regex replacement [flag]\r\n</p>\r\n<p>\r\n	Regex：被代替的原URL路径，可以是莫须有的，不存在的，支持正则表达式Replacement：用来实现代替的URL路径，必须真实存在的Flag：标志位，定义URL重写后进行的操作，有4种，分别是：\r\n</p>\r\n<p>\r\n	a)last:匹配重写后的URL，再一次对URL重写规则进行匹配，当使用last的需要注意的是如下：\r\n</p>\r\n<p>\r\n	rewrite   /images/.*\\.jpg   /images/a.jpg  last;这样写的话，将会造成死循环。\r\n</p>\r\n<p>\r\n	b）break：匹配重写URL后，终止匹配，直接使用\r\n</p>\r\n<p>\r\n	c）redirect：临时重定向，返回代码302\r\n</p>\r\n<p>\r\n	d）permanent：永久重定向，返回代码301\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	下面是nginx配置文件中的配置，简单实现url的重写配置(可以在vhosts虚拟主机配置里设置)[root@node1 src]# vim /usr/local/nginx/conf/nginx.conf ...............\r\n</p>\r\n<p>\r\n	server {listen 80;server_name localhost;root /var/www/html; index index.html index.htm;\r\n</p>\r\n<p>\r\n	location / { rewrite /abc http://www.huanqiu.com break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#本机站点目录下并不需要创建abc这个目录，对其的访问都重写到http://www.huanqiu.com}\r\n</p>\r\n<p>\r\n	location /text { rewrite /  http://china.huanqiu.com break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#本机站点目录下不需要创建text目录，对其的访问都重写到http://china.huanqiu.com}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@node1 src]# mkdir /var/www/html/text\r\n</p>\r\n<p>\r\n	注意：nginx的rewrite重写规则后的url必须要是能在外网访问的真实url！这一点要和nginx的反向代理区别开，proxy_pass代理后的url可以是内网访问，在内网之间代理！\r\n</p>\r\n<p>\r\n	3.nginx实现带健康状态检测的负载均衡\r\n</p>\r\n<p>\r\n	nginx要能够检测后端nginx的健康状态，需要新的模块，重新编译nginx\r\n</p>\r\n<p>\r\n	模块的使用：healthcheck_nginx_upstreams-master.zip\r\n</p>\r\n<p>\r\n	下载模块，下载到本机的/usr/loca/src目录下下载地址：http://pan.baidu.com/s/1o8IrpbG提取密码：vp4y\r\n</p>\r\n<p>\r\n	[root@node1 ~]# cd /usr/local/src[root@node1 src]# unzip healthcheck_nginx_upstreams-master.zip  [root@node1 src]# ll healthcheck_nginx_upstreams-master\r\n</p>\r\n<p>\r\n	接下来切换到nginx解压目录，打补丁~[root@node1 src]# cd nginx-1.8.0[root@node1 nginx-1.8.0]# patch -p1 &lt; ../healthcheck_nginx_upstreams-master\r\n</p>\r\n<p>\r\n	然后重新编译nginx，加上healthcheck_nginx_upstreams-master模块[root@node1 nginx-1.8.0]# ./configure --prefix=/usr/loca/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --add-module=/usr/local/src/healthcheck_nginx_upstreams-master\r\n</p>\r\n<p>\r\n	[root@node1 src]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	接下来配置实现nginx带健康状态的负载均衡：[root@node1 src]# vim /usr/local/nginx/conf/nginx.conf ....................................upstream cluster { &nbsp; &nbsp;server 192.168.1.104 weight=1; 　server 192.168.1.105 weight=1; 　　 　healthcheck_enabled;              　healthcheck_delay 1000; 　healthcheck_timeout 1000; 　healthcheck_failcount 3; &nbsp; &nbsp;healthcheck_send \"GET /.health HTTP/1.0\"; 　　#healthcheck_expected \'I_AM_ALIVE\'; 　　　　　　＃从RS上收到的http body部分的响应内容，如果未设置，则表示从后端服务器收到200状态码即可，这里我们不启用&nbsp;&nbsp; &nbsp;# Optional supervisord module support &nbsp; &nbsp;#supervisord none; &nbsp; &nbsp;#supervisord_inherit_backend_status;   }\r\n</p>\r\n<p>\r\n	server {     listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {       root html;      index index.php index.html index.htm;       proxy_pass http://cluster;\r\n</p>\r\n<p>\r\n	}     location /stat {       healthcheck_status;     }   }\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------上面参数解释：upstream cluster &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//定义后方的服务器群组Server 192.168.1.104 weight=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //指明后方的一台服务器地址，权重设置为1；也可以IP:PORT指定端口实现端口映射Server 192.168.1.105 weight=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//指明后方的另一台服务器地址，权重设置为1\r\n</p>\r\n<p>\r\n	healthcheck_enable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //开启健康探测功能healthcheck_delay 1000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//设置健康检测的时延；即对同一台RS两次检测之间的时间间隔，单位毫秒，默认为1000&nbsp;healthcheck_timeout 1000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//设置一次健康检测的超时时间healthcheck_failcount 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //后方某台服务器有一次检测不到即视为宕掉；即对同一台RS检测成功或失败多少次，才决定其成功或失败，并实现启用和禁用此服务healthcheck_send \"GET /.health HTTP/1.0\" &nbsp; &nbsp;//使用GET方法访问后方服务器站点下的.health来进行探测；即从RS上获得用于检测健康状态的文件，默认只支持http&nbsp;1.0协议\r\n</p>\r\n<p>\r\n	proxy_pass http://cluster &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//与upstream cluster相对应，在访问http://111.112.114.23时将流量转发到cluster组内机器上\r\n</p>\r\n<p>\r\n	location /stats &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //定义一个站点，用来查看后方服务器的健康状况----------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	最后，重启nginx[root@node1 src]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	测试：假如：RS1机器上访问的结果是“welcome to 192.168.1.104”RS2机器上访问的结果是“welcome to 192.168.1.105”\r\n</p>\r\n<p>\r\n	访问http://111.112.114.23，第一次出现的如果是RS1的访问结果，那么再刷一下，就会出现RS2的访问结果，这样就看出了负载均衡的效果。\r\n</p>\r\n<p>\r\n	可以查看后端两台Real Server服务器的健康状态:访问http://111.112.114.23/stat即可！\r\n</p>\r\n<p>\r\n	关闭RS1的nginx服务，再次访问http://111.112.114.23/stat查看后端机器状态，就会发现RS1的健康状态已提示Bad，即显示后端的192.168.1.101的RS1不能正常连接。\r\n</p>\r\n<p>\r\n	这样就实现了负载均衡和健康探测，但依然不能满足高并发量，再次用ab进行测试：\r\n</p>\r\n<p>\r\n	但是，这样通过nginx代理可以满足的最大连接请求依然没有直接访问RS的大！这个通过下面结果可知：[root@node1 src]# ab -c 100 -n 10000 http://192.168.1.104/test.jpg\r\n</p>\r\n<p>\r\n	[root@node1 src]# ab -c 100 -n 10000 http://111.112.114.23/test.jpg\r\n</p>\r\n<p>\r\n	继续做优化！如下：[root@node1 src]# vim /usr/local/nginx/conf/nginx.conf http { include mime.types; default_type application/octet-stream; sendfile on; 　　keepalive_timeout 65;\r\n</p>\r\n<p>\r\n	proxy_cache_path /var/www/cache levels=1:2 keys_zone=mycache:20m max_size=2048m inactive=24h;\r\n</p>\r\n<p>\r\n	proxy_temp_path /var/www/cache/tmp;\r\n</p>\r\n<p>\r\n	upstream cluster { &nbsp; &nbsp;server 192.168.1.104 weight=1; 　server 192.168.1.105 weight=1; 　healthcheck_enabled; 　healthcheck_delay 1000; 　healthcheck_timeout 1000; 　healthcheck_failcount 3; &nbsp; &nbsp;healthcheck_send \"GET /.health HTTP/1.0\";\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server { listen 80;server_name localhost;\r\n</p>\r\n<p>\r\n	location / { root html;index index.php index.html index.htm; proxy_set_header HOST $host;proxy_cache STATIC;proxy_cache_valid 200 1d;proxy_cache_use_stale error_timeout invalid_header updating http_500 http_502 http_503 http_504;proxy_pass http://cluster;\r\n</p>\r\n<p>\r\n	} location /stat { healthcheck_status; } }\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------参数解释：proxy_cache_path &nbsp; &nbsp; //设置缓存的路径和其他参数。缓存数据是保存在文件中的，缓存的键和文件名都是在代理URL上执行MD5的结果。 levels参数定义了缓存的层次结构。\r\n</p>\r\n<p>\r\n	proxy_set_header &nbsp; &nbsp; //允许重新定义或者添加发往后端服务器的请求头。\r\n</p>\r\n<p>\r\n	proxy_cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //指定用于页面缓存的共享内存。\r\n</p>\r\n<p>\r\n	proxy_cache_valid &nbsp; &nbsp;//为不同的响应状态码设置不同的缓存时间。\r\n</p>\r\n<p>\r\n	proxy_cache_use_stale &nbsp; &nbsp;//指定后端服务器出现状况时，nginx可以使用的过期缓存---------------------------------------------------------------\r\n</p>\r\n<p>\r\n	接着重启nginx服务[root@node1 src]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	[root@node1 src]# mkdir /var/www/cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#这个前面做缓存时，已经创建了。\r\n</p>\r\n<p>\r\n	再次进行压力测试，可以看到通过nginx代理可以满足的最大连接请求已经达到了5000多，超过了直接访问RS的最大连接请求了！\r\n</p>\r\n<p>\r\n	这样负载均衡+健康探测+缓存已经完成！\r\n</p>\r\n<p>\r\n	[root@node1 src]# ab -c 100 -n 10000 http://111.112.114.23/test.jpg\r\n</p>\r\n<p>\r\n	接下来一个问题就是在启用缓存之后的访问问题，试着重新访问一下该站点http://111.112.114.23：\r\n</p>\r\n<p>\r\n	即第一次访问http://111.112.114.23时访问到了192.168.1.104（即RS1），显示结果是：“welcome to 192.168.1.104”，前端nginx将本次的访问结果放入本地缓存，在缓存未失效之前，访问http://111.112.114.23时实际上是nginx的本地缓存提供的访问结果，依然显示“welcome to 192.168.1.104”的页面。可以试着多刷新几次，可以发现再怎么刷新页面内容依然是“welcome to 192.168.1.104”！这就证明现在访问到的是nginx缓存在本地的结果！\r\n</p>\r\n<p>\r\n	看看缓存目录中有没有内容[root@node1 src]# ll /var/www/cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #发现缓存目录下已经有了缓存结果；可以将这个缓存结果清除，再次刷次页面，就会是新页面了。total 4drwx------ 3 nginx nginx 4096 Sep 18 16:44 e[root@node1 src]#\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('0c439978-c324-4269-8e8d-aa772ccf33fc','proxy_pass根据path路径转发时的&quot;/&quot;问题记录','proxy_pass根据path路径转发时的&quot;/&quot;问题记录','<p>\r\n	在nginx中配置proxy_pass时，如果是按照^~匹配路径时,要注意proxy_pass后的url最后的/。当加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走。\r\n</p>\r\n<p>\r\n	比如下面设置：\r\n</p>\r\n<p>\r\n	location ^~ /wangshibo/\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	proxy_cache js_cache;\r\n</p>\r\n<p>\r\n	proxy_set_header Host js.test.com;\r\n</p>\r\n<p>\r\n	proxy_pass http://js.test.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如上面的配置，如果请求的url是http://servername/wangshibo/test.html会被代理成http://js.test.com/test.html\r\n</p>\r\n<p>\r\n	而如果这么配置\r\n</p>\r\n<p>\r\n	location ^~ /wangshibo/\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	proxy_cache js_cache;\r\n</p>\r\n<p>\r\n	proxy_set_header Host js.test.com;\r\n</p>\r\n<p>\r\n	proxy_pass http://js.test.com;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	则请求的url是http://servername/wangshibo/test.html会被代理到http://js.test.com/wangshibo/test.html\r\n</p>\r\n<p>\r\n	当然，可以用如下的rewrite来实现/的功能\r\n</p>\r\n<p>\r\n	location ^~ /wangshibo/\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	proxy_cache js_cache;\r\n</p>\r\n<p>\r\n	proxy_set_header Host js.test.com;\r\n</p>\r\n<p>\r\n	rewrite /wangshibo/(.+)$ /$1 break;\r\n</p>\r\n<p>\r\n	proxy_pass http://js.test.com;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	列举下面一例\r\n</p>\r\n<p>\r\n	1）第一种配置\r\n</p>\r\n<p>\r\n	[root@BJLX_16_202_V vhosts]# cat ssl-wangshibo.conf\r\n</p>\r\n<p>\r\n	upstream at {\r\n</p>\r\n<p>\r\n	server 192.168.1.202:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/wangshibo_access.log;\r\n</p>\r\n<p>\r\n	error_log logs/wangshibo_error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wang.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wang.key;\r\n</p>\r\n<p>\r\n	location /attendance/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://at;                                                          //不需要加上\"/\"\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问https://www.wangshibo.com/attendance/和http://192.168.1.202:8080/attendance结果是一致的。\r\n</p>\r\n<p>\r\n	2）第二种配置\r\n</p>\r\n<p>\r\n	[root@BJLX_16_202_V vhosts]# cat ssl-wangshibo.conf\r\n</p>\r\n<p>\r\n	upstream at {\r\n</p>\r\n<p>\r\n	server 192.168.1.202:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/wangshibo_access.log;\r\n</p>\r\n<p>\r\n	error_log logs/wangshibo_error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wang.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wang.key;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://at/attendance/;                                                  //一定要加上\"/\"\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问https://www.wangshibo.com和http://192.168.1.202:8080/attendance结果是一致的。\r\n</p>\r\n<p>\r\n	如下配置，想要实现的需求：192.168.1.27是后端的real server，8080端口是公司的ehr人事系统端口。又由于该系统涉及到微信接口访问，即http://ehr.wang.com/attendance和http://ehr.wang.com/app由于是内部系统，安全考虑，所以要求：1）登录ehr人事系统的时候要求使用内网登录，即http://192.168.1.27:8080,访问前要先登录公司VPN2）登录微信接口http://ehr.wang.com/attendance和http://ehr.wang.com/app使用外网登录，即使用解析后域名登录。3）访问http://ehr.wang.com，强制跳转为https://ehr.wang.com/attendance\r\n</p>\r\n<p>\r\n	[root@BJLX_4_21_P vhosts]# cat ehr.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ehr.wang.com;\r\n</p>\r\n<p>\r\n	access_log  logs/ehr_access.log;\r\n</p>\r\n<p>\r\n	error_log   logs/ehr_error.log;\r\n</p>\r\n<p>\r\n	return      301 https://$server_name$request_uri;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@BJLX_4_21_P vhosts]# cat ssl-ehr.conf\r\n</p>\r\n<p>\r\n	upstream ehr {\r\n</p>\r\n<p>\r\n	server 192.168.1.27:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name ehr.wang.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/ehr_access.log;\r\n</p>\r\n<p>\r\n	error_log logs/ehr_error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wang.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wang.key;\r\n</p>\r\n<p>\r\n	#ssl_session_timeout 5m;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	return  301  https://ehr.wang.com/attendance;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /attendance/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://ehr;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #   proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	#proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /app/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://ehr;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #   proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	#proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	由于从浏览器访问（http）到源站的real server之间要经过Nginx反向代理层（https）\r\n</p>\r\n<p>\r\n	需要将proxy_set_header X-Forwarded-Proto https;这一行注释掉，否则上面的配置无效。\r\n</p>\r\n<p>\r\n	如果中间没有代理层，直接是在real server本机进行nginx的反向代理（即本机nginx反代到本机的8080端口），则这个参数无效注释（已经过验证）\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------HTTP头域（proxy_set_header）列表与解释HTTP 头域是HTTP协议中请求(request)和响应(response)中的头部信息,其实就是HTTP通信的操作参数，告诉web服务器和浏览器怎样处理这个通信。HTTP头从一个请求信息或者响应信息的第二行开始（第一行是请求行或者响应行），以两个CR-LF字符组结束（CR：回车符,\\r，LF：换行符\\n）而每个HTTP头是字符串形式的，用冒号分割的键值对，多个HTTP头之间用CR-LF字符组隔开。\r\n</p>\r\n<p>\r\n	某些http头可以有注释，例如user-agent,server,via。但这些注释会被服务器或者浏览器忽略IETF组织已经将一些核心的HTTP头定义在RFC2616规范中，这些HTTP头是每个基于HTTP协议的软件必须实现的，而其他一些更新和扩展的头域也必须被基于HTTP的软件实现。当然，各个软件也可以定义自己的头域。\r\n</p>\r\n<p>\r\n	另一方面，RFC2616规范中并没有限制每个HTTP头的长度，或者限制HTTP头的数量，但出于性能和安全的考虑，多数服务器都会自己作规定，例如apache2.3就规定每个HTTP头不能超过8190个字节，每个请求不能超过100个HTTP头。\r\n</p>\r\n<p>\r\n	以下来看看发送一个请求(request)时候，可能包含的各个HTTP头和它的解释。\r\n</p>\r\n<p>\r\n	------------标准的请求头------------\r\n</p>\r\n<p>\r\n	Accept: 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain\r\n</p>\r\n<p>\r\n	Accept-Charset：浏览器能识别的字符集，例如 Accept-Charset: utf-8\r\n</p>\r\n<p>\r\n	Accept-Encoding：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。\r\n</p>\r\n<p>\r\n	例如 Accept-Encoding: gzip, deflate\r\n</p>\r\n<p>\r\n	Accept-Language：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN\r\n</p>\r\n<p>\r\n	Authorization：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization\r\n</p>\r\n<p>\r\n	头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==中，\r\n</p>\r\n<p>\r\n	basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ==使用base64解码就是“Aladdin:open sesame”\r\n</p>\r\n<p>\r\n	Cache-Control：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，\r\n</p>\r\n<p>\r\n	特别是希望使用缓　存改善性能的时候，内容也较多，所以我想在下一篇博文中主要介绍一下。\r\n</p>\r\n<p>\r\n	Connection：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是\r\n</p>\r\n<p>\r\n	浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟\r\n</p>\r\n<p>\r\n	这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。\r\n</p>\r\n<p>\r\n	Cookie：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin\r\n</p>\r\n<p>\r\n	Content-Length：一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，\r\n</p>\r\n<p>\r\n	常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。\r\n</p>\r\n<p>\r\n	Content-MD5：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\r\n</p>\r\n<p>\r\n	Content-Type：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。例如：Content-Type: application/x-www-form-urlencoded\r\n</p>\r\n<p>\r\n	Date：发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT\r\n</p>\r\n<p>\r\n	Expect：指示需要使用服务器某些特殊的功能。（这个我不是很清楚）\r\n</p>\r\n<p>\r\n	From：发送这个请求的用户的email地址。例如：From: user@example.com\r\n</p>\r\n<p>\r\n	Host：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: www.some.com:182\r\n</p>\r\n<p>\r\n	If-Match:通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，\r\n</p>\r\n<p>\r\n	则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。\r\n</p>\r\n<p>\r\n	If-Modified-Since：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，\r\n</p>\r\n<p>\r\n	如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）\r\n</p>\r\n<p>\r\n	If-None-Match：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。\r\n</p>\r\n<p>\r\n	If-Range：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，\r\n</p>\r\n<p>\r\n	如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。\r\n</p>\r\n<p>\r\n	If-Unmodified-Since：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。\r\n</p>\r\n<p>\r\n	Max-Forwards：限制请求信息在代理服务器或网关中向前传递的次数。\r\n</p>\r\n<p>\r\n	Pragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，\r\n</p>\r\n<p>\r\n	而Pragma:no-cache可以在http1.0和1.1中使用\r\n</p>\r\n<p>\r\n	Proxy-Authorization：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\r\n</p>\r\n<p>\r\n	Range：在HTTP头中，\"Range\"字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，\r\n</p>\r\n<p>\r\n	例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。\r\n</p>\r\n<p>\r\n	Referer：指当前请求的URL是在什么地址引用的。例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，\r\n</p>\r\n<p>\r\n	那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。\r\n</p>\r\n<p>\r\n	Upgrade：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\r\n</p>\r\n<p>\r\n	User-Agent：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0\r\n</p>\r\n<p>\r\n	Via：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，\r\n</p>\r\n<p>\r\n	然后被转发至www.somenet.com的公共代理（使用http/1.1），最后被转发至目标服务器www.someweb.com，那么在someweb.com中收到的via 头应该是：\r\n</p>\r\n<p>\r\n	via:1.0 someProxy 1.1 www.someweb.com(apache 1.1)\r\n</p>\r\n<p>\r\n	Warning：记录一些警告信息。\r\n</p>\r\n<p>\r\n	------------通用但非标准的HTTP头（通常，非标准的头域都是用“X-”开头，例如\"x-powered-by\"）------------\r\n</p>\r\n<p>\r\n	X-Requested-With：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）\r\n</p>\r\n<p>\r\n	DNT:DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，\r\n</p>\r\n<p>\r\n	并且于2011年3月7日被提交至IETF组织实现标准化\r\n</p>\r\n<p>\r\n	X-Forwarded-For:记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。\r\n</p>\r\n<p>\r\n	X-Forwarded-Proto：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，\r\n</p>\r\n<p>\r\n	但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https\r\n</p>\r\n<p>\r\n	Front-End-Https：微软使用与其负载平衡的一个头域。\r\n</p>\r\n<p>\r\n	X-ATT-DeviceId：AT&amp;A的产品中使用的头域，不过不是很清楚用途。\r\n</p>','2017-07-31 17:16:48',1,11,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('0f1c4ebe-06c5-4aba-b11a-3463aa1bcf13','Nginx的https配置记录以及http强制跳转到https的方法梳理','Nginx的https配置记录以及http强制跳转到https的方法梳理','<p>\r\n	一、Nginx安装（略）安装的时候需要注意加上 --with-http_ssl_module，因为http_ssl_module不属于Nginx的基本模块。Nginx安装方法：\r\n</p>\r\n<p>\r\n	# ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module\r\n</p>\r\n<p>\r\n	# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	二、生成证书(略)可以使用openssl生成证书：可参考：http://www.cnblogs.com/kevingrace/p/5865501.html比如生成如下两个证书文件（假设存放路径为/usr/local/nginx/cert/）：wangshibo.crtwangshibo.key\r\n</p>\r\n<p>\r\n	三、修改Nginx配置server {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen       443;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name  www.wangshibo.com;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root /var/www/vhosts/www.wangshibo.com/httpdocs/main/;\r\n</p>\r\n<p>\r\n	ssl on;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_certificate /usr/local/nginx/cert/wangshibo.crt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_certificate_key /usr/local/nginx/cert/wangshibo.key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_session_timeout  5m;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_protocols  SSLv2 SSLv3 TLSv1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_ciphers  HIGH:!aNULL:!MD5; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//或者是ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssl_prefer_server_ciphers   on;\r\n</p>\r\n<p>\r\n	access_log  /var/www/vhosts/www.wangshibo.com/logs/clickstream_ssl.log  main;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error_log  /var/www/vhosts/www.wangshibo.com/logs/clickstream_error_ssl.log;\r\n</p>\r\n<p>\r\n	if ($remote_addr !~ ^(124.165.97.144|133.110.186.128|133.110.186.88)) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //对访问的来源ip做白名单限制&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite ^.*$  /maintence.php last;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastcgi_pass   127.0.0.1:9000;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastcgi_read_timeout 300;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastcgi_index  index.php;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#include        fastcgi_params;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;include        fastcgi.conf;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}    }\r\n</p>\r\n<p>\r\n	---------------------------------http访问强制跳转到https---------------------------------网站添加了https证书后，当http方式访问网站时就会报404错误，所以需要做http到https的强制跳转设置.\r\n</p>\r\n<p>\r\n	---------------一、采用nginx的rewrite方法---------------------\r\n</p>\r\n<p>\r\n	1) 下面是将所有的http请求通过rewrite重写到https上。\r\n</p>\r\n<p>\r\n	例如将所有的dev.wangshibo.com域名的http访问强制跳转到https。\r\n</p>\r\n<p>\r\n	下面配置均可以实现：\r\n</p>\r\n<p>\r\n	配置1：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$  https://$host$1 permanent;        //这是ngixn早前的写法，现在还可以使用。\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-------------------------------------------------------\r\n</p>\r\n<p>\r\n	上面的跳转配置rewrite ^(.*)$  https://$host$1 permanent;\r\n</p>\r\n<p>\r\n	也可以改为下面\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://dev.wangshibo.com/$1 permanent;\r\n</p>\r\n<p>\r\n	或者\r\n</p>\r\n<p>\r\n	rewrite ^ http://dev.wangshibo.com$request_uri? permanent;\r\n</p>\r\n<p>\r\n	-------------------------------------------------------\r\n</p>\r\n<p>\r\n	配置2：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	return      301 https://$server_name$request_uri;      //这是nginx最新支持的写法\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	配置3：这种方式适用于多域名的时候，即访问wangshibo.com的http也会强制跳转到https://dev.wangshibo.com上面\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com wangshibo.com *.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	if ($host ~* \"^wangshibo.com$\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ https://dev.wangshibo.com/ permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	配置4：下面是最简单的一种配置\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	if ($host = \"dev.wangshibo.com\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://dev.wangshibo.com permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	---------------二、采用nginx的497状态码---------------------\r\n</p>\r\n<p>\r\n	497 - normal request was sent to HTTPS\r\n</p>\r\n<p>\r\n	解释：当网站只允许https访问时，当用http访问时nginx会报出497错误码\r\n</p>\r\n<p>\r\n	思路：\r\n</p>\r\n<p>\r\n	利用error_page命令将497状态码的链接重定向到https://dev.wangshibo.com这个域名上\r\n</p>\r\n<p>\r\n	配置实例：\r\n</p>\r\n<p>\r\n	如下访问dev.wangshibo.com或者wangshibo.com的http都会被强制跳转到https\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com wangshibo.com *.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	error_page 497  https://$host$uri?$args;\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	也可以将80和443的配置放在一起：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       127.0.0.1:443;  #ssl端口\r\n</p>\r\n<p>\r\n	listen       127.0.0.1:80;   #用户习惯用http访问，加上80，后面通过497状态码让它自动跳到443端口\r\n</p>\r\n<p>\r\n	server_name  dev.wangshibo.com;\r\n</p>\r\n<p>\r\n	#为一个server{......}开启ssl支持\r\n</p>\r\n<p>\r\n	ssl                  on;\r\n</p>\r\n<p>\r\n	#指定PEM格式的证书文件\r\n</p>\r\n<p>\r\n	ssl_certificate      /etc/nginx/wangshibo.pem;\r\n</p>\r\n<p>\r\n	#指定PEM格式的私钥文件\r\n</p>\r\n<p>\r\n	ssl_certificate_key  /etc/nginx/wangshibo.key;\r\n</p>\r\n<p>\r\n	#让http请求重定向到https请求\r\n</p>\r\n<p>\r\n	error_page 497  https://$host$uri?$args;\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	---------------三、利用meta的刷新作用将http跳转到https---------------------\r\n</p>\r\n<p>\r\n	上述的方法均会耗费服务器的资源，可以借鉴百度使用的方法：巧妙的利用meta的刷新作用，将http跳转到https\r\n</p>\r\n<p>\r\n	可以基于http://dev.wangshibo.com的虚拟主机路径下写一个index.html，内容就是http向https的跳转\r\n</p>\r\n<p>\r\n	将下面的内容追加到index.html首页文件内\r\n</p>\r\n<p>\r\n	[root@localhost ~]# cat /var/www/html/8080/index.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@localhost ~]# cat /usr/local/nginx/conf/vhosts/test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com wangshibo.com *.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	#将404的页面重定向到https的首页\r\n</p>\r\n<p>\r\n	error_page  404 https://dev.wangshibo.com/;\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------下面是nginx反代tomcat，并且http强制跳转至https。访问http://zrx.wangshibo.com和访问http://172.29.34.33:8080/zrx/结果是一样的\r\n</p>\r\n<p>\r\n	[root@BJLX_34_33_V vhosts]# cat zrx.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name zrx.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log  logs/access.log;\r\n</p>\r\n<p>\r\n	error_log   logs/error.log;\r\n</p>\r\n<p>\r\n	return      301 https://$server_name$request_uri;\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /data/nginx/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@BJLX_34_33_V vhosts]# cat ssl-zrx.conf\r\n</p>\r\n<p>\r\n	upstream tomcat8 {\r\n</p>\r\n<p>\r\n	server 172.29.34.33:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name zrx.wangshibo.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/ssl-access.log;\r\n</p>\r\n<p>\r\n	error_log logs/ssl-error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wangshibo.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wangshibo.key;\r\n</p>\r\n<p>\r\n	ssl_session_timeout 5m;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcat8/zrx/;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('132da9a5-a269-4114-8322-54c3f784727d','mysqldump数据导出问题','mysqldump数据导出问题','<p>\r\n	1，使用mysqldump时报错(1064)，这个是因为mysqldump版本太低与当前数据库版本不一致导致的。\r\n</p>\r\n<p>\r\n	mysqldump: Couldn\'t execute \'SET OPTION SQL_QUOTE_SHOW_CREATE=1\': You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'OPTION SQL_QUOTE_SHOW_CREATE=1\' at line 1 (1064)\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# mysqldump --versionmysqldump  Ver 10.13 Distrib 5.1.61, for redhat-linux-gnu (x86_64)\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //或者登陆mysql，select version();也可查看版本Server version: 5.6.25-log Source distribution。。。。。\r\n</p>\r\n<p>\r\n	这样的话必须知道mysqldump的绝对路径，在mysql的安装目录下有。\r\n</p>\r\n<p>\r\n	2，导出时指定字符集，报错Character set \'utf-8\' is not a compiled character set and is not specifie .--default-character-set=utf-8\r\n</p>\r\n<p>\r\n	这个是因为字符集错了。是--default-character-set=utf8\r\n</p>\r\n<p>\r\n	3，导出时提示warning，A partial dump from a server that has GTIDs\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# mysqldump  -uroot -p xqsj_db &gt; xqsj_db20160811.sqlWarning: A partial dump from a server that has GTIDs will by default include the GTIDs of all transactions, even those that changed suppressed parts of the database. If you don\'t want to restore GTIDs, pass --set-gtid-purged=OFF. To make a complete dump, pass --all-databases --triggers --routines --events.\r\n</p>\r\n<p>\r\n	关于GTID是5.6以后，加入了全局事务 ID (GTID) 来强化数据库的主备一致性，故障恢复，以及容错能力。官方给的：A global transaction identifier (GTID) is a unique identifier created and associated with each transaction committed on the server of origin (master).所以可能是因为在一个数据库里面唯一，但是当导入其他的库就有可能重复。所有会有一个提醒。\r\n</p>\r\n<p>\r\n	可以通过添加--set-gtid-purged=off  或者–gtid-mode=OFF这两个参数设置。很有肯能是在导入库中重新生产GTID，而不用原来的。\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# mysqldump  -uroot --set-gtid-purged=off -p xqsj_db &gt; xqsj_db20160811.sql&nbsp;\r\n</p>\r\n<p>\r\n	#这样就ok了！\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,4,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('16c3d5fc-24e4-4234-a41c-74058779c986','centos6.8下安装部署LNMP-（nginx1.8.0+php5.6.10+mysql5.6.','centos6.8下安装部署LNMP-（nginx1.8.0+php5.6.10+mysql5.6.12）','<p>\r\n	在平时运维工作中，经常需要用到LNMP应用框架。以下对LNMP环境部署记录下：1）前期准备：为了安装顺利，建议先使用yum安装依赖库[root@opd ~]#yum install -y make cmake gcc gcc-c++ autoconf automake libpng-devel libjpeg-devel zlib libxml2-devel ncurses-devel bison libtool-ltdl-devel libiconv libmcrypt mhash mcrypt libmcrypt-devel pcre-devel openssl-devel freetype-devel libcurl-devel\r\n</p>\r\n<p>\r\n	2）安装nginx[root@opd ~]#cd /opt/src[root@src ~]#wget http://nginx.org/download/nginx-1.8.0.tar.gz[root@src ~]#tar -zxvf nginx-1.8.0.tar.gz[root@src ~]#cd nginx-1.8.0添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型[root@nginx-1.8.0 ~]#useradd www -M -s /sbin/nologin[root@nginx-1.8.0 ~]#vim auto/cc/gcc将这句注释掉取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"\r\n</p>\r\n<p>\r\n	我们再配置下nginx编译参数[root@nginx-1.8.0 ~]#./configure --prefix=/opt/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module[root@nginx-1.8.0 ~]#make[root@nginx-1.8.0 ~]#make install clean添加开机自启动[root@nginx-1.8.0 ~]#vim /etc/rc.local在这个文件里面添加：/opt/nginx/sbin/nginx[root@nginx-1.8.0 ~]#/opt/nginx/sbin/nginx\r\n</p>\r\n<p>\r\n	----------------------------------顺便说下：Centos7采用yum方式安装nginx-----------------------------------centos7系统库中默认是没有nginx的rpm包的，所以我们自己需要先更新下rpm依赖库1）使用yum安装nginx需要包括Nginx的库，安装Nginx的库# rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\r\n</p>\r\n<p>\r\n	2）使用下面命令安装nginx# yum install nginx\r\n</p>\r\n<p>\r\n	3）启动Nginx# service nginx start或# systemctl start nginx.service---------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	3）安装PHP由于PHP需要这些类库的支撑先下载PHP[root@opd ~]#cd /opt/src/[root@src ~]#wget http://cn2.php.net/distributions/php-5.6.10.tar.gz[root@src ~]#tar -zxvf php-5.6.10.tar.gz[root@src ~]#cd php-5.6.10我们先配置下PHP的编译参数[root@php-5.6.10 ~]#./configure --prefix=/opt/php --with-mysql --with-mysqli --with-iconv-dir --with-zlib --with-libxml-dir --enable-xml --with-curl --enable-fpm --enable-mbstring --with-gd --with-openssl --with-mhash --enable-sockets --with-xmlrpc --enable-zip --enable-soap --with-libdir=/usr/lib64 --with-jpeg-dir=/usr/lib64 --with-freetype-dir=/usr/lib64 --with-png-dir=/usr/lib64[root@php-5.6.10 ~]#make[root@php-5.6.10 ~]#make install clean复制php.ini[root@php-5.6.10 ~]#cp php.ini-development /opt/php/lib/php.ini[root@php-5.6.10 ~]#cd /opt/php/etc/[root@php-5.6.10 ~]#cp php-fpm.conf.default php-fpm.conf &nbsp; &nbsp; &nbsp; &nbsp;//在php-fpm.conf文件中可以定义php的服务端口、进程启动的用户和组权限（最好和nginx服务启动权限一直）等。使用PHP-FPM管理脚本，在编译包里面已经配置好了，只需要复制到/etc/init.d/中即可[root@php-5.6.10 ~]#cd /opt/src/php-5.6.10/sapi/fpm/[root@php-5.6.10 ~]#cp init.d.php-fpm /etc/init.d/php-fpm[root@php-5.6.10 ~]#chmod +x /etc/init.d/php-fpm启动php-fpm[root@php-5.6.10 ~]#service php-fpm start加入开机启动策略[root@php-5.6.10 ~]#chkconfig --add php-fpm[root@php-5.6.10 ~]#chkconfig php-fpm on\r\n</p>\r\n<p>\r\n	4）安装MySQL （可参考：centos 6x系统下源码安装mysql操作记录）MySQL5.7.x以上的版本不支持本安装新增了boost引擎，后续我会更新……先下载MySQL[root@opd ~]#cd /opt/src/[root@src ~]#wget  http://cdn.mysql.com//archives/mysql-5.6/mysql-5.6.21.tar.gz[root@src ~]#tar -zxvf mysql-5.6.12.tar.gz[root@src ~]#cd mysql-5.6.12我们先配置下MySQL的编译参数 一般我们就配置下安装路径就可以了 如你有特殊配置也可以在安装之后修改参数也可以的[root@mysql-5.6.12 ~]#cmake -DCMAKE_INSTALL_PREFIX=/opt/mysql -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DENABLED_LOCAL_INFILE=ON -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 -DCOMPILATION_COMMENT=\'production environment\' -DWITH_READLINE=ON -DSYSCONFDIR=/opt/mysql -DMYSQL_UNIX_ADDR=/opt/mysql/mysql.sock -DMYSQL_DATADIR=/opt/data\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------------------------------------------------------------------注意：mysql5.5以上的编译就用cmake了，而不是使用./configure了。cmake编译的优化参数说明如下：--------------------------------------DCMAKE_INSTALL_PREFIX=dir_name &nbsp; &nbsp; &nbsp; 安装的主目录-DDEFAULT_CHARSET &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;字符集，默认字符集是latin1-DDEFAULT_COLLATION=collation_name &nbsp; &nbsp; &nbsp; 服务校对，默认的是latin1_swedish_ci，可以通过SHOW COLLATION语句查看哪个校对匹配的字符集-DENABLED_LOCAL_INFILE &nbsp; &nbsp; &nbsp; 是否打开LOAD DATA INFILE的LOCAL参数-DWITH_INNOBASE_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp; 将INNODB存储引擎编译进去-DWITHOUT_FEDERATED_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp; 将FEDERATED存储引擎编译进去-DWITH_BLACKHOLE_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp; 将BLACKHOLE存储引擎编译进去-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp;不编译EXAMPLE存储引擎-DWITH_PARTITION_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;将分区存储引擎编译进去-DWITH_PERFSCHEMA_STORAGE_ENGINE=1 &nbsp; &nbsp; &nbsp; 将Performance Schema(性能视图)存储引擎编译进去-DCOMPILATION_COMMENT=string &nbsp; &nbsp; &nbsp; 编译环境描述-DWITH_READLINE=bool &nbsp; &nbsp; &nbsp; 是否使用readline库-DSYSCONFDIR=dir_name my.cnf &nbsp; &nbsp; &nbsp; 参数文件的路径-DMYSQL_UNIX_ADDR=file_name Unix socket &nbsp; &nbsp; &nbsp; &nbsp;文件的路径，socket文件用于服务器监听连接，这个参数必须是绝对路径-DENABLED_PROFILING=bool &nbsp; &nbsp; &nbsp; 是否开启profiling代码的查询（用于SHOW PROFILE and SHOW PROFILES语句）-DMYSQL_DATADIR=dir_name MySQL &nbsp; &nbsp; &nbsp; 文件目录的路径，这个参数也可以在启动MySQL的时候带上--datadir参数进行设置-DWITH_EXTRA_CHARSETS=name &nbsp; &nbsp; &nbsp; 指定额外的字符集，默认是all，包含所有的字符集。-DINSTALL_BINDIR=dir_name &nbsp; &nbsp; &nbsp;安装用户程序的路径,默认路径是DCMAKE_INSTALL_PREFIX/bin-DINSTALL_DOCDIR=dir_name &nbsp; &nbsp; &nbsp;安装文档的路径，默认路径是DCMAKE_INSTALL_PREFIX/doc-DINSTALL_INCLUDEDIR=dir_name &nbsp; &nbsp; &nbsp;安装头文件的路径，默认路径是DCMAKE_INSTALL_PREFIX/include-DINSTALL_LIBDIR=dir_name &nbsp; &nbsp; &nbsp; 安装库文件的路径，默认路径是DCMAKE_INSTALL_PREFIX/lib-DINSTALL_MANDIR=dir_name &nbsp; &nbsp; &nbsp;安装帮助手册的路径，默认路径是DCMAKE_INSTALL_PREFIX/man-DINSTALL_PLUGINDIR=dir_name &nbsp; &nbsp; &nbsp;安装插件的路径，默认路径是DCMAKE_INSTALL_PREFIX/lib/plugin-DINSTALL_SBINDIR=dir_name &nbsp; &nbsp; &nbsp;安装mysqld服务端启动脚本的路径，默认路径是DCMAKE_INSTALL_PREFIX/bin-DINSTALL_SCRIPTDIR=dir_name &nbsp; &nbsp; &nbsp;初始化MySQL数据库的数据文件路径的mysql_install_db脚本路径，默认路径是DCMAKE_INSTALL_PREFIX/scripts-DINSTALL_SQLBENCHDIR=dir_name &nbsp; &nbsp; &nbsp;安装sql-bench的路径，默认路径是DCMAKE_INSTALL_PREFIX-DINSTALL_SUPPORTFILESDIR=dir_name &nbsp; &nbsp; &nbsp;安装支持文件的路径，默认路径是DCMAKE_INSTALL_PREFIX/support-files-DMYSQL_TCP_PORT=port_num &nbsp; &nbsp; 服务器监听TCP/IP连接的端口，默认是3306\r\n</p>\r\n<p>\r\n	如若要编译进其它功能，如SSL等，则可使用类似如下选项来实现编译时使用某库或不使用某库：-DWITH_READLINE=1-DWITH_SSL=system-DWITH_ZLIB=system-DWITH_LIBWRAP=0-------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	编译需要较长的时间[root@mysql-5.6.12 ~]#make[root@mysql-5.6.12 ~]#make install clean添加mysql用户，设置mysql目录权限[root@mysql-5.6.12 ~]# useradd mysql -M -s /sbin/nologin [root@mysql-5.6.12 ~]# chown -R mysql:mysql /opt/mysql [root@mysql-5.6.12 ~]# chown -R mysql:mysql /opt/data安装数据库[root@mysql-5.6.12 ~]# cd /opt/mysql/scripts[root@scripts ~]#./mysql_install_db --user=mysql --basedir=/opt/mysql --datadir=/opt/mysql/data [root@scripts ~]#cd /opt/mysql/support-files复制mysql管理脚本[root@support-files ~]#cp mysql.server /etc/rc.d/init.d/mysql复制mysql配置文件[root@support-files ~]#cp my-default.cnf /etc/my.cnf添加mysql服务[root@support-files ~]#chkconfig --add mysql加入开机启动策略[root@support-files ~]#chkconfig mysql on[root@support-files ~]#service mysql start\r\n</p>\r\n<p>\r\n	4）nginx+php配置\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#charset koi8-r;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /Data/logs/nginx/www.wangshibo.com/access.log main;\r\n</p>\r\n<p>\r\n	error_log  /Data/logs/nginx/www.wangshibo.com/error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	## maintence\r\n</p>\r\n<p>\r\n	if ($remote_addr !~ ^(100.110.15.16|100.110.15.17|100.110.15.18|127.0.0.1)) {             //nginx访问的白名单限制\r\n</p>\r\n<p>\r\n	rewrite ^.*$ /maintence.php last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root   /var/www/vhosts/www.wangshibo.com/main;\r\n</p>\r\n<p>\r\n	try_files $uri $uri/ @router;\r\n</p>\r\n<p>\r\n	index  index.php;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /nginx_status {\r\n</p>\r\n<p>\r\n	stub_status on;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#error_page  404              /404.html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# redirect server error pages to the static page /50x.html\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	error_page   500 502 503 504  /50x.html;\r\n</p>\r\n<p>\r\n	location = /50x.html {\r\n</p>\r\n<p>\r\n	root   html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location @router {\r\n</p>\r\n<p>\r\n	rewrite ^.*$ /index.php last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {\r\n</p>\r\n<p>\r\n	root       /var/www/vhosts/www.wangshibo.com/main;\r\n</p>\r\n<p>\r\n	fastcgi_pass   127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 30;\r\n</p>\r\n<p>\r\n	fastcgi_index  index.php;\r\n</p>\r\n<p>\r\n	fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;               //这一行最好将/scripts换成$document_root，否则可能出现白面\r\n</p>\r\n<p>\r\n	#include        fastcgi_params;\r\n</p>\r\n<p>\r\n	include        fastcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ ^/(status|ping)$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	include fastcgi_params;\r\n</p>\r\n<p>\r\n	fastcgi_pass 127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('1816487c-64cd-4fff-a6ec-b91b1055638e','nginx缓存配置的操作记录梳理','nginx缓存配置的操作记录梳理','<p>\r\n	web缓存位于内容源Web服务器和客户端之间,当用户访问一个URL时,Web缓存服务器会去后端Web源服务器取回要输出的内容,然后,当下一个请求到来时,如果访问的是相同的URL，Web缓存服务器直接输出内容给客户端,而不是向源服务器再次发送请求.Web缓存降低了内容源Web服务器,数据库的负载,减少了网络延迟,提高了用户访问的响应速度,增强了用户体验.\r\n</p>\r\n<p>\r\n	web缓存服务器中,最著名的要数Squid Cache(简称为Squid)，Squid是一个流浪的自由软件的代理服务器和Web缓存服务器。----------------------------------------------------------------------------------------------------------------------------Squid可以作为网页服务器的前置cache服务器缓存相关请求来提高Web服务器的速度;Squid可以为一组人共享网络资源而缓存万维网,域名系统和其他网络搜索;Squid可以通过过滤流量帮助网络安全,到局域网通过代理上网.----------------------------------------------------------------------------------------------------------------------------然而，当下多数公司网站的图片,js,css等文件的缓存会选择Nginx的web缓存服务。\r\n</p>\r\n<p>\r\n	如下将对nginx的web缓存功能的整体配置进行梳理性记录：Nginx的Web缓存服务主要由proxy_cache相关指令集和fastcgi_cache相关指令集构成。1)proxy_cache相关指令集用于反向代理时,对后端内容源服务器进行缓存.Nginx的proxy_cache缓存功能,十分稳定,速度不逊于Squid！\r\n</p>\r\n<p>\r\n	2)fastcgi相关指令集主要用于对FastCGI的动态程序进行缓存.两者功能基本一样.在功能上,Nginx已经具备Squid所拥有的Web缓存加速功能,清除指定URL缓存功能.而在性能上,Nginx对多核CPU的利用,胜过Squid不少.另外,在反向代理,负载均衡,健康检查,后端服务器故障转移,重写,易用性上,Nginx也比Squid强大很多.这使得一台Nginx可以同时作为\"负载均衡服务器\"与\"Web缓存服务器\"来使用.\r\n</p>\r\n<p>\r\n	proxy_cache相关指令集(1)proxy_cache指令 语法: proxy_cache zone_name ;该指令用于设置哪个缓存区将被使用,zone_name的值为proxy_cache_path指令创建的缓存区的名称.\r\n</p>\r\n<p>\r\n	(2)proxy_cache_path指令语法 proxy_cache_path path [levels=number]\r\n</p>\r\n<p>\r\n	keys_zone=zone_name:zone_size[inactive=time] [max_size=size];该指令用于设置缓存文件的存放路径.\r\n</p>\r\n<p>\r\n	例如:proxy_cache_path /usr/local/nginx/proxy_cache_dir levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g ;解释：path 表示存放目录levels 表示指定该缓存空间有两层hash目录,第一层目录为1个字母,第二层目录为2个字母,保存的文件名会类似/usr/local/nginx/proxy_cache_dir/c/29/XXXXXX ;keys_zone参数用来为这个缓存区起名.500m 指内存缓存空间大小为500MBinactive的1d指如果缓存数据在1天内没有被访问,将被删除。相当于expires过期时间的配置；max_size的30g是指硬盘缓存空间为30G\r\n</p>\r\n<p>\r\n	(3)proxy_cache_methods指令 语法:proxy_cache_methods[GET HEAD POST];该指令用于设置缓存哪些HTTP方法,默认缓存HTTP GET/HEAD方法,不缓存HTTP POST 方法\r\n</p>\r\n<p>\r\n	(4)proxy_cache_min_uses指令 语法:proxy_cache_min_uses the_number该指令用于设置缓存的最小使用次数,默认值为1\r\n</p>\r\n<p>\r\n	(5)proxy_cache_valid指令 语法: proxy_cache_valid reply_code [reply_code...] time ;该指令用于对不同返回状态码的URL设置不同的缓存时间.例如:proxy_cache_valid 200 302 10m ;proxy_cache_valid 404 1m ;设置200,302状态的URL缓存10分钟,404状态的URL缓存1分钟.\r\n</p>\r\n<p>\r\n	(6)proxy_cache_key指令 语法: proxy_cache_key line ;该指令用来设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存.一般根据$host(域名),$request_uri(请求的路径)等变量组合成proxy_cache_key .\r\n</p>\r\n<p>\r\n	proxy_cache缓存配置的完整示例（多数nginx缓存的配置）：1）下载nginx和第三方的ngx_cache_purge模块的编译安装包（官网：http://labs.frickle.com/nginx_ngx_cache_purge/），将ngx_cache_purge编译到到Nginx中,用来清除指定URL的缓存[root@test-huanqiu ~]# yum install -y pcre pcre-devel openssl openssl-devel gcc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//首先安装依赖[root@test-huanqiu ~]# cd /usr/local/src                                    [root@test-huanqiu src]# wget http://labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz[root@test-huanqiu src]# wget http://nginx.org/download/nginx-1.8.0.tar.gz[root@test-huanqiu src]# tar -zxvf ngx_cache_purge-2.3.tar.gz[root@test-huanqiu src]# tar zxvf nginx-1.8.0.tar.gz[root@test-huanqiu src]# cd nginx-1.8.0.tar.gz[root@test-huanqiu nginx-1.8.0]# ./configure --user=www --group=www --add-module=../ngx_cache_purge-2.3 --prefix=/usr/local/nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre [root@test-huanqiu src]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	2）接着，在同一分区下创建两个缓存目录,分别供proxy_temp_path , proxy_cache_path指令设置缓存路径.注意:两个指定设置的缓存路径必须为同一磁盘分区,不能跨分区.[root@test-huanqiu src]# mkdir -p /usr/local/nginx/proxy_temp_path[root@test-huanqiu src]# mkdir -p /usr/local/nginx/proxy_cache_path\r\n</p>\r\n<p>\r\n	3）在配置文件nginx.conf中对扩展名为gif,jpg,jpeg,png,bmp,swf,js,css的图片,flash，javascript , css文件开启Web缓存,其他文件不缓存。\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	user  www;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	#要想开启nginx的缓存功能，需要添加此处的两行内容！\r\n</p>\r\n<p>\r\n	#设置Web缓存区名称为cache_one,内存缓存空间大小为500M,缓存的数据超过1天没有被访问就自动清除;访问的缓存数据,硬盘缓存空间大小为30G\r\n</p>\r\n<p>\r\n	proxy_cache_path /usr/local/nginx/proxy_cache_path levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g;\r\n</p>\r\n<p>\r\n	#创建缓存的时候可能生成一些临时文件存放的位置\r\n</p>\r\n<p>\r\n	proxy_temp_path /usr/local/nginx/proxy_temp_path;\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# ulimit -n 65535[root@test-huanqiu src]# mkdir /usr/local/nginx/conf/vhosts[root@test-huanqiu src]# vim /usr/local/nginx/conf/vhosts/wang.conf\r\n</p>\r\n<p>\r\n	upstream LB-WWW {\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	server 192.168.1.101:80 max_fails=3 fail_timeout=30s;     #max_fails = 3 为允许失败的次数，默认值为1\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80 max_fails=3 fail_timeout=30s;     #fail_timeout = 30s 当max_fails次失败后，暂停将请求分发到该后端服务器的时间\r\n</p>\r\n<p>\r\n	server 192.168.1.118:80 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/www-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/www-error.log;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-WWW;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;             #跟后端服务器连接超时时间，发起握手等候响应时间\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;                #后端服务器回传时间，就是在规定时间内后端服务器必须传完所有数据\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;                #连接成功后等待后端服务器的响应时间，已经进入后端的排队之中等候处理\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;                #代理请求缓冲区,会保存用户的头信息以供nginx进行处理\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;                  #同上，告诉nginx保存单个用几个buffer最大用多少空间\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;          #如果系统很忙时候可以申请最大的proxy_buffers\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;       #proxy缓存临时文件的大小\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ {\r\n</p>\r\n<p>\r\n	#使用Web缓存区cache_one，已在nginx.conf的缓存配置中命名的。\r\n</p>\r\n<p>\r\n	proxy_cache cache_one ;\r\n</p>\r\n<p>\r\n	#对不同HTTP状态码缓存设置不同的缓存时间\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 304 12h ;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 301 302 1m ;\r\n</p>\r\n<p>\r\n	proxy_cache_valid any 1m ;\r\n</p>\r\n<p>\r\n	#设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存,这里根据\"域名,URI,\r\n</p>\r\n<p>\r\n	#参数\"组合成Key\r\n</p>\r\n<p>\r\n	proxy_cache_key $host$uri$is_args$args;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#用于清除缓存的url设置\r\n</p>\r\n<p>\r\n	#假设一个URL为http://www.wangshibo.com/test.gif,那么就可以通过访问http://www.wangshibo.com/purge/test.gif清除该URL的缓存。\r\n</p>\r\n<p>\r\n	location ~ /purge(/.*) {\r\n</p>\r\n<p>\r\n	#设置只允许指定的IP或IP段才可以清除URL缓存\r\n</p>\r\n<p>\r\n	allow 127.0.0.1 ;\r\n</p>\r\n<p>\r\n	allow 192.168.0.0/16 ;\r\n</p>\r\n<p>\r\n	deny all ;\r\n</p>\r\n<p>\r\n	proxy_cache_purge cache_one $host$1$is_args$args ;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	fastcgi_cache相关指令集(1)fastcgi_cache指令语法:fastcgi_cache zone_name;该指令用于设置哪个缓存区将被使用,zone_name的值为fastcgi_cache_path指令创建的缓存区名称.\r\n</p>\r\n<p>\r\n	(2)fastcgi_cache_path指令语法:fastcgi_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size];该指令用于设置缓存文件的存放路径,例如:fastcgi_cache_path /usr/local/nginx/fastcgi_cache_dir levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g ;注意这个指令只能在http标签内配置,levels指定该缓存空间有两层hash目录,第一层目录为1个字母,第二层为2个字母,保存的文件名会类似/usr/local/nginx/fastcgi_cache_dir/c/29/XXXX;keys_zone参数用来为这个缓存区起名,500m指内存缓存空间大小为500MB;inactive的1d指如果缓存数据在1天内没有被访问,将被删除;max_size的30g是指硬盘缓存空间为30GB\r\n</p>\r\n<p>\r\n	(3)fastcgi_cache_methods指令语法:fastcgi_cache_methods [GET HEAD POST] ;该指令用于设置缓存哪些HTTP方法,默认缓存HTTP GET/HEAD 方法,不缓存HTTP POST方法\r\n</p>\r\n<p>\r\n	(4)fastcgi_cache_min_uses指令语法:fastcgi_cache_min_uses the_number;该指令用于设置缓存的最小使用次数,默认值为1.\r\n</p>\r\n<p>\r\n	(5)fastcgi_cache_valid指令fastcgi_cache_valid reply_code [reply_code...] time;该‎指令用于对不同返回状态码的URL设置不同的缓存时间.fastcgi_cache_valid 200 302 10m ;fastcgi_cache_valid 404 1m ;设置200,302状态的URL缓存10分钟,404状态的URL缓存1分钟.如果不指定状态码,直接指定缓存时间,则只有200,301,302状态的URL缓存5分钟.\r\n</p>\r\n<p>\r\n	(6)fastcgi_cache_key指令语法:fastcgi_cache_key line ;该指令用来设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存.一般根据FastCGI服务器的地址和端口,$request_uri(请求的路径)等变量组合成fastcgi_cache_key。\r\n</p>\r\n<p>\r\n	fastcgi_cache缓存配置的完整示例1)首先,在同一分区下创建两个缓存目录,分别供fastcgi_temp_path,fastcgi_cache_path指令设置缓存路径.注意:两个指定设置的缓存路径必须为同一磁盘分区,不能跨分区.[root@test-huanqiu src]# mkdir -p /usr/local/nginx/fastcgi_temp_path[root@test-huanqiu src]# mkdir -p /usr/local/nginx/fastcgi_cache_path2)配置文件nginx.conf对扩展名为gif,jpg,jpeg,png,bmp,swf,js,css的图片,Flash,JavaScript,CSS文件开启Web缓存,其他文件不缓存.\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	http{\r\n</p>\r\n<p>\r\n	#fastcgi_temp_path和fastcgi_cache_path指定的路径必须在同一分区\r\n</p>\r\n<p>\r\n	fastcgi_temp_path /usr/local/nginx/fastcgi_temp_path ;\r\n</p>\r\n<p>\r\n	#设置Web缓存区名称为cache_one,内存缓存空间大小为500MB,自动清除超过1天没有被\r\n</p>\r\n<p>\r\n	#访问的缓存数据,硬盘缓存空间大小为30G\r\n</p>\r\n<p>\r\n	fastcgi_cache_path /usr/local/nginx/fastcgi_cache_path levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g ;\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# vim /usr/local/nginx/conf/vhosts/wang.conf\r\n</p>\r\n<p>\r\n	server{\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	location ~ .*\\.(php|php5)$ {\r\n</p>\r\n<p>\r\n	#使用Web缓存区cache_one\r\n</p>\r\n<p>\r\n	fastcgi_cache cache_one ;\r\n</p>\r\n<p>\r\n	#对不同的HTTP状态码缓存设置不同的缓存时间\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid 200 10m ;\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid 301 302 1h ;\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid an 1m ;\r\n</p>\r\n<p>\r\n	#设置Web缓存的key值,Nginx根据key值md5哈希存储缓存,这里根据\"FastCGI服务\r\n</p>\r\n<p>\r\n	#器的IP,端口,请求的URI\"组合成Key。\r\n</p>\r\n<p>\r\n	fastcgi_cache_key 127.0.0.1:9000$requet_uri ;\r\n</p>\r\n<p>\r\n	#FastCGI服务器\r\n</p>\r\n<p>\r\n	fastcgi_pass 127.0.0.1:9000 ;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php ;\r\n</p>\r\n<p>\r\n	include fcgi.conf ;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	--------------------------------------------------扩展一下-----------------------------------------------------------------------------------Nginx服务器缓存机制除了上面介绍的proxy_cache之外，还包括proxy_store。这两种之间的区别可以理解为：Proxy_store 只是作为一个镜像，proxy_cache 可以提供过期时间设置Web缓存主要思想Web缓存技术的基本思想是利用客户访问的时间局部性原理，对客户已经访问过的内容在Nginx服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过Ｎginx服务器再次向后端服务器发出请求，所以能够减少Ｎginx服务器与后端服务器之间的网络流量，减轻网络拥塞，同时还能减小数据传输延迟，提高用户访问速度。同时，当后端服务器宕机时，Nginx服务器上的副本资源还能够回应相关的用户请求，这样能够提高后端服务器的鲁棒性。\r\n</p>\r\n<p>\r\n	Nginx基于Proxy Store缓存机制的原理 a）404错误驱动当Nginx服务器发现，用户请求数据在服务器本地不存在时，会产生404错误，服务器能够捕捉该错误，进一步转向后端服务器请求相关数据，最后将后端请求到的数据传回客户端，并在服务器本地缓存。\r\n</p>\r\n<p>\r\n	2）资源驱动不存在原理上基本等同于404错误驱动，不同之处在于该方法是通过location块的location if条件判断直接驱动Nginx服务器和后端服务器的通信和Ｗeb缓存，而不对资源不存在产生404错误。配置文件片段：\r\n</p>\r\n<p>\r\n	这两种缓存机制只能缓存200状态下的响应数据，同时不支持动态链接请求。比如:getsource?id=1和getsource?id=2这两个请求，返回的是相同的资源。所以实际上，一般是采用Nginx搭配Squid服务器架构实现方案。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,2,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('19799513-1631-4d18-a754-6a6044d51bfe','Mysql更换MyISAM存储引擎为Innodb的操作记录','Mysql更换MyISAM存储引擎为Innodb的操作记录','<p>\r\n	一般情况下，mysql会默认提供多种存储引擎,可以通过下面的查看:\r\n</p>\r\n<p>\r\n	1）查看mysql是否安装了innodb插件。通过下面的命令结果可知，已经安装了innodb插件。\r\n</p>\r\n<p>\r\n	mysql&gt; show plugins;\r\n</p>\r\n<p>\r\n	+------------+--------+----------------+---------+---------+\r\n</p>\r\n<p>\r\n	| Name       | Status | Type           | Library | License |\r\n</p>\r\n<p>\r\n	+------------+--------+----------------+---------+---------+\r\n</p>\r\n<p>\r\n	| binlog     | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| partition  | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| CSV        | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| MEMORY     | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| InnoDB     | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| MyISAM     | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	| MRG_MYISAM | ACTIVE | STORAGE ENGINE | NULL    | GPL     |\r\n</p>\r\n<p>\r\n	+------------+--------+----------------+---------+---------+\r\n</p>\r\n<p>\r\n	7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------如果发现没有安装innodb插件,可以执行下面语句进行安装：  mysql&gt; install plugin innodb soname \'ha_innodb.so\';----------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）查看mysql现在已提供什么存储引擎:\r\n</p>\r\n<p>\r\n	mysql&gt; show engines;\r\n</p>\r\n<p>\r\n	+------------+---------+------------------------------------------------------------+--------------+------+------------+\r\n</p>\r\n<p>\r\n	| Engine     | Support | Comment                                                    | Transactions | XA   | Savepoints |\r\n</p>\r\n<p>\r\n	+------------+---------+------------------------------------------------------------+--------------+------+------------+\r\n</p>\r\n<p>\r\n	| MRG_MYISAM | YES     | Collection of identical MyISAM tables                      | NO           | NO   | NO         |\r\n</p>\r\n<p>\r\n	| CSV        | YES     | CSV storage engine                                         | NO           | NO   | NO         |\r\n</p>\r\n<p>\r\n	| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance     | NO           | NO   | NO         |\r\n</p>\r\n<p>\r\n	| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |\r\n</p>\r\n<p>\r\n	| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables  | NO           | NO   | NO         |\r\n</p>\r\n<p>\r\n	+------------+---------+------------------------------------------------------------+--------------+------+------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）查看mysql当前默认的存储引擎:\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'%storage_engine%\';\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	| Variable_name  | Value  |\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	| storage_engine | MyISAM |\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	4）看某个表用了什么引擎(在显示结果里参数engine后面的就表示该表当前用的存储引擎):mysql&gt; show create table 表名;\r\n</p>\r\n<p>\r\n	mysql&gt; show create table wx_share_log;\r\n</p>\r\n<p>\r\n	+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Table        | Create Table                                                                                                                                                                                                                                                                                                       |\r\n</p>\r\n<p>\r\n	+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| wx_share_log | CREATE TABLE `wx_share_log` (\r\n</p>\r\n<p>\r\n	`id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'微信分享日志自增ID\',\r\n</p>\r\n<p>\r\n	`reference_id` int(11) NOT NULL COMMENT \'推荐的经纪人id\',\r\n</p>\r\n<p>\r\n	`create_time` datetime NOT NULL COMMENT \'创建时间\',\r\n</p>\r\n<p>\r\n	PRIMARY KEY (`id`)\r\n</p>\r\n<p>\r\n	) ENGINE=MyISAM AUTO_INCREMENT=13 DEFAULT CHARSET=utf8                   |\r\n</p>\r\n<p>\r\n	+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	5）如何将MyISAM库导成INNODB引擎格式的:在备份出的xxx.sql文件中把ENGINE=MyISAM全换成ENGINE=INNODB再次导入就可以了。\r\n</p>\r\n<p>\r\n	6）转换表的命令:mysql&gt; alter table 表名 engine=innodb;\r\n</p>\r\n<p>\r\n	有上面可以查到看，本机mysql使用的存储引擎是默认的MyISAN，由于业务需要，先要将其存储引擎改为Innodb。操作记录如下：\r\n</p>\r\n<p>\r\n	1）以安全模式关闭mysql[root@dev mysql5.1.57]# mysqladmin -uroot -p shutdownEnter password: [root@dev mysql5.1.57]# ps -ef|grep mysql\r\n</p>\r\n<p>\r\n	2）备份my.cnf[root@dev mysql5.1.57]# cp my.cnf my.cnf.old\r\n</p>\r\n<p>\r\n	3）修改my.cnf配置文件[root@dev mysql5.1.57]# vim my.cnf.....[mysqld] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//在这个配置区域添加下面一行，指定存储引擎为innodbdefault-storage-engine = InnoDB\r\n</p>\r\n<p>\r\n	4）删除/mysql/data目录下的ib_logfile0，ib_logfile1。删除或剪切到别处都行。[root@dev var]# mv ib_logfile0  ib_logfile1 /tmp/back/\r\n</p>\r\n<p>\r\n	5）启动mysql，登陆mysql验证存储引擎是否已切换[root@dev var]# /Data/app/mysql5.1.57/bin/mysqld_safe --defaults-file=/Data/app/mysql5.1.57/my.cnf &amp;\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'%storage_engine%\';\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	| Variable_name  | Value  |\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	| storage_engine | InnoDB |\r\n</p>\r\n<p>\r\n	+----------------+--------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,6,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('1cd0b5d6-aa79-40e4-a0de-bc8819894593','mysql操作命令梳理（5）-执行sql语句查询即mysql状态说明','mysql操作命令梳理（5）-执行sql语句查询即mysql状态说明','<p>\r\n	在日常mysql运维中，经常要查询当前mysql下正在执行的sql语句及其他在跑的mysql相关线程，这就用到mysql processlist这个命令了。\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//查询正在执行的sql语句\r\n</p>\r\n<p>\r\n	mysql&gt; show full processlist; &nbsp; &nbsp; &nbsp; //查询正在执行的完整sql语句\r\n</p>\r\n<p>\r\n	mysql&gt; kill connection id&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//停掉processlist查询出的某个线程，id是对应的id号\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| Id   | User  | Host                | db     | Command     | Time | State                                                                 | Info             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| 1574 | root  | localhost           | huanpc | Sleep       |  702 |                                                                       | NULL             |\r\n</p>\r\n<p>\r\n	| 1955 | root  | localhost           | NULL   | Query       |    0 | init                                                                  | show processlist |\r\n</p>\r\n<p>\r\n	| 1958 | slave | 192.168.1.102:37399 | NULL   | Binlog Dump |   10 | Master has sent all binlog to slave; waiting for binlog to be updated | NULL             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; kill connection 1574;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| Id   | User  | Host                | db   | Command     | Time | State                                                                 | Info             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| 1955 | root  | localhost           | NULL | Query       |    0 | init                                                                  | show processlist |\r\n</p>\r\n<p>\r\n	| 1958 | slave | 192.168.1.102:37399 | NULL | Binlog Dump |   18 | Master has sent all binlog to slave; waiting for binlog to be updated | NULL             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	除此之外，show processlist还能查看当前mysql连接数。如果是root帐号，能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。 注意：show processlist;只列出前100条如果想全列出要使用show full processlist;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	使用show status;可以比较全面地查看到mysql状态\r\n</p>\r\n<p>\r\n	mysql&gt; show status;\r\n</p>\r\n<p>\r\n	参数解释：\r\n</p>\r\n<p>\r\n	Aborted_clients &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。\r\n</p>\r\n<p>\r\n	Aborted_connects &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;尝试已经失败的MySQL服务器的连接的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Connections &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 试图连接MySQL服务器的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Created_tmp_tables &nbsp; &nbsp; &nbsp; 当执行语句时，已经被创造了的隐含临时表的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Delayed_insert_threads &nbsp;正在使用的延迟插入处理器线程的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Delayed_writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用INSERT DELAYED写入的行数。&nbsp;\r\n</p>\r\n<p>\r\n	Delayed_errors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。&nbsp;\r\n</p>\r\n<p>\r\n	Flush_commands &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行FLUSH命令的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_delete &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求从一张表中删除行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_read_first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求读入表中第一行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_read_key &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求数字基于键读行。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_read_next &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求读入基于一个键的一行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_read_rnd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求读入基于一个固定位置的一行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_update &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求更新表中一行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Handler_write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求向表中插入一行的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Key_blocks_used &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;用于关键字缓存的块的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Key_read_requests &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求从缓存读入一个键值的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Key_reads &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从磁盘物理读入一个键值的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Key_write_requests &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求将一个关键字块写入缓存次数。&nbsp;\r\n</p>\r\n<p>\r\n	Key_writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;将一个键值块物理写入磁盘的次数。&nbsp;\r\n</p>\r\n<p>\r\n	Max_used_connections &nbsp; &nbsp; &nbsp;同时使用的连接的最大数目。&nbsp;\r\n</p>\r\n<p>\r\n	Not_flushed_key_blocks &nbsp; &nbsp; 在键缓存中已经改变但是还没被清空到磁盘上的键块。&nbsp;\r\n</p>\r\n<p>\r\n	Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Open_tables &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开表的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Open_files &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开文件的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Open_streams &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;打开流的数量(主要用于日志记载）&nbsp;\r\n</p>\r\n<p>\r\n	Opened_tables &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;已经打开的表的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Questions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 发往服务器的查询的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Slow_queries &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 要花超过long_query_time时间的查询数量。&nbsp;\r\n</p>\r\n<p>\r\n	Threads_connected &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当前打开的连接的数量。&nbsp;\r\n</p>\r\n<p>\r\n	Threads_running &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不在睡眠的线程数量。&nbsp;\r\n</p>\r\n<p>\r\n	Uptime &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器工作了多少秒。\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('1e3029f1-63f9-4808-b6b4-738943f52c67','Mysql数据库之Binlog日志使用总结','Mysql数据库之Binlog日志使用总结','<p>\r\n	binlog二进制日志对于mysql数据库的重要性有多大，在此就不多说了。下面根据本人的日常操作经历，并结合网上参考资料，对binlog日志使用做一梳理：\r\n</p>\r\n<p>\r\n	一、binlog日志介绍\r\n</p>\r\n<p>\r\n	1）什么是binlogbinlog日志用于记录所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。\r\n</p>\r\n<p>\r\n	2）binlog作用因为有了数据更新的binlog，所以可以用于实时备份，与master/slave主从复制结合。\r\n</p>\r\n<p>\r\n	3）和binlog有关参数\r\n</p>\r\n<p>\r\n	log_bin设置此参数表示启用binlog功能，并指定路径名称\r\n</p>\r\n<p>\r\n	log_bin_index设置此参数是指定二进制索引文件的路径与名称\r\n</p>\r\n<p>\r\n	binlog_do_db此参数表示只记录指定数据库的二进制日志\r\n</p>\r\n<p>\r\n	binlog_ignore_db此参数表示不记录指定的数据库的二进制日志\r\n</p>\r\n<p>\r\n	max_binlog_cache_size此参数表示binlog使用的内存最大的尺寸\r\n</p>\r\n<p>\r\n	binlog_cache_size此参数表示binlog使用的内存大小，可以通过状态变量\r\n</p>\r\n<p>\r\n	binlog_cache_use和binlog_cache_disk_use来帮助测试。\r\n</p>\r\n<p>\r\n	binlog_cache_use：使用二进制日志缓存的事务数量\r\n</p>\r\n<p>\r\n	binlog_cache_disk_use:使用二进制日志缓存但超过\r\n</p>\r\n<p>\r\n	binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量\r\n</p>\r\n<p>\r\n	max_binlog_sizeBinlog最大值，最大和默认值是1GB，该设置并不能严格控制Binlog的大小，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束sync_binlog这个参数直接影响mysql的性能和完整性sync_binlog=0当事务提交后，Mysql仅仅是将binlog_cache中的数据写入Binlog文件，但不执行fsync之类的磁盘        同步指令通知文件系统将缓存刷新到磁盘，而让Filesystem自行决定什么时候来做同步，这个是性能最好的。sync_binlog=n，在进行n次事务提交以后，Mysql将执行一次fsync之类的磁盘同步指令，同志文件系统将Binlog文件缓存刷新到磁盘。Mysql中默认的设置是sync_binlog=0，即不作任何强制性的磁盘刷新指令，这时性能是最好的，但风险也是最大的。一旦系统绷Crash，在文件系统缓存中的所有Binlog信息都会丢失\r\n</p>\r\n<p>\r\n	4）binlog的删除binlog的删除可以手工删除或自动删除：\r\n</p>\r\n<p>\r\n	a）自动删除binlog通过binlog参数（expire_logs_days ）来实现mysql自动删除binlog\r\n</p>\r\n<p>\r\n	mysql&gt; show binary logs;\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'expire_logs_days\'; &nbsp; &nbsp; &nbsp;//该参数表示binlog日志自动删除/过期的天数，默认值为0，表示不自动删除\r\n</p>\r\n<p>\r\n	mysql&gt; set global expire_logs_days=3; &nbsp; &nbsp; &nbsp; &nbsp;//表示日志保留3天，3天后就自动过期。\r\n</p>\r\n<p>\r\n	b）手工删除binlog\r\n</p>\r\n<p>\r\n	mysql&gt; reset master; &nbsp; &nbsp; &nbsp; &nbsp;//删除master的binlog，即手动删除所有的binlog日志\r\n</p>\r\n<p>\r\n	mysql&gt; reset slave; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//删除slave的中继日志\r\n</p>\r\n<p>\r\n	mysql&gt; purge master logs before \'2012-03-30 17:20:00\'; &nbsp; &nbsp; &nbsp; &nbsp; //删除指定日期以前的日志索引中binlog日志文件\r\n</p>\r\n<p>\r\n	mysql&gt; purge master logs to \'binlog.000002\'; &nbsp; &nbsp; &nbsp; //删除指定日志文件的日志索引中binlog日志文件\r\n</p>\r\n<p>\r\n	mysql&gt; set sql_log_bin=1/0; &nbsp; &nbsp; &nbsp; //如果用户有super权限，可以启用或禁用当前会话的binlog记录\r\n</p>\r\n<p>\r\n	mysql&gt; show master logs; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//查看master的binlog日志列表\r\n</p>\r\n<p>\r\n	mysql&gt; show binary logs; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //查看master的binlog日志文件大小\r\n</p>\r\n<p>\r\n	mysql&gt; show master status; &nbsp; &nbsp; //用于提供master二进制日志文件的状态信息\r\n</p>\r\n<p>\r\n	mysql&gt; show slave hosts; &nbsp; &nbsp; &nbsp; &nbsp;//显示当前注册的slave的列表。不以--report-host=slave_name选项为开头的slave不会显示在本列表中\r\n</p>\r\n<p>\r\n	mysql&gt; flush logs; &nbsp; &nbsp; //产生一个新的binlog日志文件\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql binlog日志自动清理及手动删除案例说明：\r\n</p>\r\n<p>\r\n	当开启MySQL数据库主从时，会产生大量如mysql-bin.00000* log的文件，这会大量耗费您的硬盘空间。\r\n</p>\r\n<p>\r\n	mysql-bin.000001\r\n</p>\r\n<p>\r\n	mysql-bin.000002\r\n</p>\r\n<p>\r\n	mysql-bin.000003\r\n</p>\r\n<p>\r\n	mysql-bin.000004\r\n</p>\r\n<p>\r\n	mysql-bin.000005\r\n</p>\r\n<p>\r\n	…\r\n</p>\r\n<p>\r\n	删除这些binlog日志有三种解决方法：\r\n</p>\r\n<p>\r\n	1.关闭mysql主从，关闭binlog；\r\n</p>\r\n<p>\r\n	实例操作如下：\r\n</p>\r\n<p>\r\n	[root@huqniupc ~]# vim /etc/my.cnf    //注释掉log-bin和binlog_format\r\n</p>\r\n<p>\r\n	# Replication Master Server (default)\r\n</p>\r\n<p>\r\n	# binary logging is required for replication\r\n</p>\r\n<p>\r\n	# log-bin=mysql-bin\r\n</p>\r\n<p>\r\n	# binary logging format - mixed recommended\r\n</p>\r\n<p>\r\n	# binlog_format=mixed\r\n</p>\r\n<p>\r\n	然后重启数据库\r\n</p>\r\n<p>\r\n	2.开启mysql主从，设置expire_logs_days；\r\n</p>\r\n<p>\r\n	实例操作如下：\r\n</p>\r\n<p>\r\n	[root@huqniupc ~]# vim /etc/my.cnf  //修改expire_logs_days,x是自动删除的天数，一般将x设置为短点，如10\r\n</p>\r\n<p>\r\n	expire_logs_days = x  //二进制日志自动删除的天数。默认值为0,表示“没有自动删除”\r\n</p>\r\n<p>\r\n	此方法需要重启mysql\r\n</p>\r\n<p>\r\n	当然也可以不重启mysql,开启mysql主从，直接在mysql里设置expire_logs_days\r\n</p>\r\n<p>\r\n	&gt; show binary logs;\r\n</p>\r\n<p>\r\n	&gt; show variables like \'%log%\';\r\n</p>\r\n<p>\r\n	&gt; set global expire_logs_days = 10;\r\n</p>\r\n<p>\r\n	3.手动清除binlog文件，(比如Mysql&gt; PURGE MASTER LOGS TO ‘MySQL-bin.010′;）\r\n</p>\r\n<p>\r\n	实例操作如下：\r\n</p>\r\n<p>\r\n	[root@huqniupc ~]# /usr/local/mysql/bin/mysql -u root -p\r\n</p>\r\n<p>\r\n	&gt; PURGE MASTER LOGS BEFORE DATE_SUB(CURRENT_DATE, INTERVAL 10 DAY);   //删除10天前的MySQL binlog日志,附录2有关于PURGE MASTER LOGS手动删除用法及示例\r\n</p>\r\n<p>\r\n	&gt; show master logs;\r\n</p>\r\n<p>\r\n	也可以重置master，删除所有binlog文件：\r\n</p>\r\n<p>\r\n	# /usr/local/mysql/bin/mysql -u root -p\r\n</p>\r\n<p>\r\n	&gt; reset master;  //附录3有清除binlog时，对从mysql的影响说明\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	PURGE MASTER LOGS手动删除用法及示例,MASTER和BINARY是同义词\r\n</p>\r\n<p>\r\n	&gt; PURGE {MASTER | BINARY} LOGS TO \'log_name\'\r\n</p>\r\n<p>\r\n	&gt; PURGE {MASTER | BINARY} LOGS BEFORE \'date\'\r\n</p>\r\n<p>\r\n	删除指定的日志或日期之前的日志索引中的所有二进制日志。这些日志也会从记录在日志索引文件中的清单中被删除MySQL BIN-LOG 日志，这样被给定的日志成为第一个。\r\n</p>\r\n<p>\r\n	实例：\r\n</p>\r\n<p>\r\n	&gt; PURGE MASTER LOGS TO \'MySQL-bin.010\';  //清除MySQL-bin.010日志\r\n</p>\r\n<p>\r\n	&gt; PURGE MASTER LOGS BEFORE \'2008-06-22 13:00:00\';   //清除2008-06-22 13:00:00前binlog日志\r\n</p>\r\n<p>\r\n	&gt; PURGE MASTER LOGS BEFORE DATE_SUB( NOW( ), INTERVAL 3 DAY);  //清除3天前binlog日志BEFORE，变量的date自变量可以为\'YYYY-MM-DD hh:mm:ss\'格式。\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	5）清除binlog时，对从mysql的影响如果有一个活跃的slave从属服务器，该服务器当前正在读取您正在试图删除的日志之一，则本语句不会起作用，而是会失败，并伴随一个错误；不过如果slave从属服务器是关闭的（或master-slave主从关系关闭），并且碰巧清理了其想要读取的日志之一，则slave从属服务器启动后不能复制；当从属服务器正在复制时，本语句可以安全运行，不需要停止它们。\r\n</p>\r\n<p>\r\n	6）binglog的查看通过mysqlbinlog命令可以查看binlog的内容\r\n</p>\r\n<p>\r\n	[root@localhost ~]# mysqlbinlog  /home/mysql/binlog/binlog.000003  | more/*!40019 SET @@session.max_insert_delayed_threads=0*/;/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;DELIMITER /*!*/;# at 4#120330 16:51:46 server id 1  end_log_pos 98    Start: binlog v 4, server v 5.0.45-log created 120330 16:51:46# Warning: this binlog was not closed properly. Most probably mysqld crashed writing it.# at 196#120330 17:54:15 server id 1  end_log_pos 294   Query   thread_id=3     exec_time=2     error_code=0SET TIMESTAMP=1333101255/*!*/;insert into tt7 select * from tt7/*!*/;# at 294#120330 17:54:46 server id 1  end_log_pos 388   Query   thread_id=3     exec_time=28    error_code=0SET TIMESTAMP=1333101286/*!*/;alter table tt7 engine=innodb/*!*/;&nbsp;\r\n</p>\r\n<p>\r\n	解析binlog格式：\r\n</p>\r\n<p>\r\n	位置位于文件中的位置，“at 196”说明“事件”的起点，是以第196字节开始；\r\n</p>\r\n<p>\r\n	“end_log_pos 294”说明以第294字节结束\r\n</p>\r\n<p>\r\n	&nbsp;时间戳事件发生的时间戳：“120330 17:54:46”&nbsp;\r\n</p>\r\n<p>\r\n	事件执行时间事件执行花费的时间:\"exec_time=28\"&nbsp;\r\n</p>\r\n<p>\r\n	错误码错误码为：“error_code=0” 服务器的标识服务器的标识id：“server id 1”\r\n</p>\r\n<p>\r\n	注意下面几点：1.mysql的日志切不可想象是可以恢复到任何时间的状态，这个恢复是有前提的！至少得有一个从日志记录开始后的数据库备份，通过日志恢复数据库实际上只是一个对以前操作的回放过程而已，不用想得太复杂。既然是回放操作，那么就得注意了，如果是执行了两次恢复那就相当于是回放了两次，后果可想而知。所以：1）恢复前务必先备份数据.2）由于二进制文件多,并且需要恢复的数据跨度大,可以考虑将日志文件合并在恢复.\r\n</p>\r\n<p>\r\n	2. 开启binlog日志功能要想通过日志恢复数据库，必须首先在my.cnf文件里定义，log-bin=mysql-bin，这样产生的binlog日志名就是以mysql-bin命名的\r\n</p>\r\n<p>\r\n	3.什么时候会生成新的binlog文件1）在备份的时候加入--flush-logs2）重新启动mysql服务的时候特别提示，mysql每次启动都会重新生成一个类似mysql-bin.00000n的文件，如果你的mysql每天都要重新启动一次的话，这时候你就要特别注意不要选错日志文件了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	二、binlog日志格式介绍\r\n</p>\r\n<p>\r\n	（1）Mysql binlog日志有三种格式，分别是Statement、MiXED、ROW\r\n</p>\r\n<p>\r\n	1）Statement：每一条会修改数据的sql都会记录在binlog中优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).\r\n</p>\r\n<p>\r\n	使用以下函数的语句也无法被复制：* LOAD_FILE()* UUID()* USER()* FOUND_ROWS()* SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)\r\n</p>\r\n<p>\r\n	同时在INSERT ...SELECT 会产生比 RBR 更多的行级锁\r\n</p>\r\n<p>\r\n	2）Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。\r\n</p>\r\n<p>\r\n	3）Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。\r\n</p>\r\n<p>\r\n	Mixed日志说明：在slave日志同步过程中，对于使用now这样的时间函数，MIXED日志格式，会在日志中产生对应的unix_timestamp()*1000的时间字符串，slave在完成同步时，取用的是sqlEvent发生的时间来保证数据的准确性。另外对于一些功能性函数slave能完成相应的数据同步，而对于上面指定的一些类似于UDF函数，导致Slave无法知晓的情况，则会采用ROW格式存储这些Binlog，以保证产生的Binlog可以供Slave完成数据同步。\r\n</p>\r\n<p>\r\n	（2）binlog基本配制与格式设定1）基本配制binlog日志格式可以通过mysql的my.cnf文件的属性binlog_format指定。如以下：binlog_format           = MIXED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//binlog日志格式log_bin                  =目录/mysql-bin.log &nbsp; &nbsp; &nbsp; //binlog日志名expire_logs_days    = 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //binlog过期清理时间max_binlog_size    100m &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//binlog每个日志文件大小\r\n</p>\r\n<p>\r\n	binlog-do-db=需要备份的数据库名，如果备份多个数据库，重复设置这个选项即可binlog-ignore-db=不需要备份的数据库苦命，如果备份多个数据库，重复设置这个选项即可\r\n</p>\r\n<p>\r\n	2）Binlog日志格式选择Mysql默认是使用Statement日志格式，推荐使用MIXED.由于一些特殊使用，可以考虑使用ROWED，如自己通过binlog日志来同步数据的修改，这样会节省很多相关操作。对于binlog数据处理会变得非常轻松,相对mixed，解析也会很轻松(当然前提是增加的日志量所带来的IO开销在容忍的范围内即可)。\r\n</p>\r\n<p>\r\n	3）mysqlbinlog格式选择mysql对于日志格式的选定原则:如果是采用 INSERT，UPDATE，DELETE 等直接操作表的情况，则日志格式根据 binlog_format 的设定而记录,如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何 都采用 SBR 模式记录\r\n</p>\r\n<p>\r\n	（3）Mysql Binlog日志分析\r\n</p>\r\n<p>\r\n	通过MysqlBinlog指令查看具体的mysql日志，如下:\r\n</p>\r\n<p>\r\n	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n</p>\r\n<p>\r\n	SET TIMESTAMP=1350355892/*!*/;\r\n</p>\r\n<p>\r\n	BEGIN\r\n</p>\r\n<p>\r\n	/*!*/;\r\n</p>\r\n<p>\r\n	# at 1643330\r\n</p>\r\n<p>\r\n	#121016 10:51:32 server id 1  end_log_pos 1643885        Query     thread_id=272571   exec_time=0   error_code=0\r\n</p>\r\n<p>\r\n	SET TIMESTAMP=1350355892/*!*/;\r\n</p>\r\n<p>\r\n	Insert into T_test….)\r\n</p>\r\n<p>\r\n	/*!*/;\r\n</p>\r\n<p>\r\n	# at 1643885\r\n</p>\r\n<p>\r\n	#121016 10:51:32 server id 1  end_log_pos 1643912        Xid = 0\r\n</p>\r\n<p>\r\n	COMMIT/*!*/;\r\n</p>\r\n<p>\r\n	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n</p>\r\n<p>\r\n	1.开始事物的时间:\r\n</p>\r\n<p>\r\n	SET TIMESTAMP=1350355892/*!*/;\r\n</p>\r\n<p>\r\n	BEGIN\r\n</p>\r\n<p>\r\n	2.sqlevent起点\r\n</p>\r\n<p>\r\n	#at 1643330 :为事件的起点，是以1643330字节开始。\r\n</p>\r\n<p>\r\n	3.sqlevent 发生的时间点\r\n</p>\r\n<p>\r\n	#121016 10:51:32:是事件发生的时间，\r\n</p>\r\n<p>\r\n	4.serverId\r\n</p>\r\n<p>\r\n	server id 1 :为master 的serverId\r\n</p>\r\n<p>\r\n	5.sqlevent终点及花费时间，错误码\r\n</p>\r\n<p>\r\n	end_log_pos 1643885:为事件的终点，是以1643885 字节结束。\r\n</p>\r\n<p>\r\n	execTime 0: 花费的时间\r\n</p>\r\n<p>\r\n	error_code=0:错误码\r\n</p>\r\n<p>\r\n	Xid:事件指示提交的XA事务\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	三、mysql日志（重点binlog日志）的优化说明MySQL系统的伸缩性很强，既可以在充足的硬件资源环境下高效运行，也可以在极少资源环境下很好的运行，但不管怎样，尽可能充足的硬件资源对MySQL的性能提升总是有帮助的。\r\n</p>\r\n<p>\r\n	下面着重分析一下MySQL的日志（主要是Binlog）对系统性能的影响，并根据日志的相关特性得出相应的优化思路。\r\n</p>\r\n<p>\r\n	1）日志产生的性能影响由于日志的记录带来的直接性能损耗就是数据库系统中最为昂贵的IO资源。\r\n</p>\r\n<p>\r\n	MySQL的日志主要包括错误日志（ErrorLog），更新日志（UpdateLog），二进制日志（Binlog），查询日志（QueryLog），慢查询日志（SlowQueryLog）等。特别注意：更新日志是老版本的MySQL才有的，目前已经被二进制日志替代。\r\n</p>\r\n<p>\r\n	在默认情况下，系统仅仅打开错误日志，关闭了其他所有日志，以达到尽可能减少IO损耗提高系统性能的目的。但是在一般稍微重要一点的实际应用场景中，都至少需要打开二进制日志，因为这是MySQL很多存储引擎进行增量备份的基础，也是MySQL实现复制的基本条件。有时候为了进一步的mysql性能优化，定位执行较慢的SQL语句，很多系统也会打开慢查询日志来记录执行时间超过特定数值（由我们自行设置）的SQL语句。\r\n</p>\r\n<p>\r\n	一般情况下，在生产系统中很少有系统会打开查询日志。因为查询日志打开之后会将MySQL中执行的每一条Query都记录到日志中，会该系统带来比较大的IO负担，而带来的实际效益却并不是非常大。一般只有在开发测试环境中，为了定位某些功能具体使用了哪些SQL语句的时候，才会在短时间段内打开该日志来做相应的分析。所以，在MySQL系统中，会对性能产生影响的MySQL日志（不包括各存储引擎自己的日志）主要就是Binlog了。\r\n</p>\r\n<p>\r\n	2）Binlog 相关参数及优化策略我们首先看看Binlog的相关参数，通过执行如下命令可以获得关于Binlog的相关参数。当然，其中也显示出了“innodb_locks_unsafe_for_binlog”这个Innodb存储引擎特有的与Binlog相关的参数：\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'%binlog%\';\r\n</p>\r\n<p>\r\n	+-----------------------------------------+----------------------+\r\n</p>\r\n<p>\r\n	| Variable_name                           | Value                |\r\n</p>\r\n<p>\r\n	+-----------------------------------------+----------------------+\r\n</p>\r\n<p>\r\n	| binlog_cache_size                       | 16777216             |\r\n</p>\r\n<p>\r\n	| binlog_checksum                         | CRC32                |\r\n</p>\r\n<p>\r\n	| binlog_direct_non_transactional_updates | OFF                  |\r\n</p>\r\n<p>\r\n	| binlog_error_action                     | IGNORE_ERROR         |\r\n</p>\r\n<p>\r\n	| binlog_format                           | MIXED                |\r\n</p>\r\n<p>\r\n	| binlog_gtid_simple_recovery             | OFF                  |\r\n</p>\r\n<p>\r\n	| binlog_max_flush_queue_time             | 0                    |\r\n</p>\r\n<p>\r\n	| binlog_order_commits                    | ON                   |\r\n</p>\r\n<p>\r\n	| binlog_row_image                        | FULL                 |\r\n</p>\r\n<p>\r\n	| binlog_rows_query_log_events            | OFF                  |\r\n</p>\r\n<p>\r\n	| binlog_stmt_cache_size                  | 32768                |\r\n</p>\r\n<p>\r\n	| binlogging_impossible_mode              | IGNORE_ERROR         |\r\n</p>\r\n<p>\r\n	| innodb_api_enable_binlog                | OFF                  |\r\n</p>\r\n<p>\r\n	| innodb_locks_unsafe_for_binlog          | OFF                  |\r\n</p>\r\n<p>\r\n	| max_binlog_cache_size                   | 18446744073709547520 |\r\n</p>\r\n<p>\r\n	| max_binlog_size                         | 1073741824           |\r\n</p>\r\n<p>\r\n	| max_binlog_stmt_cache_size              | 18446744073709547520 |\r\n</p>\r\n<p>\r\n	| simplified_binlog_gtid_recovery         | OFF                  |\r\n</p>\r\n<p>\r\n	| sync_binlog                             | 1                    |\r\n</p>\r\n<p>\r\n	+-----------------------------------------+----------------------+\r\n</p>\r\n<p>\r\n	19 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	“binlog_cache_size\"：在事务过程中容纳二进制日志SQL语句的缓存大小。二进制日志缓存是服务器支持事务存储引擎并且服务器启用了二进制日志(—log-bin选项)的前提下为每个客户端分配的内存，注意，是每个Client都可以分配设置大小的binlogcache空间。如果读者朋友的系统中经常会出现多语句事务的华，可以尝试增加该值的大小，以获得更有的性能。当然，我们可以通过MySQL的以下两个状态变量来判断当前的binlog_cache_size的状况：Binlog_cache_use和Binlog_cache_disk_use。\r\n</p>\r\n<p>\r\n	“max_binlog_cache_size”：和\"binlog_cache_size\"相对应，但是所代表的是binlog能够使用的最大cache内存大小。当我们执行多语句事务的时候，max_binlog_cache_size如果不够大的话，系统可能会报出“Multi-statementtransactionrequiredmorethan\'max_binlog_cache_size\'bytesofstorage”的错误。\r\n</p>\r\n<p>\r\n	“max_binlog_size”：Binlog日志最大值，一般来说设置为512M或者1G，但不能超过1G。该大小并不能非常严格控制Binlog大小，尤其是当到达Binlog比较靠近尾部而又遇到一个较大事务的时候，系统为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的所有SQL都记录进入当前日志，直到该事务结束。这一点和Oracle的Redo日志有点不一样，因为Oracle的Redo日志所记录的是数据文件的物理位置的变化，而且里面同时记录了Redo和Undo相关的信息，所以同一个事务是否在一个日志中对Oracle来说并不关键。而MySQL在Binlog中所记录的是数据库逻辑变化信息，MySQL称之为Event，实际上就是带来数据库变化的DML之类的Query语句。\r\n</p>\r\n<p>\r\n	“sync_binlog”：这个参数是对于MySQL系统来说是至关重要的，他不仅影响到Binlog对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。对于“sync_binlog”参数的各种设置的说明如下：\r\n</p>\r\n<p>\r\n	sync_binlog=0，当事务提交之后，MySQL不做fsync之类的磁盘同步指令刷新binlog_cache中的信息到磁盘，而让Filesystem自行决定什么时候来做同步，或者cache满了之后才同步到磁盘。\r\n</p>\r\n<p>\r\n	sync_binlog=n，当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将binlog_cache中的数据强制写入磁盘。\r\n</p>\r\n<p>\r\n	在MySQL中系统默认的设置是sync_binlog=0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使系统Crash，也最多丢失binlog_cache中未完成的一个事务，对实际数据没有任何实质性影响。从以往经验和相关测试来看，对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。\r\n</p>\r\n<p>\r\n	另：MySQL的复制（Replication），实际上就是通过将Master端的Binlog通过利用IO线程通过网络复制到Slave端，然后再通过SQL线程解析Binlog中的日志再应用到数据库中来实现的。所以，Binlog量的大小对IO线程以及Msater和Slave端之间的网络都会产生直接的影响。\r\n</p>\r\n<p>\r\n	MySQL中Binlog的产生量是没办法改变的，只要我们的Query改变了数据库中的数据，那么就必须将该Query所对应的Event记录到Binlog中。那我们是不是就没有办法优化复制了呢？当然不是，在MySQL复制环境中，实际上是是有8个参数可以让我们控制需要复制或者需要忽略而不进行复制的DB或者Table的，分别为：\r\n</p>\r\n<p>\r\n	Binlog_Do_DB：设定哪些数据库（Schema）需要记录Binlog；\r\n</p>\r\n<p>\r\n	Binlog_Ignore_DB：设定哪些数据库（Schema）不要记录Binlog；\r\n</p>\r\n<p>\r\n	Replicate_Do_DB：设定需要复制的数据库（Schema），多个DB用逗号（“,”）分隔；\r\n</p>\r\n<p>\r\n	Replicate_Ignore_DB：设定可以忽略的数据库（Schema）；\r\n</p>\r\n<p>\r\n	Replicate_Do_Table：设定需要复制的Table；\r\n</p>\r\n<p>\r\n	Replicate_Ignore_Table：设定可以忽略的Table；\r\n</p>\r\n<p>\r\n	Replicate_Wild_Do_Table：功能同Replicate_Do_Table，但可以带通配符来进行设置；\r\n</p>\r\n<p>\r\n	Replicate_Wild_Ignore_Table：功能同Replicate_Ignore_Table，可带通配符设置；\r\n</p>\r\n<p>\r\n	通过上面这八个参数，我们就可以非常方便按照实际需求，控制从Master端到Slave端的Binlog量尽可能的少，从而减小Master端到Slave端的网络流量，减少IO线程的IO量，还能减少SQL线程的解析与应用SQL的数量，最终达到改善Slave上的数据延时问题。\r\n</p>\r\n<p>\r\n	实际上，上面这八个参数中的前面两个是设置在Master端的，而后面六个参数则是设置在Slave端的。虽然前面两个参数和后面六个参数在功能上并没有非常直接的关系，但是对于优化MySQL的Replication来说都可以启到相似的功能。当然也有一定的区别，其主要区别如下：\r\n</p>\r\n<p>\r\n	如果在Master端设置前面两个参数，不仅仅会让Master端的Binlog记录所带来的IO量减少，还会让Master端的IO线程就可以减少Binlog的读取量，传递给Slave端的IO线程的Binlog量自然就会较少。这样做的好处是可以减少网络IO，减少Slave端IO线程的IO量，减少Slave端的SQL线程的工作量，从而最大幅度的优化复制性能。当然，在Master端设置也存在一定的弊端，因为MySQL的判断是否需要复制某个Event不是根据产生该Event的Query所更改的数据\r\n</p>\r\n<p>\r\n	所在的DB，而是根据执行Query时刻所在的默认Schema，也就是我们登录时候指定的DB或者运行“USEDATABASE”中所指定的DB。只有当前默认DB和配置中所设定的DB完全吻合的时候IO线程才会将该Event读取给Slave的IO线程。所以如果在系统中出现在默认DB和设定需要复制的DB不一样的情况下改变了需要复制的DB中某个Table的数据的时候，该Event是不会被复制到Slave中去的，这样就会造成Slave端的数据和Master的数据不一致的情况出现。同样，如果在默认Schema下更改了不需要复制的Schema中的数据，则会被复制到Slave端，当Slave端并没有该Schema的时候，则会造成复制出错而停止。\r\n</p>\r\n<p>\r\n	而如果是在Slave端设置后面的六个参数，在性能优化方面可能比在Master端要稍微逊色一点，因为不管是需要还是不需要复制的Event都被会被IO线程读取到Slave端，这样不仅仅增加了网络IO量，也给Slave端的IO线程增加了RelayLog的写入量。但是仍然可以减少Slave的SQL线程在Slave端的日志应用量。虽然性能方面稍有逊色，但是在Slave端设置复制过滤机制，可以保证不会出现因为默认Schema的问题而造成Slave和Master数据不一致或者复制出错的问题。\r\n</p>\r\n<p>\r\n	3）慢查询日志Query Log 相关参数及使用建议再来看看SlowQueryLog的相关参数配置。有些时候，我们为了定位系统中效率比较地下的Query语句，则需要打开慢查询日志，也就是SlowQueryLog。我们可以如下查看系统慢查询日志的相关设置：\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'log_slow%\';\r\n</p>\r\n<p>\r\n	+------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name | Value |\r\n</p>\r\n<p>\r\n	+------------------+-------+\r\n</p>\r\n<p>\r\n	| log_slow_queries | ON |\r\n</p>\r\n<p>\r\n	+------------------+-------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'long_query%\';\r\n</p>\r\n<p>\r\n	+-----------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name | Value |\r\n</p>\r\n<p>\r\n	+-----------------+-------+\r\n</p>\r\n<p>\r\n	| long_query_time | 1 |\r\n</p>\r\n<p>\r\n	+-----------------+-------+\r\n</p>\r\n<p>\r\n	1 row in set (0.01 sec)\r\n</p>\r\n<p>\r\n	“log_slow_queries”参数显示了系统是否已经打开SlowQueryLog功能，而“long_query_time”参数则告诉我们当前系统设置的SlowQuery记录执行时间超过多长的Query。在MySQLAB发行的MySQL版本中SlowQueryLog可以设置的最短慢查询时间为1秒，这在有些时候可能没办法完全满足我们的要求，如果希望能够进一步缩短慢查询的时间限制，可以使用Percona提供的microslow-patch（件成为mslPatch）来突破该限制。mslpatch不仅仅能将慢查询时间减小到毫秒级别，同时还能通过一些特定的规则来过滤记录的SQL，如仅记录涉及到某个表的SlowQuery等等附加功能。\r\n</p>\r\n<p>\r\n	打开SlowQueryLog功能对系统性能的整体影响没有Binlog那么大，毕竟SlowQueryLog的数据量比较小，带来的IO损耗也就较小，但是，系统需要计算每一条Query的执行时间，所以消耗总是会有一些的，主要是CPU方面的消耗。如果大家的系统在CPU资源足够丰富的时候，可以不必在乎这一点点损耗，毕竟他可能会给我们带来更大性能优化的收获。但如果我们的CPU资源也比较紧张的时候，也完全可以在大部分时候关闭该功能，而只需要间断性的打开SlowQueryLog功能来定位可能存在的慢查询。\r\n</p>\r\n<p>\r\n	MySQL的其他日志由于使用很少（QueryLog）或者性能影响很少，在此就不做过多分析了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,7,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('218bb56e-9bd3-4d44-9a00-e319b4480e0f','mysql操作命令梳理（1）-索引','mysql操作命令梳理（1）-索引','<p>\r\n	1、创建索引索引的创建可以在CREATE TABLE语句中进行，也可以单独用CREATE INDEX或ALTER TABLE来给表增加索引。以下命令语句分别展示了如何创建主键索引（PRIMARY KEY），联合索引（UNIQUE）和普通索引（INDEX）的方法。\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 ADD INDEX 索引名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 ADD UNIQUE 索引名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 ADD PRIMARY KEY 索引名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;CREATE INDEX 索引名 ON 表名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;CREATE UNIQUE INDEX 索引名 ON 表名 列名;\r\n</p>\r\n<p>\r\n	例如：\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE `article` ADD INDEX `id`;               //给article表增加id索引\r\n</p>\r\n<p>\r\n	或者：\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE `article` ADD INDEX (`id`,`order_id`);         //给article表增加id索引，order_id索引\r\n</p>\r\n<p>\r\n	2、重建索引重建索引在常规的数据库维护操作中经常使用。在数据库运行了较长时间后，索引都有损坏的可能，这时就需要重建。对数据重建索引可以起到提高检索效率。\r\n</p>\r\n<p>\r\n	mysql&gt; REPAIR TABLE 表名 QUICK;\r\n</p>\r\n<p>\r\n	3、查询数据表索引MySQL查询表索引命令的有两种命令形式：\r\n</p>\r\n<p>\r\n	mysql&gt; SHOW INDEX FROM 表名;\r\n</p>\r\n<p>\r\n	或者：\r\n</p>\r\n<p>\r\n	mysql&gt; SHOW keys FROM 表名;\r\n</p>\r\n<p>\r\n	比如：\r\n</p>\r\n<p>\r\n	mysql&gt; SHOW INDEX FROM uc_member;\r\n</p>\r\n<p>\r\n	+-----------+------------+---------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+\r\n</p>\r\n<p>\r\n	| Table     | Non_unique | Key_name            | Seq_in_index | Column_name     | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment |\r\n</p>\r\n<p>\r\n	+-----------+------------+---------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+\r\n</p>\r\n<p>\r\n	| uc_member |          0 | PRIMARY             |            1 | member_id       | A         |        1099 |     NULL | NULL   |      | BTREE      |         |\r\n</p>\r\n<p>\r\n	| uc_member |          1 | idx_nickname_passwd |            1 | member_nickname | A         |         549 |     NULL | NULL   |      | BTREE      |         |\r\n</p>\r\n<p>\r\n	| uc_member |          1 | idx_nickname_passwd |            2 | member_password | A         |        1099 |     NULL | NULL   |      | BTREE      |         |\r\n</p>\r\n<p>\r\n	| uc_member |          1 | member_mobile       |            1 | member_mobile   | A         |        1099 |     NULL | NULL   |      | BTREE      |         |\r\n</p>\r\n<p>\r\n	+-----------+------------+---------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	解释：Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。Key_name 索引的名称。Seq_in_index 索引中的列序列号，从1开始。Column_name 列名称。Collation 列以什么方式存储在索引中。在MySQL中，有值‘A\'（升序）或NULL（无分类）。Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机 会就越大。Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。\r\n</p>\r\n<p>\r\n	4、删除索引删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：\r\n</p>\r\n<p>\r\n	mysql&gt;DROP index 索引名 ON 表名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 DROP INDEX 索引名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 DROP UNIQUE 索引名 列名;\r\n</p>\r\n<p>\r\n	mysql&gt;ALTER TABLE 表名 DROP PRIMARY KEY 索引名 列名;\r\n</p>\r\n<p>\r\n	在上面前三条语句中，都删除了table_name中的索引index_name。而在最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此也可不指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。\r\n</p>\r\n<p>\r\n	---------------------------------------索引、主键、唯一索引、联合索引梳理--------------------------------------------说下Mysql索引概念：索引就好比一本书的目录，它会让你更快的找到内容，显然目录（索引）并不是越多越好，假如这本书1000页，有500也是目录，它当然效率低，目录是要占纸张的,而索引是要占磁盘空间的。\r\n</p>\r\n<p>\r\n	Mysql索引主要有两种结构：hash和B+树：hash:hsah索引在mysql比较少用,他以把数据的索引以hash形式组织起来,因此当查找某一条记录的时候,速度非常快.当时因为是hash结构,每个键只对应一个值,而且是散列的方式分布.所以他并不支持范围查找和排序等功能.B+树:b+tree是mysql使用最频繁的一个索引数据结构,数据结构以平衡树的形式来组织,因为是树型结构,所以更适合用来处理排序,范围查找等功能.相对hash索引,B+树在查找单条记录的速度虽然比不上hash索引,但是因为更适合排序等操作,所以他更受用户的欢迎.毕竟不可能只对数据库进行单条记录的操作.\r\n</p>\r\n<p>\r\n	Mysql常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引\r\n</p>\r\n<p>\r\n	PRIMARY KEY(主键索引)：    ALTER TABLE 表名 ADD PRIMARY KEY 列名\r\n</p>\r\n<p>\r\n	UNIQUE(唯一索引)：     ALTER TABLE 表名 ADD UNIQUE 列名\r\n</p>\r\n<p>\r\n	INDEX(普通索引)：    ALTER TABLE 表名 ADD INDEX 索引名 列名\r\n</p>\r\n<p>\r\n	FULLTEXT(全文索引):  ALTER TABLE 表名 ADD FULLTEXT 列名\r\n</p>\r\n<p>\r\n	组合索引：ALTER TABLE 表名 ADD INDEX 索引名 (列名1,列名2, 列名3)\r\n</p>\r\n<p>\r\n	Mysql各种索引区别：普通索引：最基本的索引，没有任何限制唯一索引：与\"普通索引\"类似，不同的就是：索引列的值必须唯一，但允许有空值。主键索引：它 是一种特殊的唯一索引，不允许有空值。 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。\r\n</p>\r\n<p>\r\n	索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。\r\n</p>\r\n<p>\r\n	普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。\r\n</p>\r\n<p>\r\n	主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。\r\n</p>\r\n<p>\r\n	主键分为复合主键和联合主键复合主键就是指你表的主键含有一个以上的字段组成 。例如：\r\n</p>\r\n<p>\r\n	create table test\r\n</p>\r\n<p>\r\n	(\r\n</p>\r\n<p>\r\n	name varchar(19),\r\n</p>\r\n<p>\r\n	id number,\r\n</p>\r\n<p>\r\n	value varchar(10),\r\n</p>\r\n<p>\r\n	primary key (id,name)\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	上面的id和name字段组合起来就是你test表的复合主键 （若其一为单索引字段时，左边的id才会有索引）它的出现是因为你的name字段可能会出现重名，所以要加上ID字段这样就可以保证你记录的唯一性 一般情况下，主键的字段长度和字段数目要越少越好。\r\n</p>\r\n<p>\r\n	联合主键，顾名思义就是多个主键联合形成一个主键组合，体现在联合。(主键原则上是唯一的，别被唯一值所困扰。) 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。\r\n</p>\r\n<p>\r\n	举一个简单的例子 主键A跟主键B组成联合主键 主键A跟主键B的数据可以完全相同(困扰吧，没关系)，联合就在于主键A跟主键B形成的联合主键是唯一的。 下例主键A数据是1，主键B数据也是1，联合主键其实是11，这个11是唯一值，绝对不充许再出现11这个唯一值。(这就是多对多关系) 主键A数据 主键B数据 1　　　　　　1 2　　　　　　2 3　　　　　　3 主键A与主键B的联合主键值最多也就是 11 12 13 21 22 23 31 32 33\r\n</p>','2017-07-31 17:32:24',3,3,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('231614c2-c158-4c49-b0f9-1d4db0b4406c','mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理','mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理','<p>\r\n	在mysql工作中接触最多的就是mysql replication，mysql在复制方面还是会有一些常规问题，比如主库宕机或者从库宕机有可能会导致复制中断，通常需要进行人为修复，或者很多时候需要把一个从库提升为主库，但对从库和主库的数据一致性不能保证一样。这种情况下就需要使用percona-toolkit工具的pt-table-checksum组件来检查主从数据的一致性；如果发现不一致的数据，可以通过pt-table-sync修复；还可以通过pt-heartbeat监控主从复制延迟。当然如果数据量小，slave只是当做一个备份使用，那么出现数据不一致完全可以重做，或者通过其他方法解决。如果数据量非常大，重做就是非常蛋碎的一件事情了。比如说，线上数据库做了主从同步环境，数据库在进行了迁移后，需要对mysql迁移（Replication）后的数据一致性进行校验，但又不能对生产环境使用造成影响，pt-table-checksum成为了绝佳也是唯一的检查工具。\r\n</p>\r\n<p>\r\n	percona-toolkit介绍percona-toolkit是一组高级命令行工具的集合，用来执行各种通过手工执行非常复杂和麻烦的mysql和系统任务，这些任务包括：\r\n</p>\r\n<p>\r\n	1）检查master和slave数据的一致性&nbsp;\r\n</p>\r\n<p>\r\n	2）有效地对记录进行归档&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	3）查找重复的索引&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	4）对服务器信息进行汇总&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	5）分析来自日志和tcpdump的查询&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	6）当系统出问题的时候收集重要的系统信息percona-toolkit源自Maatkit和Aspersa工具，这两个工具是管理mysql的最有名的工具。不过，现在Maatkit工具已经不维护了，所以以后推荐还是使用percona-toolkit工具！这些工具主要包括开发、性能、配置、监控、复制、系统、实用六大类，作为一个优秀的DBA，里面有的工具非常有用，如果能掌握并加以灵活应用，将能极大的提高工作效率。\r\n</p>\r\n<p>\r\n	percona-toolkit工具中最主要的三个组件分别是：&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	1）pt-table-checksum  负责监测mysql主从数据一致性&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	2）pt-table-sync      负责当主从数据不一致时修复数据，让它们保存数据的一致性&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	3）pt-heartbeat       负责监控mysql主从同步延迟下面就对这三个组件的使用做一记录，当然percona-toolkit工具也有很多其他组件，后面会一一说明。\r\n</p>\r\n<p>\r\n	percona-toolkit工具安装（建议主库和从库服务器上都安装）软件下载并在主库服务器上安装\r\n</p>\r\n<p>\r\n	&nbsp;[百度云盘下载地址：https://pan.baidu.com/s/1bp1OOgf &nbsp; （提取密码：y462）]\r\n</p>\r\n<p>\r\n	[root@master-server src]# wget https://www.percona.com/downloads/percona-toolkit/2.2.7/RPM/percona-toolkit-2.2.7-1.noarch.rpm\r\n</p>\r\n<p>\r\n	[root@master-server src]# rpm -ivh percona-toolkit-2.2.7-1.noarch.rpm &nbsp; &nbsp; //安装后，percona-toolkit工具的各个组件命令就有有了（输入ht-，按TAB键就会显示）\r\n</p>\r\n<p>\r\n	安装该工具依赖的软件包\r\n</p>\r\n<p>\r\n	[root@master-server src]# yum install perl-IO-Socket-SSL perl-DBD-MySQL perl-Time-HiRes perl perl-DBI -y\r\n</p>\r\n<p>\r\n	一、pt-table-checksum使用梳理pt-table-checksum 是 Percona-Toolkit的组件之一，用于检测MySQL主、从库的数据是否一致。其原理是在主库执行基于statement的sql语句来生成主库数据块的checksum，把相同的sql语句传递到从库执行，并在从库上计算相同数据块的checksum，最后，比较主从库上相同数据块的checksum值，由此判断主从数据是否一致。检测过程根据唯一索引将表按row切分为块（chunk），以为单位计算，可以避免锁表。检测时会自动判断复制延迟、 master的负载， 超过阀值后会自动将检测暂停，减小对线上服务的影响。pt-table-checksum 默认情况下可以应对绝大部分场景，官方说，即使上千个库、上万亿的行，它依然可以很好的工作，这源自于设计很简单，一次检查一个表，不需要太多的内存和多余的操作；必要时，pt-table-checksum 会根据服务器负载动态改变 chunk 大小，减少从库的延迟。\r\n</p>\r\n<p>\r\n	为了减少对数据库的干预，pt-table-checksum还会自动侦测并连接到从库，当然如果失败，可以指定--recursion-method选项来告诉从库在哪里。它的易用性还体现在，复制若有延迟，在从库 checksum 会暂停直到赶上主库的计算时间点（也通过选项--设定一个可容忍的延迟最大值，超过这个值也认为不一致）。\r\n</p>\r\n<p>\r\n	为了保证主数据库服务的安全，该工具实现了许多保护措施：&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	1）自动设置 innodb_lock_wait_timeout 为1s，避免引起&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	2）默认当数据库有25个以上的并发查询时，pt-table-checksum会暂停。可以设置 --max-load 选项来设置这个阀值&nbsp; &nbsp; 3）当用 Ctrl+C 停止任务后，工具会正常的完成当前 chunk 检测，下次使用 --resume 选项启动可以恢复继续下一个 chunkpt-table-checksum [OPTIONS] [DSN]pt-table-checksum：在主（master）上通过执行校验的查询对复制的一致性进行检查，对比主从的校验值，从而产生结果。DSN指向的是主的地址，该工具的退出状态不为零，如果发现有任何差别，或者如果出现任何警告或错误。注意：第一次运行的时候需要加上--create-replicate-table参数，生成checksums表！！如果不加这个参数，那么就需要在对应库下手工添加这张表了,表结构SQL如下：\r\n</p>\r\n<p>\r\n	CREATE TABLE checksums (\r\n</p>\r\n<p>\r\n	db             char(64)     NOT NULL,\r\n</p>\r\n<p>\r\n	tbl            char(64)     NOT NULL,\r\n</p>\r\n<p>\r\n	chunk          int          NOT NULL,\r\n</p>\r\n<p>\r\n	chunk_time     float            NULL,\r\n</p>\r\n<p>\r\n	chunk_index    varchar(200)     NULL,\r\n</p>\r\n<p>\r\n	lower_boundary text             NULL,\r\n</p>\r\n<p>\r\n	upper_boundary text             NULL,\r\n</p>\r\n<p>\r\n	this_crc       char(40)     NOT NULL,\r\n</p>\r\n<p>\r\n	this_cnt       int          NOT NULL,\r\n</p>\r\n<p>\r\n	master_crc     char(40)         NULL,\r\n</p>\r\n<p>\r\n	master_cnt     int              NULL,\r\n</p>\r\n<p>\r\n	ts             timestamp    NOT NULL,\r\n</p>\r\n<p>\r\n	PRIMARY KEY (db, tbl, chunk),\r\n</p>\r\n<p>\r\n	INDEX ts_db_tbl (ts, db, tbl)\r\n</p>\r\n<p>\r\n	) ENGINE=InnoDB;\r\n</p>\r\n<p>\r\n	常用参数解释：--nocheck-replication-filters ：不检查复制过滤器，建议启用。后面可以用--databases来指定需要检查的数据库。--no-check-binlog-format : 不检查复制的binlog模式，要是binlog模式是ROW，则会报错。--replicate-check-only :只显示不同步的信息。--replicate= ：把checksum的信息写入到指定表中，建议直接写到被检查的数据库当中。--databases= ：指定需要被检查的数据库，多个则用逗号隔开。--tables= ：指定需要被检查的表，多个用逗号隔开h= ：Master的地址u= ：用户名p=：密码P= ：端口\r\n</p>\r\n<p>\r\n	最重要的一点就是：要在主库上授权，能让主库ip访问。这一点不能忘记！（实验证明从库上可以不授权，但最好还是从库也授权）注意：\r\n</p>\r\n<p>\r\n	1）根据测试，需要一个即能登录主库，也能登录从库的账号；\r\n</p>\r\n<p>\r\n	2）只能指定一个host，必须为主库的IP；\r\n</p>\r\n<p>\r\n	3）在检查时会向表加S锁；\r\n</p>\r\n<p>\r\n	4）运行之前需要从库的同步IO和SQL进程是YES状态。\r\n</p>\r\n<p>\r\n	例如：（本文例子中：192.168.1.101是主库ip，192.168.1.102是从库ip）在主库执行授权（一定要对主库ip授权，授权的用户名和密码可以自行定义，不过要保证这个权限能同时登陆主库和从库）mysql&gt; GRANT SELECT, PROCESS, SUPER, REPLICATION SLAVE,CREATE,DELETE,INSERT,UPDATE ON *.* TO \'root\'@\'192.168.1.101\' identified  by \'123456\';mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	在从库上执行授权mysql&gt;  GRANT SELECT, PROCESS, SUPER, REPLICATION SLAVE ON *.* TO \'root\'@\'192.168.1.101\' IDENTIFIED BY \'123456\';mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	如下，在主库上执行的一个检查主从数据一致性的命令（别忘了第一次运行的时候需要添加--create-replicate-table参数，后续再运行时就不需要加了）：下面命令中的192.168.1.101是主库ip检查的是huanqiu库下的haha表的数据（当然，命令中也可以不跟表，直接检查某整个库的数据；如下去掉--tables=haha表，直接检查huanqiu库的数据）[root@master-server ~]# pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanqiu.checksums --create-replicate-table&nbsp;--databases=huanqiu --tables=haha h=192.168.1.101,u=root,p=123456,P=3306\r\n</p>\r\n<p>\r\n	Diffs cannot be detected because no slaves were found.  Please read the --recursion-method documentation for information.\r\n</p>\r\n<p>\r\n	TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE\r\n</p>\r\n<p>\r\n	01-08T04:04:54      0      0        4       1       0   0.009 huanqiu.haha\r\n</p>\r\n<p>\r\n	上面有报错：Diffs cannot be detected because no slaves were found.  Please read the --recursion-method documentation for information上面的提示信息很清楚，因为找不到从，所以执行失败，提示用参数--recursion-method 可以指定模式解决。其实是因为从库的slave关闭了。在主库上执行：\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;\r\n</p>\r\n<p>\r\n	+----+------+-----------+------+---------+------+-------+------------------+\r\n</p>\r\n<p>\r\n	| Id | User | Host      | db   | Command | Time | State | Info             |\r\n</p>\r\n<p>\r\n	+----+------+-----------+------+---------+------+-------+------------------+\r\n</p>\r\n<p>\r\n	| 10 | root | localhost | NULL | Query   |    0 | init  | show processlist |\r\n</p>\r\n<p>\r\n	+----+------+-----------+------+---------+------+-------+------------------+\r\n</p>\r\n<p>\r\n	发现没有slave在运行。\r\n</p>\r\n<p>\r\n	在从库上开启slavemysql&gt; start slave;mysql&gt; show slave status\\G;\r\n</p>\r\n<p>\r\n	再在主库上执行：\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;\r\n</p>\r\n<p>\r\n	+----+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| Id | User  | Host                | db   | Command     | Time | State                                                                 | Info             |\r\n</p>\r\n<p>\r\n	+----+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| 10 | root  | localhost           | NULL | Query       |    0 | init                                                                  | show processlist |\r\n</p>\r\n<p>\r\n	| 18 | slave | 192.168.1.102:37115 | NULL | Binlog Dump |    5 | Master has sent all binlog to slave; waiting for binlog to be updated | NULL             |\r\n</p>\r\n<p>\r\n	+----+-------+---------------------+------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	发现已有slave在运行。\r\n</p>\r\n<p>\r\n	再次执行检查命令：[root@master-server ~]# pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanqiu.checksums --databases=huanqiu --tables=haha h=192.168.1.101,u=root,p=123456,P=3306\r\n</p>\r\n<p>\r\n	TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE\r\n</p>\r\n<p>\r\n	01-08T04:11:03      0      0        4       1       0   1.422 huanqiu.haha\r\n</p>\r\n<p>\r\n	解释：TS ：完成检查的时间。ERRORS ：检查时候发生错误和警告的数量。DIFFS ：0表示一致，1表示不一致。当指定--no-replicate-check时，会一直为0，当指定--replicate-check-only会显示不同的信息。ROWS ：表的行数。CHUNKS ：被划分到表中的块的数目。SKIPPED ：由于错误或警告或过大，则跳过块的数目。TIME ：执行的时间。TABLE ：被检查的表名。\r\n</p>\r\n<p>\r\n	二、pt-table-sync用法梳理如果通过pt-table-checksum 检查找到了不一致的数据表，那么如何同步数据呢？即如何修复MySQL主从不一致的数据，让他们保持一致性呢？这时候可以利用另外一个工具pt-table-sync。使用方法：pt-table-sync: 高效的同步MySQL表之间的数据，他可以做单向和双向同步的表数据。他可以同步单个表，也可以同步整个库。它不同步表结构、索引、或任何其他模式对象。所以在修复一致性之前需要保证他们表存在。\r\n</p>\r\n<p>\r\n	假如上面检查数据时发现主从不一致[root@master-server ~]#  pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanqiu.checksums --databases=huanqiu --tables=haha h=192.168.1.101,u=root,p=123456,P=3306\r\n</p>\r\n<p>\r\n	TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE\r\n</p>\r\n<p>\r\n	01-08T04:18:07      0      1        4       1       0   0.843 huanqiu.haha\r\n</p>\r\n<p>\r\n	现在需要DIFFS为1可知主从数据不一致，需要修复！修复命令如下：先master的ip，用户，密码，然后是slave的ip，用户，密码[root@master-server ~]# pt-table-sync --replicate=huanqiu.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --print\r\n</p>\r\n<p>\r\n	REPLACE INTO `huanqiu`.`haha`(`id`, `name`) VALUES (\'1\', \'wangshibo\') /*percona-toolkit src_db:huanqiu src_tbl:haha src_dsn:h=192.168.1.101,p=...,u=root dst_db:huanqiu dst_tbl:haha dst_dsn:h=192.168.1.102,p=...,u=root lock:1 transaction:1 changing_src:huanqiu.checksums replicate:huanqiu.checksums bidirectional:0 pid:23676 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	REPLACE INTO `huanqiu`.`haha`(`id`, `name`) VALUES (\'2\', \'wangshikui\') /*percona-toolkit src_db:huanqiu src_tbl:haha src_dsn:h=192.168.1.101,p=...,u=root dst_db:huanqiu dst_tbl:haha dst_dsn:h=192.168.1.102,p=...,u=root lock:1 transaction:1 changing_src:huanqiu.checksums replicate:huanqiu.checksums bidirectional:0 pid:23676 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	REPLACE INTO `huanqiu`.`haha`(`id`, `name`) VALUES (\'3\', \'limeng\') /*percona-toolkit src_db:huanqiu src_tbl:haha src_dsn:h=192.168.1.101,p=...,u=root dst_db:huanqiu dst_tbl:haha dst_dsn:h=192.168.1.102,p=...,u=root lock:1 transaction:1 changing_src:huanqiu.checksums replicate:huanqiu.checksums bidirectional:0 pid:23676 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	REPLACE INTO `huanqiu`.`haha`(`id`, `name`) VALUES (\'4\', \'wanghi\') /*percona-toolkit src_db:huanqiu src_tbl:haha src_dsn:h=192.168.1.101,p=...,u=root dst_db:huanqiu dst_tbl:haha dst_dsn:h=192.168.1.102,p=...,u=root lock:1 transaction:1 changing_src:huanqiu.checksums replicate:huanqiu.checksums bidirectional:0 pid:23676 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	参数解释：--replicate=  ：指定通过pt-table-checksum得到的表，这2个工具差不多都会一直用。--databases=  : 指定执行同步的数据库。--tables=     ：指定执行同步的表，多个用逗号隔开。--sync-to-master ：指定一个DSN，即从的IP，他会通过show processlist或show slave status 去自动的找主。h=   ：服务器地址，命令里有2个ip，第一次出现的是Master的地址，第2次是Slave的地址。u=        ：帐号。p=     ：密码。--print       ：打印，但不执行命令。--execute     ：执行命令。\r\n</p>\r\n<p>\r\n	上面命令介绍完了，接下来开始执行修复：通过（--print）打印出来了修复数据的sql语句，可以手动的在slave从库上执行，让他们数据保持一致性，这样比较麻烦！可以直接在master主库上执行修复操作，通过--execute参数，如下：[root@master-server ~]# pt-table-sync --replicate=huanqiu.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --execute\r\n</p>\r\n<p>\r\n	如上修复后，再次检查，发现主从库数据已经一致了！[root@master-server ~]# pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanqiu.checksums --databases=huanqiu --tables=haha h=192.168.1.101,u=root,p=123456,P=3306\r\n</p>\r\n<p>\r\n	TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE\r\n</p>\r\n<p>\r\n	01-08T04:36:43      0      0        4       1       0   0.040 huanqiu.haha\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------建议:修复数据的时候，最好还是用--print打印出来的好，这样就可以知道那些数据有问题，可以人为的干预下。不然直接执行了，出现问题之后更不好处理。总之还是在处理之前做好数据的备份工作。\r\n</p>\r\n<p>\r\n	注意：要是表中没有唯一索引或则主键则会报错：Can\'t make changes on the master because no unique index exists at /usr/local/bin/pt-table-sync line 10591.-----------------------------------------------------------------------------------------------------------------------为了确保主从数据的一致性，可以编写监控脚本，定时检查。当检查到主从数据不一致时，强制修复数据。[root@master-server ~]# cat /root/pt_huanqiu.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	NUM=$(/usr/bin/pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanqiu.checksums --databases=huanqiu  h=192.168.1.101,u=root,p=123456,P=3306|awk -F\" \" \'{print $3}\'|sed -n \'2p\')\r\n</p>\r\n<p>\r\n	if [ $NUM -eq 1 ];then\r\n</p>\r\n<p>\r\n	/usr/bin/pt-table-sync --replicate=huanqiu.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --print\r\n</p>\r\n<p>\r\n	/usr/bin/pt-table-sync --replicate=huanqiu.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --execute\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	echo \"data is ok\"\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master-server ~]# cat /root/pt_huanpc.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	NUM=$(/usr/bin/pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=huanpc.checksums --databases=huanpc  h=192.168.1.101,u=root,p=123456,P=3306|awk -F\" \" \'{print $3}\'|sed -n \'2p\')\r\n</p>\r\n<p>\r\n	if [ $NUM -eq 1 ];then\r\n</p>\r\n<p>\r\n	/usr/bin/pt-table-sync --replicate=huanpc.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --print\r\n</p>\r\n<p>\r\n	/usr/bin/pt-table-sync --replicate=huanpc.checksums h=192.168.1.101,u=root,p=123456 h=192.168.1.102,u=root,p=123456 --execute\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	echo \"data is ok\"\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master-server ~]# crontab -l#检查主从huanqiu库数据一致性* * * * * /bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 10;/bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 20;/bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 30;/bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 40;/bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 50;/bin/bash -x /root/pt_huanqiu.sh &gt; /dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	#检查主从huanpc库数据一致性* * * * * /bin/bash -x /root/root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 10;/bin/bash -x /root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 20;/bin/bash -x /root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 30;/bin/bash -x /root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 40;/bin/bash -x /root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1* * * * * sleep 50;/bin/bash -x /root/pt_huanpc.sh &gt; /dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------最后总结：pt-table-checksum和pt-table-sync工具很给力，工作中常常在使用。注意使用该工具需要授权，一般SELECT, PROCESS, SUPER, REPLICATION SLAVE等权限就已经足够了。\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------另外说一个问题：在上面的操作中，在主库里添加pt-table-checksum检查的权限（从库可以不授权）后，进行数据一致性检查操作，会在操作的库（实例中是huanqiu、huanpc）下产生一个checksums表！这张checksums表是pt-table-checksum检查过程中产生的。这张表一旦产生了，默认是删除不了的，并且这张表所在的库也默认删除不了，删除后过一会儿就又会出来。\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Reading table information for completion of table and column names\r\n</p>\r\n<p>\r\n	You can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| checksums         |\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop table checksums;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;         //过一段时间再次查看，发现checksums表还在\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| checksums         |\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	不仅这张表删除不了，这张表所在的库也删除不了，删除后过一会儿就是自动生成。\r\n</p>\r\n<p>\r\n	mysql&gt; drop database huanqiu;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database huanpc;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiu            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database huanqiu;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanpc             |\r\n</p>\r\n<p>\r\n	| huanqiu            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	要想删除的话，一定要先把pt-table-checksum检查前添加的权限收回！\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for \'root\'@\'192.168.1.101\';\r\n</p>\r\n<p>\r\n	+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for root@192.168.1.101                                                                                                                                                       |\r\n</p>\r\n<p>\r\n	+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, PROCESS, SUPER, REPLICATION SLAVE ON *.* TO \'root\'@\'192.168.1.101\' IDENTIFIED BY PASSWORD \'*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9\' |\r\n</p>\r\n<p>\r\n	+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; revoke SELECT, INSERT, UPDATE, DELETE, CREATE, PROCESS, SUPER, REPLICATION SLAVE ON *.* FROM \'root\'@\'192.168.1.101\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for \'root\'@\'192.168.1.101\';\r\n</p>\r\n<p>\r\n	+-----------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for root@192.168.1.101                                                                                   |\r\n</p>\r\n<p>\r\n	+-----------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'root\'@\'192.168.1.101\' IDENTIFIED BY PASSWORD \'*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9\' |\r\n</p>\r\n<p>\r\n	+-----------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select user,host,password from mysql.user;\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| user  | host          | password                                  |\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| root  | localhost     | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |\r\n</p>\r\n<p>\r\n	| root  | master-server |                                           |\r\n</p>\r\n<p>\r\n	| root  | 127.0.0.1     |                                           |\r\n</p>\r\n<p>\r\n	| root  | ::1           |                                           |\r\n</p>\r\n<p>\r\n	|       | localhost     |                                           |\r\n</p>\r\n<p>\r\n	|       | master-server |                                           |\r\n</p>\r\n<p>\r\n	| root  | 192.168.1.101 | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |\r\n</p>\r\n<p>\r\n	| slave | 192.168.1.102 | *4F0FF134CC4C1A2872D972373A6AA86CA0A81872 |\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	8 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; delete from mysql.user where user=\"root\" and host=\"192.168.1.101\";   //这一步其实不必操作，此步删除操作不能在上面revoke执行前进行，否则revoke回收权限失败！\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select user,host,password from mysql.user;\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| user  | host          | password                                  |\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| root  | localhost     | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |\r\n</p>\r\n<p>\r\n	| root  | master-server |                                           |\r\n</p>\r\n<p>\r\n	| root  | 127.0.0.1     |                                           |\r\n</p>\r\n<p>\r\n	| root  | ::1           |                                           |\r\n</p>\r\n<p>\r\n	|       | localhost     |                                           |\r\n</p>\r\n<p>\r\n	|       | master-server |                                           |\r\n</p>\r\n<p>\r\n	| slave | 192.168.1.102 | *4F0FF134CC4C1A2872D972373A6AA86CA0A81872 |\r\n</p>\r\n<p>\r\n	+-------+---------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	权限删除后，就能成功删除checksums这张表和它所在的库了！主库的checksums删除了，从库的这张表也会跟着删除\r\n</p>\r\n<p>\r\n	mysql&gt; use huanpc;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanpc |\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	| checksums        |\r\n</p>\r\n<p>\r\n	| heihei           |\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop table checksums;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanpc |\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	| heihei           |\r\n</p>\r\n<p>\r\n	+------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Reading table information for completion of table and column names\r\n</p>\r\n<p>\r\n	You can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| checksums         |\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop table checksums;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	也就是说，checksums表一旦产生，不仅这张表默认删除不了，连同它所在的库，要是想删除它们，只能如上操作先撤销权限。\r\n</p>\r\n<p>\r\n	三、pt-heartbeat监控mysql主从复制延迟梳理\r\n</p>\r\n<p>\r\n	对于MySQL数据库主从复制延迟的监控，可以借助percona的有力武器pt-heartbeat来实现。pt-heartbeat的工作原理通过使用时间戳方式在主库上更新特定表，然后在从库上读取被更新的时间戳然后与本地系统时间对比来得出其延迟。具体流程：&nbsp; &nbsp;1）在主上创建一张heartbeat表，按照一定的时间频率更新该表的字段（把时间更新进去）。监控操作运行后，heartbeat表能促使主从同步！&nbsp; &nbsp;2）连接到从库上检查复制的时间记录，和从库的当前系统时间进行比较，得出时间的差异。\r\n</p>\r\n<p>\r\n	使用方法（主从和从库上都可以执行监控操作）：pt-heartbeat [OPTIONS] [DSN] --update|--monitor|--check|--stop\r\n</p>\r\n<p>\r\n	注意：需要指定的参数至少有 --stop，--update，--monitor，--check。\r\n</p>\r\n<p>\r\n	其中--update，--monitor和--check是互斥的，--daemonize和--check也是互斥。\r\n</p>\r\n<p>\r\n	--ask-pass     隐式输入MySQL密码\r\n</p>\r\n<p>\r\n	--charset     字符集设置\r\n</p>\r\n<p>\r\n	--check      检查从的延迟，检查一次就退出，除非指定了--recurse会递归的检查所有的从服务器。\r\n</p>\r\n<p>\r\n	--check-read-only    如果从服务器开启了只读模式，该工具会跳过任何插入。\r\n</p>\r\n<p>\r\n	--create-table    在主上创建心跳监控的表，如果该表不存在，可以自己手动建立，建议存储引擎改成memory。通过更新该表知道主从延迟的差距。\r\n</p>\r\n<p>\r\n	CREATE TABLE heartbeat (\r\n</p>\r\n<p>\r\n	ts                    varchar(26) NOT NULL,\r\n</p>\r\n<p>\r\n	server_id             int unsigned NOT NULL PRIMARY KEY,\r\n</p>\r\n<p>\r\n	file                  varchar(255) DEFAULT NULL,\r\n</p>\r\n<p>\r\n	position              bigint unsigned DEFAULT NULL,\r\n</p>\r\n<p>\r\n	relay_master_log_file varchar(255) DEFAULT NULL,\r\n</p>\r\n<p>\r\n	exec_master_log_pos   bigint unsigned DEFAULT NULL\r\n</p>\r\n<p>\r\n	);\r\n</p>\r\n<p>\r\n	heratbeat   表一直在更改ts和position,而ts是我们检查复制延迟的关键。\r\n</p>\r\n<p>\r\n	--daemonize   执行时，放入到后台执行\r\n</p>\r\n<p>\r\n	--user=-u，   连接数据库的帐号\r\n</p>\r\n<p>\r\n	--database=-D，    连接数据库的名称\r\n</p>\r\n<p>\r\n	--host=-h，     连接的数据库地址\r\n</p>\r\n<p>\r\n	--password=-p，     连接数据库的密码\r\n</p>\r\n<p>\r\n	--port=-P，     连接数据库的端口\r\n</p>\r\n<p>\r\n	--socket=-S，    连接数据库的套接字文件\r\n</p>\r\n<p>\r\n	--file 【--file=output.txt】   打印--monitor最新的记录到指定的文件，很好的防止满屏幕都是数据的烦恼。\r\n</p>\r\n<p>\r\n	--frames 【--frames=1m,2m,3m】  在--monitor里输出的[]里的记录段，默认是1m,5m,15m。可以指定1个，如：--frames=1s，多个用逗号隔开。可用单位有秒（s）、分钟（m）、小时（h）、天（d）。\r\n</p>\r\n<p>\r\n	--interval   检查、更新的间隔时间。默认是见是1s。最小的单位是0.01s，最大精度为小数点后两位，因此0.015将调整至0.02。\r\n</p>\r\n<p>\r\n	--log    开启daemonized模式的所有日志将会被打印到制定的文件中。\r\n</p>\r\n<p>\r\n	--monitor    持续监控从的延迟情况。通过--interval指定的间隔时间，打印出从的延迟信息，通过--file则可以把这些信息打印到指定的文件。\r\n</p>\r\n<p>\r\n	--master-server-id    指定主的server_id，若没有指定则该工具会连到主上查找其server_id。\r\n</p>\r\n<p>\r\n	--print-master-server-id    在--monitor和--check 模式下，指定该参数则打印出主的server_id。\r\n</p>\r\n<p>\r\n	--recurse    多级复制的检查深度。模式M-S-S...不是最后的一个从都需要开启log_slave_updates，这样才能检查到。\r\n</p>\r\n<p>\r\n	--recursion-method     指定复制检查的方式,默认为processlist,hosts。\r\n</p>\r\n<p>\r\n	--update    更新主上的心跳表。\r\n</p>\r\n<p>\r\n	--replace     使用--replace代替--update模式更新心跳表里的时间字段，这样的好处是不用管表里是否有行。\r\n</p>\r\n<p>\r\n	--stop    停止运行该工具（--daemonize），在/tmp/目录下创建一个“pt-heartbeat-sentinel” 文件。后面想重新开启则需要把该临时文件删除，才能开启（--daemonize）。\r\n</p>\r\n<p>\r\n	--table   指定心跳表名，默认heartbeat。\r\n</p>\r\n<p>\r\n	实例说明：master：192.168.1.101slave：192.168.1.102同步的库：huanqiu、huanpc主从库都能使用root账号、密码123456登录\r\n</p>\r\n<p>\r\n	先操作针对huanqiu库的检查，其他同步的库的检查操作类似！\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE TABLE heartbeat (            //主库上的对应库下创建heartbeat表，一般创建后从库会同步这张表（不同步的话，就在从库那边手动也手动创建）\r\n</p>\r\n<p>\r\n	-&gt;   ts                    varchar(26) NOT NULL,\r\n</p>\r\n<p>\r\n	-&gt;   server_id             int unsigned NOT NULL PRIMARY KEY,\r\n</p>\r\n<p>\r\n	-&gt;   file                  varchar(255) DEFAULT NULL,\r\n</p>\r\n<p>\r\n	-&gt;   position              bigint unsigned DEFAULT NULL,\r\n</p>\r\n<p>\r\n	-&gt;   relay_master_log_file varchar(255) DEFAULT NULL,\r\n</p>\r\n<p>\r\n	-&gt;   exec_master_log_pos   bigint unsigned DEFAULT NULL\r\n</p>\r\n<p>\r\n	-&gt; );\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	更新主库上的heartbeat,--interval=1表示1秒钟更新一次（注意这个启动操作要在主库服务器上执行）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat --user=root --ask-pass --host=192.168.1.101 --create-table -D huanqiu --interval=1 --update --replace --daemonizeEnter password:\r\n</p>\r\n<p>\r\n	[root@master-server ~]# [root@master-server ~]# ps -ef|grep pt-heartbeatroot 15152 1 0 19:49 ? 00:00:00 perl /usr/bin/pt-heartbeat --user=root --ask-pass --host=192.168.1.101 --create-table -D huanqiu --interval=1 --update --replace --daemonizeroot 15154 14170 0 19:49 pts/3 00:00:00 grep pt-heartbeat\r\n</p>\r\n<p>\r\n	在主库运行监测同步延迟：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --monitor --host=192.168.1.102 --user=root --password=1234560.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]........解释：0表示从没有延迟。 [ 0.00s, 0.00s, 0.00s ] 表示1m,5m,15m的平均值。可以通过--frames去设置。\r\n</p>\r\n<p>\r\n	或者加上--master-server-id参数（主库my.cnf里配置的server-id值）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --monitor --host=192.168.1.102 --user=root --password=123456 --master-server-id=1010.00s [ 0.00s, 0.00s, 0.00s ]0.00s [ 0.00s, 0.00s, 0.00s ]0.00s [ 0.00s, 0.00s, 0.00s ]0.00s [ 0.00s, 0.00s, 0.00s ].........也可以将主库的server-id打印出来（--print-master-server-id）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --monit --host=192.168.1.102 --user=root --password=123456 --print-master-server-id0.00s [  0.00s,  0.00s,  0.00s ] 1010.00s [  0.00s,  0.00s,  0.00s ] 1010.00s [  0.00s,  0.00s,  0.00s ] 1010.00s [  0.00s,  0.00s,  0.00s ] 101.........\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --check --host=192.168.1.102 --user=root --password=123456 --print-master-server-id0.00 101\r\n</p>\r\n<p>\r\n	上面的监测命令会一直在运行状态中，可以使用--check监测一次就退出注意：使用了--check，就不能使用--monit--update，--monitor和--check是互斥的，--daemonize和--check也是互斥。\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --check --host=192.168.1.102 --user=root --password=1234560.00[root@master-server ~]#\r\n</p>\r\n<p>\r\n	注意：如果想把这个输出结果加入自动化监控，那么可以使用如下命令使监控输出写到文件，然后使用脚本定期过滤文件中的最大值作为预警即可：注意--log选项必须在有--daemonize参数的时候才会打印到文件中，且这个文件的路径最好在/tmp下，否则可能因为权限问题无法创建[root@master-server ~]# pt-heartbeat -D huanqiu --table=heartbeat --monitor --host=192.168.1.102 --user=root --password=123456 --log=/opt/master-slave.txt --daemonize[root@master-server ~]# tail -f /opt/master-slave.txt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//可以测试，在主库上更新数据时，从库上是否及时同步，如不同步，可以在这里看到监控的延迟数据0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ].......\r\n</p>\r\n<p>\r\n	下面是编写的主从同步延迟监控脚本，就是定期过滤--log文件中最大值（此脚本运行的前提是：启动更新主库heartbeat命令以及带上--log的同步延迟检测命令）。如果发生延迟，发送报警邮件。sendemail邮件发送环境部署参考：http://www.cnblogs.com/kevingrace/p/5961861.html[root@master-server ~]# cat&nbsp;/root/check-slave-monit.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	cat /opt/master-slave.txt &gt; /opt/master_slave.txt\r\n</p>\r\n<p>\r\n	echo &gt; /opt/master-slave.txt\r\n</p>\r\n<p>\r\n	max_time=`cat /opt/master_slave.txt |grep -v \'^$\' |awk \'{print $1}\' |sort -k1nr |head -1`\r\n</p>\r\n<p>\r\n	NUM=$(echo \"$max_time\"|cut -d\"s\" -f1)\r\n</p>\r\n<p>\r\n	if [ $NUM == \"0.00\" ];then\r\n</p>\r\n<p>\r\n	echo \"Mysql主从数据一致\"\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	/usr/local/bin/sendEmail -f ops@huanqiu.cn -t wangshibo@huanqiu.cn -s smtp.huanqiu.cn -u \"Mysql主从同步延迟\" -o message-content-type=html -o message-charset=utf8 -xu ops@huanqiu.cn -xp WEE78@12l$ -m \"Mysql主从数据同步有延迟\"\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master-server ~]# chmod&nbsp;/root/check-slave-monit.sh[root@master-server ~]#&nbsp;sh /root/check-slave-monit.sh&nbsp;Mysql主从数据一致\r\n</p>\r\n<p>\r\n	结合crontab，每隔一分钟检查一次\r\n</p>\r\n<p>\r\n	[root@master-server ~]# crontab -e\r\n</p>\r\n<p>\r\n	#mysql主从同步延迟检查\r\n</p>\r\n<p>\r\n	* * * * * /bin/bash -x /root/check-slave-monit.sh &gt; /dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	在从库上运行监测同步延迟(也可以在命令后加上--master-server-id=101或--print-master-server-id，同上操作)\r\n</p>\r\n<p>\r\n	[root@slave-server src]# pt-heartbeat -D huanqiu --table=heartbeat --monitor --user=root --password=1234560.00s [ 0.00s, 0.00s, 0.00s ]0.00s [ 0.00s, 0.00s, 0.00s ]0.00s [ 0.00s, 0.00s, 0.00s ]........[root@slave-server src]# pt-heartbeat -D huanqiu --table=heartbeat --user=root --password=123456 --check0.00\r\n</p>\r\n<p>\r\n	[root@slave-server src]# pt-heartbeat -D huanqiu --table=heartbeat --monitor --user=root --password=123456 --log=/opt/master-slave.txt --daemonize\r\n</p>\r\n<p>\r\n	[root@slave-server src]# tail -f /opt/master-slave.txt 0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]0.00s [  0.00s,  0.00s,  0.00s ]\r\n</p>\r\n<p>\r\n	如何关闭上面在主库上执行的heartbeat更新进程呢？方法一：可以用参数--stop去关闭\r\n</p>\r\n<p>\r\n	[root@master-server ~]# ps -ef|grep heartbeatroot 15152 1 0 19:49 ? 00:00:02 perl /usr/bin/pt-heartbeat --user=root --ask-pass --host=192.168.1.101 --create-table -D huanqiu --interval=1 --update --replace --daemonizeroot 15310 1 0 19:59 ? 00:00:01 perl /usr/bin/pt-heartbeat -D huanqiu --table=heartbeat --monitor --host=192.168.1.102 --user=root --password=123456 --log=/opt/master-slave.txt --daemonizeroot 15555 31932 0 20:13 pts/2 00:00:00 grep heartbeat\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-heartbeat --stopSuccessfully created file /tmp/pt-heartbeat-sentinel\r\n</p>\r\n<p>\r\n	[root@master-server ~]# ps -ef|grep heartbeatroot 15558 31932 0 20:14 pts/2 00:00:00 grep heartbeat\r\n</p>\r\n<p>\r\n	[root@master-server ~]#\r\n</p>\r\n<p>\r\n	这样就把在主上开启的进程杀掉了。但是后续要继续开启后台进行的话，记住一定要先把/tmp/pt-heartbeat-sentinel 文件删除，否则启动不了\r\n</p>\r\n<p>\r\n	方法二：直接kill掉进程pid（推荐这种方法）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# ps -ef|grep heartbeatroot 15152 1 0 19:49 ? 00:00:02 perl /usr/bin/pt-heartbeat --user=root --ask-pass --host=192.168.1.101 --create-table -D huanqiu --interval=1 --update --replace --daemonizeroot 15310 1 0 19:59 ? 00:00:01 perl /usr/bin/pt-heartbeat -D huanqiu --table=heartbeat --monitor --host=192.168.1.102 --user=root --password=123456 --log=/opt/master-slave.txt --daemonizeroot 15555 31932 0 20:13 pts/2 00:00:00 grep heartbeat\r\n</p>\r\n<p>\r\n	[root@master-server ~]# kill -9 15152\r\n</p>\r\n<p>\r\n	[root@master-server ~]# ps -ef|grep heartbeatroot 15558 31932 0 20:14 pts/2 00:00:00 grep heartbeat\r\n</p>\r\n<p>\r\n	最后总结：通过pt-heartbeart工具可以很好的弥补默认主从延迟的问题，但需要搞清楚该工具的原理。默认的Seconds_Behind_Master值是通过将服务器当前的时间戳与二进制日志中的事件时间戳相对比得到的，所以只有在执行事件时才能报告延时。备库复制线程没有运行，也会报延迟null。还有一种情况：大事务，一个事务更新数据长达一个小时，最后提交。这条更新将比它实际发生时间要晚一个小时才记录到二进制日志中。当备库执行这条语句时，会临时地报告备库延迟为一个小时，执行完后又很快变成0。\r\n</p>\r\n<p>\r\n	---------------------------------------percona-toolkit其他组件命令用法----------------------------------\r\n</p>\r\n<p>\r\n	下面这些工具最好不要直接在线上使用，应该作为上线辅助或故障后离线分析的工具，也可以做性能测试的时候配合着使用。\r\n</p>\r\n<p>\r\n	1）pt-online-schema-change功能介绍：功能为:在alter操作更改表结构的时候不用锁定表，也就是说执行alter的时候不会阻塞写和读取操作，注意执行这个工具的时候必须做好备份，操作之前最好要充分了解它的原理。工作原理是:创建一个和你要执行alter操作的表一样的空表结构，执行表结构修改，然后从原表中copy原始数据到表结构修改后的表，当数据copy完成以后就会将原表移走，用新表代替原表，默认动作是将原表drop掉。在copy数据的过程中，任何在原表的更新操作都会更新到新表，因为这个工具在会在原表上创建触发器，触发器会将在原表上更新的内容更新到新表。如果表中已经定义了触发器这个工具就不能工作了。\r\n</p>\r\n<p>\r\n	用法介绍：pt-online-schema-change [OPTIONS] DSNoptions可以自行查看help（或加--help查看有哪些选项），DNS为你要操作的数据库和表。有两个参数需要注意一下：--dry-run  这个参数不建立触发器，不拷贝数据，也不会替换原表。只是创建和更改新表。--execute  这个参数的作用和前面工作原理的介绍的一样，会建立触发器，来保证最新变更的数据会影响至新表。注意：如果不加这个参数，这个工具会在执行一些检查后退出。这一举措是为了让使用这充分了解了这个工具的原理。\r\n</p>\r\n<p>\r\n	使用示例：在线更改表的的引擎，这个尤其在整理innodb表的时候非常有用，如下huanqiu库的haha表默认是Myisam存储引擎，现需要在线修改成Innodb类型。\r\n</p>\r\n<p>\r\n	mysql&gt; show create table huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Table | Create Table                                                                                                                                                             |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| haha  | CREATE TABLE `haha` (\r\n</p>\r\n<p>\r\n	`id` int(10) NOT NULL AUTO_INCREMENT,\r\n</p>\r\n<p>\r\n	`name` varchar(50) NOT NULL,\r\n</p>\r\n<p>\r\n	PRIMARY KEY (`id`)\r\n</p>\r\n<p>\r\n	) ENGINE=MyISAM AUTO_INCREMENT=91 DEFAULT CHARSET=utf8 |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	修改操作如下：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-online-schema-change --user=root --password=123456 --host=localhost --alter=\"ENGINE=InnoDB\" D=huanqiu,t=haha --execute --check-replication-filters\r\n</p>\r\n<p>\r\n	Found 1 slaves:\r\n</p>\r\n<p>\r\n	slave-server\r\n</p>\r\n<p>\r\n	Will check slave lag on:\r\n</p>\r\n<p>\r\n	slave-server\r\n</p>\r\n<p>\r\n	Replication filters are set on these hosts:\r\n</p>\r\n<p>\r\n	slave-server\r\n</p>\r\n<p>\r\n	slave_skip_errors = ALL\r\n</p>\r\n<p>\r\n	replicate_ignore_db = mysql\r\n</p>\r\n<p>\r\n	replicate_do_db = huanqiu,huanpc\r\n</p>\r\n<p>\r\n	Please read the --check-replication-filters documentation to learn how to solve this problem. at /usr/bin/pt-online-schema-change line 8083.\r\n</p>\r\n<p>\r\n	如上命令就是在主库上操作的，会提示它有从库，需要添加参数--nocheck-replication-filters，即不检查从库。（注意：下面命令中可以将localhost换成主库ip。另外：该命令只能针对某张表进行修改，因为它是针对alter操作的，而alter是针对表的操作命令。所以不能省略命令中\"t=表名\"的选项）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-online-schema-change --user=root --password=123456 --host=localhost --alter=\"ENGINE=InnoDB\" D=huanqiu,t=haha --execute --nocheck-replication-filters\r\n</p>\r\n<p>\r\n	Found 1 slaves:\r\n</p>\r\n<p>\r\n	slave-server\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	2017-01-16T10:36:33 Dropped old table `huanqiu`.`_haha_old` OK.\r\n</p>\r\n<p>\r\n	2017-01-16T10:36:33 Dropping triggers...\r\n</p>\r\n<p>\r\n	2017-01-16T10:36:33 Dropped triggers OK.\r\n</p>\r\n<p>\r\n	Successfully altered `huanqiu`.`haha`.\r\n</p>\r\n<p>\r\n	然后再次查看huanqiu.haha表的存储引擎，发现已是Innodb类型的了。\r\n</p>\r\n<p>\r\n	mysql&gt; show create table huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Table | Create Table                                                                                                                                                             |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| haha  | CREATE TABLE `haha` (\r\n</p>\r\n<p>\r\n	`id` int(10) NOT NULL AUTO_INCREMENT,\r\n</p>\r\n<p>\r\n	`name` varchar(50) NOT NULL,\r\n</p>\r\n<p>\r\n	PRIMARY KEY (`id`)\r\n</p>\r\n<p>\r\n	) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=utf8 |\r\n</p>\r\n<p>\r\n	+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	若是在从库上，则可以直接执行（也可以将下面从库ip替换成localhost）\r\n</p>\r\n<p>\r\n	[root@slave-server ~]# pt-online-schema-change --user=root --password=123456 --host=192.168.1.102 --alter=\"ENGINE=InnoDB\" D=huanqiu,t=haha --execute\r\n</p>\r\n<p>\r\n	No slaves found.  See --recursion-method if host slave-server has slaves.\r\n</p>\r\n<p>\r\n	Not checking slave lag because no slaves were found and --check-slave-lag was not specified.\r\n</p>\r\n<p>\r\n	Operation, tries, wait:\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	2017-01-15T21:40:35 Swapped original and new tables OK.\r\n</p>\r\n<p>\r\n	2017-01-15T21:40:35 Dropping old table...\r\n</p>\r\n<p>\r\n	2017-01-15T21:40:35 Dropped old table `huanqiu`.`_haha_old` OK.\r\n</p>\r\n<p>\r\n	2017-01-15T21:40:35 Dropping triggers...\r\n</p>\r\n<p>\r\n	2017-01-15T21:40:35 Dropped triggers OK.\r\n</p>\r\n<p>\r\n	Successfully altered `huanqiu`.`haha`.\r\n</p>\r\n<p>\r\n	2）pt-duplicate-key-checker功能介绍：功能为从mysql表中找出重复的索引和外键，这个工具会将重复的索引和外键都列出来，并生成了删除重复索引的语句，非常方便用法介绍：pt-duplicate-key-checker [OPTION...] [DSN]包含比较多的选项，具体的可以通过命令pt-duplicate-key-checker  --help来查看具体支持那些选项，我这里就不一一列举了。DNS为数据库或者表。使用示例：查看huanqiu库或huanqiu.haha表的重复索引和外键使用情况使用，如下命令：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-duplicate-key-checker  --host=localhost --user=root --password=123456  --databases=huanqiu\r\n</p>\r\n<p>\r\n	# ########################################################################\r\n</p>\r\n<p>\r\n	# Summary of indexes\r\n</p>\r\n<p>\r\n	# ########################################################################\r\n</p>\r\n<p>\r\n	# Total Indexes  6\r\n</p>\r\n<p>\r\n	# [root@master-server ~]# pt-duplicate-key-checker  --host=localhost --user=root --password=123456  --databases=huanqiu --table=haha\r\n</p>\r\n<p>\r\n	# ########################################################################\r\n</p>\r\n<p>\r\n	# Summary of indexes\r\n</p>\r\n<p>\r\n	# ########################################################################\r\n</p>\r\n<p>\r\n	# Total Indexes  1\r\n</p>\r\n<p>\r\n	3）pt-slave-find功能介绍：查找和打印mysql所有从服务器复制层级关系用法介绍：pt-slave-find [OPTION...] MASTER-HOST原理：连接mysql主服务器并查找其所有的从，然后打印出所有从服务器的层级关系。使用示例：查找主服务器为192.168.1.101的mysql有所有从的层级关系（将下面的192.168.1.101改成localhost，就是查询本机mysql的从关系）：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-slave-find --user=root --password=123456 --host=192.168.1.101\r\n</p>\r\n<p>\r\n	192.168.1.101\r\n</p>\r\n<p>\r\n	Version         5.6.33-log\r\n</p>\r\n<p>\r\n	Server ID       101\r\n</p>\r\n<p>\r\n	Uptime          5+02:59:42 (started 2017-01-11T10:44:14)\r\n</p>\r\n<p>\r\n	Replication     Is not a slave, has 1 slaves connected, is not read_only\r\n</p>\r\n<p>\r\n	Filters\r\n</p>\r\n<p>\r\n	Binary logging  MIXED\r\n</p>\r\n<p>\r\n	Slave status\r\n</p>\r\n<p>\r\n	Slave mode      STRICT\r\n</p>\r\n<p>\r\n	Auto-increment  increment 1, offset 1\r\n</p>\r\n<p>\r\n	InnoDB version  5.6.33\r\n</p>\r\n<p>\r\n	+- 192.168.1.102\r\n</p>\r\n<p>\r\n	Version         5.6.34-log\r\n</p>\r\n<p>\r\n	Server ID       102\r\n</p>\r\n<p>\r\n	Uptime          4+22:22:18 (started 2017-01-11T15:21:38)\r\n</p>\r\n<p>\r\n	Replication     Is a slave, has 0 slaves connected, is not read_only\r\n</p>\r\n<p>\r\n	Filters         slave_skip_errors=ALL; replicate_ignore_db=mysql; replicate_do_db=huanqiu,huanpc\r\n</p>\r\n<p>\r\n	Binary logging  MIXED\r\n</p>\r\n<p>\r\n	Slave status    265831 seconds behind, running, no errors\r\n</p>\r\n<p>\r\n	Slave mode      STRICT\r\n</p>\r\n<p>\r\n	Auto-increment  increment 1, offset 1\r\n</p>\r\n<p>\r\n	InnoDB version  5.6.34\r\n</p>\r\n<p>\r\n	4）pt-show-grants功能介绍：规范化和打印mysql权限，让你在复制、比较mysql权限以及进行版本控制的时候更有效率！用法介绍：pt-show-grants [OPTION...] [DSN]选项自行用help查看，DSN选项也请查看help，选项区分大小写。使用示例：查看指定mysql的所有用户权限：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-show-grants --host=\'localhost\' --user=\'root\' --password=\'123456\'\r\n</p>\r\n<p>\r\n	-- Grants dumped by pt-show-grants\r\n</p>\r\n<p>\r\n	-- Dumped from server Localhost via UNIX socket, MySQL 5.6.33-log at 2017-01-16 11:22:12\r\n</p>\r\n<p>\r\n	-- Grants for \'\'@\'localhost\'\r\n</p>\r\n<p>\r\n	GRANT USAGE ON *.* TO \'\'@\'localhost\';\r\n</p>\r\n<p>\r\n	-- Grants for \'data_check\'@\'%\'\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	查看执行数据库的权限：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-show-grants --host=\'localhost\' --user=\'root\' --password=\'123456\' --database=\'huanqiu\'\r\n</p>\r\n<p>\r\n	-- Grants dumped by pt-show-grants\r\n</p>\r\n<p>\r\n	-- Dumped from server Localhost via UNIX socket, MySQL 5.6.33-log at 2017-01-16 11:23:16\r\n</p>\r\n<p>\r\n	-- Grants for \'\'@\'localhost\'\r\n</p>\r\n<p>\r\n	GRANT USAGE ON *.* TO \'\'@\'localhost\';\r\n</p>\r\n<p>\r\n	-- Grants for \'data_check\'@\'%\'\r\n</p>\r\n<p>\r\n	GRANT SELECT ON *.* TO \'data_check\'@\'%\' IDENTIFIED BY PASSWORD \'*36B94ABF70E8D5E025CF9C059E66445CBB05B54F\';\r\n</p>\r\n<p>\r\n	-- Grants for \'mksync\'@\'%\'\r\n</p>\r\n<p>\r\n	GRANT ALL PRIVILEGES ON *.* TO \'mksync\'@\'%\' IDENTIFIED BY PASSWORD \'*B5E7409B1A22D47C6F1D8A693C6146CEB6570475\';\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	查看每个用户权限生成revoke收回权限的语句：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-show-grants --host=\'localhost\' --user=\'root\' --password=\'123456\'  --revoke\r\n</p>\r\n<p>\r\n	-- Grants dumped by pt-show-grants\r\n</p>\r\n<p>\r\n	-- Dumped from server Localhost via UNIX socket, MySQL 5.6.33-log at 2017-01-16 11:24:58\r\n</p>\r\n<p>\r\n	-- Revoke statements for \'\'@\'localhost\'\r\n</p>\r\n<p>\r\n	REVOKE USAGE ON *.* FROM \'\'@\'localhost\';\r\n</p>\r\n<p>\r\n	-- Grants for \'\'@\'localhost\'\r\n</p>\r\n<p>\r\n	..........\r\n</p>\r\n<p>\r\n	5）pt-upgrade功能介绍：这个工具用来检查在新版本中运行的SQL是否与老版本一样，返回相同的结果，最好的应用场景就是数据迁移的时候。这在升级服务器的时候非常有用，可以先安装并导数据到新的服务器上，然后使用这个工具跑一下sql看看有什么不同，可以找出不同版本之间的差异。用法介绍：pt-upgrade [OPTION...] DSN [DSN...] [FILE]比较文件中每一个查询语句在每台服务器上执行的结果（主要是针对不同版本的执行结果）。（--help查看选项）使用示例：查看某个sql文件在两个服务器的运行结果范例：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-upgrade h=192.168.1.101 h=192.168.1.102 --user=root --password=123456 /root/test.sql\r\n</p>\r\n<p>\r\n	#-----------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	# Logs\r\n</p>\r\n<p>\r\n	#-----------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	host1:\r\n</p>\r\n<p>\r\n	DSN:       h=192.168.1.101\r\n</p>\r\n<p>\r\n	hostname:  master-server\r\n</p>\r\n<p>\r\n	MySQL:     Source distribution 5.6.33\r\n</p>\r\n<p>\r\n	host2:\r\n</p>\r\n<p>\r\n	DSN:       h=192.168.1.102\r\n</p>\r\n<p>\r\n	hostname:  slave-server\r\n</p>\r\n<p>\r\n	MySQL:     Source distribution 5.6.34\r\n</p>\r\n<p>\r\n	......\r\n</p>\r\n<p>\r\n	queries_read          1\r\n</p>\r\n<p>\r\n	queries_with_diffs    0\r\n</p>\r\n<p>\r\n	queries_with_errors   0\r\n</p>\r\n<p>\r\n	查看慢查询中的对应的查询SQL在两个服务器的运行结果范例：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-upgrade h=192.168.1.101 h=192.168.1.102 --user=root --password=123456 /data/mysql/data/mysql-slow.log\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	6）pt-index-usage功能介绍：这个工具主要是用来分析慢查询的索引使用情况。从log文件中读取插叙语句，并用explain分析他们是如何利用索引。完成分析之后会生成一份关于索引没有被查询使用过的报告。用法介绍：pt-index-usage [OPTION...] [FILE...]可以直接从慢查询中获取sql，FILE文件中的sql格式必须和慢查询中个是一致，如果不是一直需要用pt-query-digest转换一下。也可以不生成报告直接保存到数据库中，具体的见后面的示例注意：使用这个工具需要MySQL必须要有密码，另外运行时可能报找不到/var/lib/mysql/mysql.sock的错，简单的从mysql启动后的sock文件做一个软链接即可。重点要说明的是pt-index-usage只能分析慢查询日志，所以如果想全面分析所有查询的索引使用情况就得将slow_launch_time设置为0，因此请谨慎使用该工具，线上使用的话最好在凌晨进行分析，尤其分析大量日志的时候是很耗CPU的。整体来说这个工具是不推荐使用的，要想实现类似的分析可以考虑一些其他第三方的工具，比如：mysqlidxchx, userstat和check-unused-keys。网上比较推荐的是userstat，一个Google贡献的patch。使用示例：从满查询中的sql查看索引使用情况范例：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-index-usage --host=localhost --user=root --password=123456 /data/mysql/data/mysql-slow.log\r\n</p>\r\n<p>\r\n	将分析结果保存到数据库范例：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-index-usage --host=localhost --user=root --password=123456 /data/mysql/data/mysql-slow.log  --no-report --create-save-results-database\r\n</p>\r\n<p>\r\n	7）pt-visual-explain功能介绍：格式化explain出来的执行计划按照tree方式输出，方便阅读。用法介绍：pt-visual-explain [OPTION...] [FILE...]通过管道直接查看explain输出结果的范例：\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-------------+\r\n</p>\r\n<p>\r\n	| id | name        |\r\n</p>\r\n<p>\r\n	+----+-------------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo   |\r\n</p>\r\n<p>\r\n	|  2 | wangshihuan |\r\n</p>\r\n<p>\r\n	|  3 | 王世博      |\r\n</p>\r\n<p>\r\n	| 10 | wangshiman  |\r\n</p>\r\n<p>\r\n	+----+-------------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mysql -uroot -p123456  -e \"explain select * from huanqiu.haha\" |pt-visual-explain\r\n</p>\r\n<p>\r\n	Warning: Using a password on the command line interface can be insecure.\r\n</p>\r\n<p>\r\n	Table scan\r\n</p>\r\n<p>\r\n	rows           4\r\n</p>\r\n<p>\r\n	+- Table\r\n</p>\r\n<p>\r\n	table          haha\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mysql -uroot -p123456  -e \"explain select * from huanqiu.haha where id=3\" |pt-visual-explain\r\n</p>\r\n<p>\r\n	Warning: Using a password on the command line interface can be insecure.\r\n</p>\r\n<p>\r\n	Bookmark lookup\r\n</p>\r\n<p>\r\n	+- Table\r\n</p>\r\n<p>\r\n	|  table          haha\r\n</p>\r\n<p>\r\n	|  possible_keys  PRIMARY\r\n</p>\r\n<p>\r\n	+- Constant index lookup\r\n</p>\r\n<p>\r\n	key            haha-&gt;PRIMARY\r\n</p>\r\n<p>\r\n	possible_keys  PRIMARY\r\n</p>\r\n<p>\r\n	key_len        4\r\n</p>\r\n<p>\r\n	ref            const\r\n</p>\r\n<p>\r\n	rows           1\r\n</p>\r\n<p>\r\n	查看包含查询语句的test.sql文件的范例：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-visual-explain --connect /root/test.sql --user=root --password=123456\r\n</p>\r\n<p>\r\n	8）pt-config-diff功能介绍：比较mysql配置文件和服务器参数用法介绍：pt-config-diff [OPTION...] CONFIG CONFIG [CONFIG...]CONFIG可以是文件也可以是数据源名称，最少必须指定两个配置文件源，就像unix下面的diff命令一样，如果配置完全一样就不会输出任何东西。使用示例：范例1：查看本地和远程服务器的配置文件差异：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-config-diff h=localhost h=192.168.1.102 --user=root --password=123456\r\n</p>\r\n<p>\r\n	18 config differences\r\n</p>\r\n<p>\r\n	Variable                  master-server             slave-server\r\n</p>\r\n<p>\r\n	========================= ========================= =========================\r\n</p>\r\n<p>\r\n	binlog_checksum           NONE                      CRC32\r\n</p>\r\n<p>\r\n	general_log_file          /data/mysql/data/maste... /data/mysql/data/slave...\r\n</p>\r\n<p>\r\n	hostname                  master-server             slave-server\r\n</p>\r\n<p>\r\n	innodb_version            5.6.33                    5.6.34\r\n</p>\r\n<p>\r\n	log_bin_index             /data/mysql/data/maste... /data/mysql/data/slave...\r\n</p>\r\n<p>\r\n	log_slave_updates         OFF                       ON\r\n</p>\r\n<p>\r\n	relay_log_recovery        OFF                       ON\r\n</p>\r\n<p>\r\n	secure_file_priv                                    NULL\r\n</p>\r\n<p>\r\n	server_id                 101                       102\r\n</p>\r\n<p>\r\n	server_uuid               d8497104-d7a7-11e6-911... d8773e51-d7a7-11e6-911...\r\n</p>\r\n<p>\r\n	slave_net_timeout         3600                      5\r\n</p>\r\n<p>\r\n	slave_skip_errors         OFF                       ALL\r\n</p>\r\n<p>\r\n	sync_binlog               1                         0\r\n</p>\r\n<p>\r\n	sync_master_info          10000                     1\r\n</p>\r\n<p>\r\n	sync_relay_log            10000                     1\r\n</p>\r\n<p>\r\n	sync_relay_log_info       10000                     1\r\n</p>\r\n<p>\r\n	system_time_zone          CST                       EST\r\n</p>\r\n<p>\r\n	version                   5.6.33-log                5.6.34-log\r\n</p>\r\n<p>\r\n	范例2：比较本地配置文件和远程服务器的差异：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-config-diff /usr/local/mysql/my.cnf h=localhost h=192.168.1.102 --user=root --password=123456\r\n</p>\r\n<p>\r\n	6 config differences\r\n</p>\r\n<p>\r\n	Variable                  /usr/local/mysql/my.cnf master-server      slave-ser\r\n</p>\r\n<p>\r\n	========================= ================= ================== ===============\r\n</p>\r\n<p>\r\n	binlog_checksum           none              NONE               CRC32\r\n</p>\r\n<p>\r\n	innodb_read_io_threads    1000              64                 64\r\n</p>\r\n<p>\r\n	innodb_write_io_threads   1000              64                 64\r\n</p>\r\n<p>\r\n	log_bin_index             master-bin.index  /data/mysql/dat... /data/mysql/...\r\n</p>\r\n<p>\r\n	server_id                 101               101                102\r\n</p>\r\n<p>\r\n	sync_binlog               1                 1                  0\r\n</p>\r\n<p>\r\n	9）pt-mysql-summary功能介绍：精细地对mysql的配置和sataus信息进行汇总，汇总后你直接看一眼就能看明白。工作原理：连接mysql后查询出status和配置信息保存到临时目录中，然后用awk和其他的脚本工具进行格式化。OPTIONS可以查阅官网的相关页面。用法介绍：pt-mysql-summary [OPTIONS] [-- MYSQL OPTIONS]使用示例：汇总本地mysql服务器的status和配置信息：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-mysql-summary -- --user=root --password=123456 --host=localhost\r\n</p>\r\n<p>\r\n	10）pt-deadlock-logger功能介绍：提取和记录mysql死锁的相关信息用法介绍：pt-deadlock-logger [OPTION...] SOURCE_DSN收集和保存mysql上最近的死锁信息，可以直接打印死锁信息和存储死锁信息到数据库中，死锁信息包括发生死锁的服务器、最近发生死锁的时间、死锁线程id、死锁的事务id、发生死锁时事务执行了多长时间等等非常多的信息。使用示例：查看本地mysql的死锁信息\r\n</p>\r\n<p>\r\n	[root@master-server ~]# pt-deadlock-logger  --user=root --password=123456 h=localhost D=test,t=deadlocks\r\n</p>\r\n<p>\r\n	server ts thread txn_id txn_time user hostname ip db tbl idx lock_type lock_mode wait_hold victim query\r\n</p>\r\n<p>\r\n	localhost 2017-01-11T11:00:33 188 0 0 root  192.168.1.101 huanpc checksums PRIMARY RECORD X w 1 REPLACE INTO `huanpc`.`checksums` (db, tbl, chunk, chunk_index, lower_boundary, upper_boundary, this_cnt, this_crc) SELECT \'huanpc\', \'heihei\', \'1\', NULL, NULL, NULL, COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS(\'#\', `member`, `city`)) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `huanpc`.`heihei` /*checksum table*/\r\n</p>\r\n<p>\r\n	localhost 2017-01-11T11:00:33 198 0 0 root  192.168.1.101 huanpc checksums PRIMARY RECORD X w 0 REPLACE INTO `huanpc`.`checksums` (db, tbl, chunk, chunk_index, lower_boundary, upper_boundary, this_cnt, this_crc) SELECT \'huanpc\', \'heihei\', \'1\', NULL, NULL, NULL, COUNT(*) AS cnt, COALESCE(LOWER(CONV(BIT_XOR(CAST(CRC32(CONCAT_WS(\'#\', `member`, `city`)) AS UNSIGNED)), 10, 16)), 0) AS crc FROM `huanpc`.`heihei` /*checksum table*/\r\n</p>\r\n<p>\r\n	11）pt-mext功能介绍：并行查看SHOW GLOBAL STATUS的多个样本的信息。用法介绍：pt-mext [OPTIONS] -- COMMAND原理：pt-mext执行你指定的COMMAND，并每次读取一行结果，把空行分割的内容保存','2017-07-31 17:32:24',3,5,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('255173d6-c27c-4467-bda4-fdc0c67cd7e3','mysql连接数设置操作（Too many connections）','mysql连接数设置操作（Too many connections）','<p>\r\n	mysql在使用过程中，发现连接数超了~~~~\r\n</p>\r\n<p>\r\n	[root@linux-node1 ~]# mysql -u glance -h 192.168.1.17 -pEnter password: ERROR 1040 (08004): Too many connections\r\n</p>\r\n<p>\r\n	解决办法，这也是centos7下修改mysql连接数的做法：\r\n</p>\r\n<p>\r\n	1）临时修改\r\n</p>\r\n<p>\r\n	MariaDB [(none)]&gt; show variables like \"max_connections\";+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 214 |+-----------------+-------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	MariaDB [(none)]&gt; set GLOBAL max_connections=1000; Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	MariaDB [(none)]&gt; show variables like \"max_connections\";+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 1000 |+-----------------+-------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）永久修改：配置/etc/my.cnf[mysqld]新添加一行如下参数：max_connections=1000重启mariadb服务，再次查看mariadb数据库最大连接数，可以看到最大连接数是214，并非我们设置的1000。\r\n</p>\r\n<p>\r\n	MariaDB [(none)]&gt; show variables like \'max_connections\'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 214 | +-----------------+-------+ 这是由于mariadb有默认打开文件数限制。可以通过配置/usr/lib/systemd/system/mariadb.service来调大打开文件数目。\r\n</p>\r\n<p>\r\n	配置/usr/lib/systemd/system/mariadb.service[Service]新添加两行如下参数：LimitNOFILE=10000LimitNPROC=10000\r\n</p>\r\n<p>\r\n	重新加载系统服务，并重启mariadb服务systemctl --system daemon-reload systemctl restart mariadb.service\r\n</p>\r\n<p>\r\n	再次查看mariadb数据库最大连接数，可以看到最大连接数已经是1000\r\n</p>\r\n<p>\r\n	MariaDB [(none)]&gt; show variables like \'max_connections\'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 1000 | +-----------------+-------+\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('25d2c0cd-bc4f-4e51-afab-433440fe0127','mysql主从同步(2)-问题梳理','mysql主从同步(2)-问题梳理','<p>\r\n	之前部署了Mysql主从复制环境（Mysql主从同步(1)-主从/主主环境部署梳理），在mysql同步过程中会出现很多问题，导致数据同步异常。以下梳理了几种主从同步中可能存在的问题:\r\n</p>\r\n<p>\r\n	1)slave运行过慢不能与master同步，也就是MySQL数据库主从同步延迟MySQL数据库slave服务器延迟的现象是非常普遍的，MySQL复制允许从机进行SELECT操作，但是在实际线上环境下，由于从机延迟的关系，很难将读取操作转向到从机。这就导致了有了以下一些潜规则：“实时性要求不高的读取操作可以放到slave服务器，实时性要求高的读取操作放到master服务器”，“从机仅能做前一天的统计类查询”。slave滞后即slave不能快速执行来自于master的所有事件，从而不能避免更新slave数据延迟。mysql的master-slave架构中master仅做写入、更新、删除操作，slave做select操作。造成slave滞后的原因有很多。slave同步延迟的原理MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的IO Thread线程从主库中bin log中读取取日志。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随即的，不是顺序的，成本高很多。由于SQL  Thread也是单线程的，如果slave上的其他查询产生lock争用，又或者一个DML语句（大事务、大查询）执行了几分钟卡住了，那么所有之后的DML会等待这个DML执行完才会继续执行，这就导致了延时。也许有人会质疑：主库上那个相同的DDL也会执行几分钟，为什么slave会延时？原因是master可以并发执行，而Slave_SQL_Running线程却不可以。\r\n</p>\r\n<p>\r\n	slave同步延迟的可能原因&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	1--slave的I/O线程推迟读取日志中的事件信息；最常见原因是slave是在单线程中执行所有事务，而master有很多线程可以并行执行事务。&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	2--带来低效连接的长查询、磁盘读取的I/O限制、锁竞争和innodb线程同步启动等。&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	3--Master负载；Slave负载&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	4--网络延迟&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	5--机器配置（cpu、内存、硬盘）（主从同步延迟怎么产生的？）总之，当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能处理的承受范围时，主从同步就会产生延时；或者当slave中有大型query语句产生了锁等待也会产生延时。\r\n</p>\r\n<p>\r\n	如何查看同步延迟&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	1--可以通过比对master、slave上的日志位置&nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	&nbsp;2--通过\"show slave status\"查看Seconds_Behind_Master的值，这个值代表主从同步延迟的时间，值越大说明延迟越严重。值为0为正常情况，正值表示已经出现延迟，数字越大从库落后主库越多。&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	3--使用percona-toolkit的pt-hearbeat工具进行查看。\r\n</p>\r\n<p>\r\n	减少同步延迟的操作方案&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	1--减少锁竞争如果查询导致大量的表锁定，需要考虑重构查询语句，尽量避免过多的锁。&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	2--负载均衡搭建多少slave，并且使用lvs或nginx进行查询负载均衡，可以减少每个slave执行查询的次数和时间，从而将更多的时间用于去处理主从同步。&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	3--salve较高的机器配置&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	4--Slave调整参数为了保障较高的数据安全性，配置sync_binlog=1，innodb_flush_log_at_trx_commit=1等设置。而Slave可以关闭binlog，innodb_flush_log_at_trx_commit也可以设置为0来提高sql的执行效率（这两个参数很管用）&nbsp; &nbsp;&nbsp;\r\n</p>\r\n<p>\r\n	5--并行复制即有单线程的复制改成多线程复制。从库有两个线程与复制相关：io_thread 负责从主库拿binlog并写到relaylog， sql_thread 负责读relaylog并执行。多线程的思路就是把sql_thread 变成分发线程，然后由一组worker_thread来负责执行。几乎所有的并行复制都是这个思路，有不同的，便是sql_thread 的分发策略。MySQL5.7的真正并行复制enhanced multi-threaded slave（MTS）很好的解决了主从同步复制的延迟问题。\r\n</p>\r\n<p>\r\n	2）slave同步状态中出现Slave_IO_Running: NO 报错：Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: \'Could not find first log file name in binary log index file\'\r\n</p>\r\n<p>\r\n	原因1：清理数据导致主从库不同步（前提是主库的binlog日志没有被暴力删除或错误删除，即要确保正在使用的那个最新binlog文件在master主库机器上存在）。\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	1）先进入slave中执行:\"slave stop;\"来停止从库同步；\r\n</p>\r\n<p>\r\n	2）再去master中执行:\"flush logs;\"来清空日志；\r\n</p>\r\n<p>\r\n	3）然后在master中执行:\"show master status;\"查看下主库的状态，主要是日志的文件和position；\r\n</p>\r\n<p>\r\n	4）然后回到slave中，执行:\"CHANGE MASTER TO ......执行同步指令\r\n</p>\r\n<p>\r\n	原因2：该错误发生在从库的io进程从主库拉取日志时，发现主库的mysql_bin.index文件中第一个文件不存在。出现此类报错可能是由于你的slave 由于某种原因停止了好长一段\r\n</p>\r\n<p>\r\n	时间，当你重启slave 复制的时候，在主库上找不到相应的binlog ,会报此类错误。或者是由于某些设置主库上的binlog被删除了，导致从库获取不到对应的binglog file。\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	1）为了避免数据丢失，需要重新进行slave同步操作。\r\n</p>\r\n<p>\r\n	2）注意主库binlog的清理策略，选择基于时间过期的删除方式还是基于空间利用率的删除方式。\r\n</p>\r\n<p>\r\n	3）记住最好不要使用\"rm -rf\"命令删除binlog file，这样不会同步修改mysql_bin.index 记录的binlog 条目。在删除binlog的时候确保主库保留了从库\"show slave status\"\r\n</p>\r\n<p>\r\n	的Relay_Master_Log_File对应的binlog file。任何时候都不能删除正在使用的那个最新binlog文件；最好把bin-log文件不要删除，最好给备份出来。\r\n</p>\r\n<p>\r\n	原因2的情况下，使用原因1的处理方案显然是解决不了的！此时的解决方案是：\r\n</p>\r\n<p>\r\n	在从库上执行：\r\n</p>\r\n<p>\r\n	mysql&gt; stop slave;\r\n</p>\r\n<p>\r\n	mysql&gt; reset slave;\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	3）slave同步状态中出现Slave_IO_Running: Connecting导致这个错误的原因一般是：&nbsp; &nbsp; 1--网络不通&nbsp; &nbsp; 2--权限问题（连接master的用户名和密码跟master授权不一致）&nbsp; &nbsp; 3--连接时用的log file和pos节点跟\"show master status\"的结果不一致\r\n</p>\r\n<p>\r\n	4）slave同步状态中出现Slave_SQL_Running: No ，即slave不同步！解决办法：第一种方法：忽略错误后，继续同步。该方法适用于主从库数据相差不大，或者要求数据可以不完全统一的情况，数据要求不严格的情况（下面均为在slave机器上的操作）\r\n</p>\r\n<p>\r\n	mysql&gt; stop slave;\r\n</p>\r\n<p>\r\n	mysql&gt; set global sql_slave_skip_counter =1; &nbsp; //表示跳过一步错误，后面的数字可变；或者在my.cnf里添加slave-skip-errors = all（上面已在配置中添加）\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status\\G &nbsp; &nbsp; &nbsp;//查看：第二种方法：重新做主从，完全同步该方法适用于主从库数据相差较大，或者要求数据完全统一的情况 1--master主库上操作\r\n</p>\r\n<p>\r\n	mysql&gt; flush tables with read lock; &nbsp;//进行锁表，防止数据写入。注意该处是锁定为只读状态，语句不区分大小写\r\n</p>\r\n<p>\r\n	#mysqldump --lock-all-tables --all-databases --flush-logs --master-data=2 &gt; /root/allsql.sql &nbsp; //主库完全备份(如果是指定库同步，就备份指定库)，注意数据库备份一定要定期进行，确保数据万无一失\r\n</p>\r\n<p>\r\n	mysql&gt; show master status; &nbsp; &nbsp; &nbsp;//查看master状态，注意log file和pos节点，slave同步会用到\r\n</p>\r\n<p>\r\n	# scp mysql.bak.sql root@192.168.1.102:/tmp/ &nbsp; &nbsp; &nbsp; &nbsp;//把备份文件传到slave从库机器，进行数据恢复&nbsp;\r\n</p>\r\n<p>\r\n	2--slave从库操作\r\n</p>\r\n<p>\r\n	mysql&gt; stop slave;\r\n</p>\r\n<p>\r\n	mysql&gt; source /tmp/mysql.bak.sql\r\n</p>\r\n<p>\r\n	mysql&gt; change master to master_host = \'192.168.1.101\', master_user = \'slave\', master_port=3306.......；\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status\\G .......Slave_IO_Running: YesSlave_SQL_Running: Yes此种方法中最为关键主要有两步：①主服务器上锁表做完全备份，并滚动日志；②从服务器上进行半道恢复.\r\n</p>\r\n<p>\r\n	5）slave中继日志relay-log损坏？什么是中继日志？relay-log存放在从服务器上，从服务器将主服务器的二进制日志文件拷贝到自己的主机上放在中继日志中，然后调用SQL线程按照拷中继日志文件中的二进制日志文件执行以便就可达到数据的同步 。如何中继日志避免：mysql 5.6版本后，在my.cnf文件中开启relay_log_recover=1即可避免。\r\n</p>\r\n<p>\r\n	6）slave连接超时且重新连接频繁若有多少slave，且没有设置server_id或两个slave设置相同的server_id，将有可能会出现服务器的ID冲突。这种情况下，其中一台slave可能会频繁超时或丢失后重新连接序列。所以一定要确保每台slave及master在my.cnf中都要设置不一样的server_id。\r\n</p>\r\n<p>\r\n	7）主库与从库使用不同的存储引擎造成不同步\r\n</p>\r\n<p>\r\n	8）从库同步时，提示表不存在错误：Last_Error: Error executing row event: \'Table \'test.t1\' doesn\'t exist\'解决方法：在从库重建这张表。\r\n</p>\r\n<p>\r\n	9）max_allowed_packet设置过小导致slave报错max_allowed_packet默认是16M，主从库的max_allowed_packet值和备库上的不匹配。在这情况下，主库可能会记录一个备库认为过大的包。当备库获取到该二进制日志事件时，可能会碰到各种问题，如无限报错和重试、中继日志损坏等。具体表现：从库的Slave_IO_Thread死掉了，查看后，出现以下错误提示：Got a packet bigger than \'max_allowed_packet\' bytes很明显是由于max_allowed_packet的设置太小导致的，然后查检主从库上的设置，主库的设置大于从库，因为max_allowed_packet是动态参数，先调整从库上的max_allowed_packet 与主库相同，重新单独启动I/O线程就正常了。原理说明：binlog的事件以RBR格式记录，且当前的事件长度大于了从库的max_allowed_packet, 导致无法Slave IO不能正常读取master binlog event.\r\n</p>\r\n<p>\r\n	10）在master上删除一条记录时出现的故障在master上删除一条记录后，slave上因找不到这条记录而报错。解决方法：由于主库上已经对这条语句进行了删除操作，故可以跳过。在这种情况下，说明主从同步可能数据会有不一致的情况发生，所以需要使用pt-table-checksum进行数据库一致性比对。（参考：mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理）\r\n</p>\r\n<p>\r\n	11）在master更新一条记录，而slave却找不到。主从数据不致时，master有某条记录，但在salve上没有这条记录，若在master上进行更新这条记录，则在slave中可能报错。解决方法：&nbsp; &nbsp;1--根据从库发生异常的位置，查主库上的二进制日志。&nbsp; &nbsp;2--根据主库二进制日志信息，找到更新后的整条记录。&nbsp; &nbsp;3--在从库上执行在主库上找到的记录信息，进行insert操作。&nbsp; &nbsp;4--跳过这条语句，再同步slave。&nbsp; &nbsp;5--使用pt-table-checksum查看主从库表数据否一致。\r\n</p>','2017-07-31 17:32:24',3,2,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('2d16455f-ec12-4b5d-9763-469cc5355d3d','Mysql占用过高CPU时的优化手段','Mysql占用过高CPU时的优化手段','<p>\r\n	Mysql占用CPU过高的时候，该从哪些方面下手进行优化？占用CPU过高，可以做如下考虑：\r\n</p>\r\n<p>\r\n	1）一般来讲，排除高并发的因素，还是要找到导致你CPU过高的哪几条在执行的SQL，show processlist语句，查找负荷最重的SQL语句，优化该SQL，比如适当建立某字段的索引；\r\n</p>\r\n<p>\r\n	2）打开慢查询日志，将那些执行时间过长且占用资源过多的SQL拿来进行explain分析，导致CPU过高，多数是GroupBy、OrderBy排序问题所导致，然后慢慢进行优化改进。比如优化insert语句、优化group by语句、优化order by语句、优化join语句等等；\r\n</p>\r\n<p>\r\n	3）考虑定时优化文件及索引；\r\n</p>\r\n<p>\r\n	4）定期分析表，使用optimize table；\r\n</p>\r\n<p>\r\n	5）优化数据库对象；\r\n</p>\r\n<p>\r\n	6）考虑是否是锁问题；\r\n</p>\r\n<p>\r\n	7）调整一些MySQL Server参数，比如key_buffer_size、table_cache、innodb_buffer_pool_size、innodb_log_file_size等等；\r\n</p>\r\n<p>\r\n	8）如果数据量过大，可以考虑使用MySQL集群或者搭建高可用环境。\r\n</p>\r\n<p>\r\n	9）可能由于内存latch（泄露）导致数据库CPU高\r\n</p>\r\n<p>\r\n	10）在多用户高并发的情况下，任何系统都会hold不住的，所以，使用缓存是必须的，使用memcached或者redis缓存都可以；\r\n</p>\r\n<p>\r\n	11）看看tmp_table_size大小是否偏小，如果允许，适当的增大一点；\r\n</p>\r\n<p>\r\n	12）如果max_heap_table_size配置的过小，增大一点；\r\n</p>\r\n<p>\r\n	13）mysql的sql语句睡眠连接超时时间设置问题（wait_timeout）\r\n</p>\r\n<p>\r\n	14）使用show processlist查看mysql连接数，看看是否超过了mysql设置的连接数（http://www.cnblogs.com/kevingrace/p/6226324.html）\r\n</p>\r\n<p>\r\n	下面分享一例遇到过的案例：网站在高峰时段访问，点击页面有点卡。登陆服务器，发现机器负载有点高，并且mysql占用了很高的CPU资源，如下图：\r\n</p>\r\n<p>\r\n	MySQL负载居高不下，如果打开了慢查询日志功能，最好的办法就是针对慢查询日志里执行慢的sql语句进行优化，如果sql语句用了大量的group by等语句，union联合查询等肯定会将mysql的占用率提高。所以就需要优化sql语句\r\n</p>\r\n<p>\r\n	除了优化sql语句外，也可以做一些配置上的优化。在mysql中运行show proceslist;出现下面回显结果：1.查询有大量的Copying to tmp table on disk状态明显是由于临时表过大导致mysql将临时表写入硬盘影响了整体性能。\r\n</p>\r\n<p>\r\n	Mysql中tmp_table_size的默认值仅为16MB，在当前的情况下显然是不够用的。\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%tmp%\";+-------------------+----------+| Variable_name     | Value    |+-------------------+----------+| max_tmp_tables    | 32       || slave_load_tmpdir | /tmp     || tmp_table_size    | 16777216 || tmpdir            | /tmp     |+-------------------+----------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	解决办法：调整临时表大小1）进mysql终端命令修改，加上global,下次进mysql就会生效\r\n</p>\r\n<p>\r\n	mysql&gt; set global tmp_table_size=33554432;Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	再次登陆mysql\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%tmp%\";+-------------------+----------+| Variable_name     | Value    |+-------------------+----------+| max_tmp_tables    | 32       || slave_load_tmpdir | /tmp     || tmp_table_size    | 33554432 || tmpdir            | /tmp     |+-------------------+----------+4 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	2）my.cnf配置文件修改\r\n</p>\r\n<p>\r\n	[root@www ~]# vim my.cnf.....tmp_table_size = 32M\r\n</p>\r\n<p>\r\n	重启mysql[root@www ~]# /etc/init.d/mysqld restart\r\n</p>\r\n<p>\r\n	2.show processlist;命令的输出结果显示了有哪些线程在运行，可以帮助识别出有问题的查询语句。比如下面结果：Id  User Host db Command Time State Info 207 root 192.168.1.25:51718 mytest Sleep 5 NULL 先简单说一下各列的含义和用途，第一列，id，不用说了吧，一个标识，你要kill一个语句的时候很有用。user列，显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。host列，显示这个语句是从哪个ip的哪个端口上发出的。呵呵，可以用来追踪出问题语句的用户。db列，显示这个进程目前连接的是哪个数据库 。command列，显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。time列，此这个状态持续的时间，单位是秒。state列，显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成，info列，显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。常见问题：一般是睡眠连接过多，严重消耗mysql服务器资源(主要是cpu, 内存)，并可能导致mysql崩溃。\r\n</p>\r\n<p>\r\n	解决办法 ：在mysql的配置my.cnf文件中，有一项wait_timeout参数设置.即可设置睡眠连接超时秒数，如果某个连接超时，会被mysql自然终止。 wait_timeout过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能，不过也不能把这个指设置的过小，否则你可能会遭遇到“MySQL has gone away”之类的问题。通常来说，把wait_timeout设置为10小时是个不错的选择，但某些情况下可能也会出问题，比如说有一个CRON脚本，其中两次SQL查询的间隔时间大于10秒的话，那么这个设置就有问题了（当然，这也不是不能解决的问题，你可以在程序里时不时mysql_ping一下，以便服务器知道你还活着，重新计算wait_timeout时间）：\r\n</p>\r\n<p>\r\n	MySQL服务器默认的“wait_timeout”是28800秒即8小时，意味着如果一个连接的空闲时间超过8个小时，MySQL将自动断开该连接。然而连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致下面的报错：The last packet successfully received from the server was 596,688 milliseconds ago.mysql&gt; show variables like \'wait_timeout\';+---------------+-------+| Variable_name | Value |+---------------+-------+| wait_timeout  | 28800 |+---------------+-------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	28800seconds，也就是8小时。如果在wait_timeout秒期间内，数据库连接(java.sql.Connection)一直处于等待状态，mysql就将该连接关闭。这时，你的Java应用的连接池仍然合法地持有该连接的引用。当用该连接来进行数据库操作时，就碰到上述错误。可以将mysql全局变量wait_timeout的缺省值改大。查看mysql手册，发现对wait_timeout的最大值分别是24天/365天(windows/linux)。\r\n</p>\r\n<p>\r\n	比如将其改成30天mysql&gt; set global wait_timeout=124800;Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,3,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('2d2a2e6b-0f52-40e8-ae76-6ff0d9ec4f37','tornado项目web环境搭建-Centos7','tornado项目web环境nginx+supervisord搭建-Centos7','<p>\r\n	<span style=\"font-size:14px;\">系统 ：centos7.3+MySQL5.6.3+redis+nginx+supervisor</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">MySQL5.6.3二进制安装:</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">下载地址：<a href=\"http://ftp.jaist.ac.jp/pub/mysql/Downloads/MySQL-5.6/mysql-5.6.36-linux-glibc2.5-x86_64.tar.gz\" target=\"_blank\">http://ftp.jaist.ac.jp/pub/mysql/Downloads/MySQL-5.6/mysql-5.6.36-linux-glibc2.5-x86_64.tar.gz</a></span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">安装脚本和配置文件：<a href=\"http://117.48.201.88/downloadfile?id=11\" target=\"_blank\">http://117.48.201.88/downloadfile?id=11</a></span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">redis安装：</span><span style=\"font-size:14px;\">yum install -y redis</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">nginx的安装 配置文件脚本：<a href=\"http://117.48.201.88/downloadfile?id=9\">http://117.48.201.88/downloadfile?id=9</a></span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">supervisor安装：</span><span style=\"font-size:14px;\">pip install supervisor</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;\">supervisor的配置文件和使用方法：<a href=\"http://117.48.201.88/downloadfile?id=10\">http://117.48.201.88/downloadfile?id=10</a></span> \r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-26 13:43:57',2,78,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('2e7b7ad6-4424-40a8-b4ff-2c5f9a9ab061','利用mk-table-checksum监测Mysql主从数据一致性操作记录','利用mk-table-checksum监测Mysql主从数据一致性操作记录','<p>\r\n	前面已经提到了mysql主从环境下数据一致性检查：mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理今天这里再介绍另一种Mysql数据一致性自动检测工具:Maatkit。（不过Maatkit工具现在已经不维护了，推荐还是使用percona-toolkit工具吧！）\r\n</p>\r\n<p>\r\n	Maatkit是一个开源的工具包，为mySQL日常管理提供了帮助，它包含很多工具，这里主要说下面两个：\r\n</p>\r\n<p>\r\n	1）mk-table-checksum &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用来检测master和slave上的表结构和数据是否一致的；\r\n</p>\r\n<p>\r\n	2）mk-table-sync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在主从数据不一致时，用来修复数据的；先主后从有效保证表一致的工具，不必重载从表而能够保证一致。 上面两个perl脚本在运行时都会锁表，表的大小取决于执行的快慢，勿在高峰期间运行，可选择凌晨。-----------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	下面记录了这一操作过程：基本信息：master：192.168.1.101slave：192.168.1.102版本：mysql5.6同步的库：huanqiu、huanpc\r\n</p>\r\n<p>\r\n	Maatkit安装过程：（主库和从库服务器上都可以安装，因为数据一致性检查操作在主库或从库机器上都可以运行；建议主从机器上都安装）\r\n</p>\r\n<p>\r\n	1）安装该工具依赖的软件包\r\n</p>\r\n<p>\r\n	[root@master-server src]# yum install perl-IO-Socket-SSL perl-DBD-MySQL perl-Time-HiRes perl perl-DBI -y\r\n</p>\r\n<p>\r\n	2）maatkit下载安装 &nbsp; &nbsp;\r\n</p>\r\n<p>\r\n	[需要FQ到官网下载：https://code.google.com/archive/p/maatkit/downloads]\r\n</p>\r\n<p>\r\n	百度云盘下载地址：https://pan.baidu.com/s/1c1AufW8 &nbsp; &nbsp;（提取密码：vbi1）\r\n</p>\r\n<p>\r\n	[root@master-server ~]# tar -zvxf maatkit-7540.tar.gz &nbsp;&amp;&amp;&nbsp;cd maatkit-7540&nbsp;\r\n</p>\r\n<p>\r\n	[root@master-server maatkit-7540]# perl Makefile.PLChecking if your kit is complete...Looks goodWriting Makefile for maatkit------------------------------------------------------------------------------------------------------------如有报错：Can\'t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at Makefile.PL line 1.BEGIN failed--compilation aborted at Makefile.PL line&nbsp;\r\n</p>\r\n<p>\r\n	1.解决办法：\r\n</p>\r\n<p>\r\n	[root@slave-server maatkit-4334]# yum install perl-ExtUtils-Embed perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker&nbsp;-y------------------------------------------------------------------------------------------------------------[root@master-server maatkit-4334]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //按TAB键补全，可以查看到Maatkit的所有命令\r\n</p>\r\n<p>\r\n	mk-archiver               mk-find                   mk-parallel-dump          mk-show-grants            mk-table-sync\r\n</p>\r\n<p>\r\n	mk-checksum-filter        mk-heartbeat              mk-parallel-restore       mk-slave-delay            mk-table-usage\r\n</p>\r\n<p>\r\n	mk-config-diff            mk-index-usage            mk-profile-compact        mk-slave-find             mk-tcp-model\r\n</p>\r\n<p>\r\n	mk-deadlock-logger        mk-kill                   mk-purge-logs             mk-slave-move             mk-upgrade\r\n</p>\r\n<p>\r\n	mk-duplicate-key-checker  mk-loadavg                mk-query-advisor          mk-slave-prefetch         mk-variable-advisor\r\n</p>\r\n<p>\r\n	mk-error-log              mk-log-player             mk-query-digest           mk-slave-restart          mk-visual-explain\r\n</p>\r\n<p>\r\n	mk-fifo-split             mk-merge-mqd-results      mk-query-profiler         mk-table-checksum\r\n</p>\r\n<p>\r\n	安装完成后，一定要在被校验的主从服务器上创建只有SELECT权限的帐号（最好保持主从上创建的账号和密码一样，方便操作）\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT SELECT ON *.* TO \'data_check\'@\'%\' IDENTIFIED BY \'check@123\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	使用mk-table-checksum检查主从数据一致性1）在主库服务器上运行数据一致性检查操作（也可以在从库服务器上进行数据一致性检查操作，命令跟下面一样）[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306  h=192.168.1.102,u=data_check,p=check@123,P=3306\r\n</p>\r\n<p>\r\n	DATABASE TABLE                     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	mysql    columns_priv                  0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    columns_priv                  0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    db                            0 192.168.1.101 MyISAM       NULL       4197331717    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    db                            0 192.168.1.102 MyISAM       NULL       4197331717    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    event                         0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    event                         0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    func                          0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    func                          0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    general_log                   0 192.168.1.101 CSV          NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    general_log                   0 192.168.1.102 CSV          NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_category                 0 192.168.1.101 MyISAM       NULL       2621154011    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_category                 0 192.168.1.102 MyISAM       NULL       2621154011    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_keyword                  0 192.168.1.101 MyISAM       NULL       2791798352    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_keyword                  0 192.168.1.102 MyISAM       NULL        578891347    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_relation                 0 192.168.1.101 MyISAM       NULL       3733405838    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_relation                 0 192.168.1.102 MyISAM       NULL       1649042165    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_topic                    0 192.168.1.101 MyISAM       NULL       1795841156    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    help_topic                    0 192.168.1.102 MyISAM       NULL       2642710534    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    innodb_index_stats            0 192.168.1.101 InnoDB       NULL       1853713685    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    innodb_index_stats            0 192.168.1.102 InnoDB       NULL        213249811    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    innodb_table_stats            0 192.168.1.101 InnoDB       NULL       2028951538    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    innodb_table_stats            0 192.168.1.102 InnoDB       NULL       4163315044    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    ndb_binlog_index              0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    ndb_binlog_index              0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    plugin                        0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    plugin                        0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    proc                          0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    proc                          0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    procs_priv                    0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    procs_priv                    0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    proxies_priv                  0 192.168.1.101 MyISAM       NULL       3956276869    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    proxies_priv                  0 192.168.1.102 MyISAM       NULL       2040113179    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    servers                       0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    servers                       0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_master_info             0 192.168.1.101 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_master_info             0 192.168.1.102 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_relay_log_info          0 192.168.1.101 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_relay_log_info          0 192.168.1.102 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_worker_info             0 192.168.1.101 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slave_worker_info             0 192.168.1.102 InnoDB       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slow_log                      0 192.168.1.101 CSV          NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    slow_log                      0 192.168.1.102 CSV          NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    tables_priv                   0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    tables_priv                   0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone                     0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone                     0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_leap_second         0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_leap_second         0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_name                0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_name                0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_transition          0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_transition          0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_transition_type     0 192.168.1.101 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    time_zone_transition_type     0 192.168.1.102 MyISAM       NULL                0    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    user                          0 192.168.1.101 MyISAM       NULL        882367917    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	mysql    user                          0 192.168.1.102 MyISAM       NULL        883514797    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB       NULL       1230819712    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB       NULL       3864574229    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB       NULL       1378115040    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB       NULL       1378115040    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB       NULL       2427682155    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB       NULL        289696409    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB       NULL       1446184115    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB       NULL       1956266704    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	上面命令中参数解释：第一个h： &nbsp; 填写主库ip第一个u： &nbsp; 主库授权的用户名第一个p： &nbsp; 主库授权的密码第二个h： &nbsp; 填写从库ip第二个u： &nbsp; 从库授权的用户名第二个p： &nbsp; 从库授权的密码P： &nbsp; mysql的端口\r\n</p>\r\n<p>\r\n	上面的命令所示检查主从的所有库的数据一致性；一般我们检查的是同步的库。这就需要添加参数：-d(或者--database)&nbsp; &nbsp; 后接数据库名，注意后面不需要加=号，多个数据库之间用逗号隔开，比如-dhuanqiu,huanpc;如果不加-d，校验的是所有库；--count&nbsp; &nbsp; 会计算出表的行数\r\n</p>\r\n<p>\r\n	如下操作：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306  h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu --count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; //针对单个库huanqiu，检查主从数据一致性\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB          1         f163e1ff    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB          4         481dfe49    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB          5         ecb4850b    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306 &nbsp;h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanpc --count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;//针对单个库huanpc，检查主从数据一致性\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB          1         96d7dfcf    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB          6          a12d47d    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB          7         5681c480    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306 &nbsp;h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu,huanpc --count &nbsp; &nbsp; &nbsp; &nbsp;//针对多个库huaniu、huanpc，检查主从数据一致性\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB          1         f163e1ff    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB          4         481dfe49    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB          5         ecb4850b    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB          1         96d7dfcf    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB          6          a12d47d    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB          7         5681c480    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	上述结果中的参数解释：DATABASE： &nbsp; &nbsp; 检查的库名TABLE： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 检查的库中的表名CHUNK： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;checksum时的近似数值HOST： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主从MYSQL的地址ENGINE： &nbsp; &nbsp; &nbsp; &nbsp; 表引擎COUNT： &nbsp; &nbsp; &nbsp; &nbsp; 表的行数CHECKSUM： &nbsp;校验值TIME： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;所用时间WAIT： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 等待时间STAT： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MASTER_POS_WAIT()返回值LAG： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;slave的延时时间\r\n</p>\r\n<p>\r\n	mk-checksum-filter过滤工具的使用如果只想知道huanqiu库中哪些表不是一致的，那么只需要加一个管道符即可，如下：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306  h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu --count&nbsp;| mk-checksum-filter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //如下表示huanqiu库下只有haha表的数据，主从不一致\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB          1         f163e1ff    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB          4         481dfe49    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB          5         ecb4850b    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306 &nbsp;h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanpc --count &nbsp;| mk-checksum-filter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//如下表示huanqiu库下只有haha表的数据，主从不一致\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB          1         96d7dfcf    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB          6          a12d47d    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB          7         5681c480    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306 &nbsp;h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu,huanpc --count&nbsp;| mk-checksum-filter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//如下表示huanqiu库下只有haha表的数据，主从不一致\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB          1         f163e1ff    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB          4         481dfe49    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB          5         ecb4850b    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB          1         96d7dfcf    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB          6          a12d47d    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB          7         5681c480    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	使用mk-table-sync修复主从不同步的数据顾名思义，mk-table-sync用来修复多个实例之间数据的不一致。它可以让主从的数据修复到最终一致，也可以使通过应用双写或多写的多个不相关的数据库实例修复到一致。同时它还内部集成了pt-table-checksum的校验功能，可以一边校验一边修复，也可以基于pt-table-checksum的计算结果来进行修复。mk-table-sync工作原理1）单行数据checksum值的计算计算逻辑与pt-table-checksum一样，也是先检查表结构，并获取每一列的数据类型，把所有数据类型都转化为字符串，然后用concat_ws()函数进行连接，由此计算出该行的checksum值。checksum默认采用crc32计算。\r\n</p>\r\n<p>\r\n	2）数据块checksum值的计算同pt-table-checksum工具一样，pt-table-sync会智能分析表上的索引，然后把表的数据split成若干个chunk，计算的时候以chunk为单位。可以理解为把chunk内所有行的数据拼接起来，再计算crc32的值，即得到该chunk的checksum值。\r\n</p>\r\n<p>\r\n	3）坏块检测和修复前面两步，pt-table-sync与pt-table-checksum的算法和原理一样。再往下，就开始有所不同：pt-table-checksum只是校验，所以它把checksum结果存储到统计表，然后把执行过的sql语句记录到binlog中，任务就算完成。语句级的复制把计算逻辑传递到从库，并在从库执行相同的计算。pt-table-checksum的算法本身并不在意从库的延迟，延迟多少都一样计算(有同事对此不理解，可以参考我的前一篇文章)，不会影响计算结果的正确性(但是我们还是会检测延迟，因为延迟太多会影响业务，所以总是要加上—max-lag来限流)。 pt-table-sync则不同。它首先要完成chunk的checksum值的计算，一旦发现主从上同样的chunk的checksum值不同，就深入到该chunk内部，逐行比较并修复有问题的行。其计算逻辑描述如下(以修复主从结构的数据不一致为例，业务双写的情况修复起来更复杂—因为涉及到冲突解决和基准选择的问题，限于篇幅，这里不介绍)：&nbsp; &nbsp; 1）对每一个从库，每一个表，循环进行如下校验和修复过程。&nbsp; &nbsp; 2）对每一个chunk，在校验时加上for update锁。一旦获得锁，就记录下当前主库的show master status值。&nbsp; &nbsp; 3）在从库上执行select master_pos_wait()函数，等待从库sql线程执行到show master status得到的位置。以此保证，主从上关于这个chunk的内容均不再改变。&nbsp; &nbsp; 4）对这个chunk执行checksum，然后与主库的checksum进行比较。&nbsp; &nbsp; 5）如果checksum相同，说明主从数据一致，就继续下一个chunk。&nbsp; &nbsp; 6）如果checksum不同，说明该chunk有不一致。深入chunk内部，逐行计算checksum并比较(单行checksum比较过程与chunk的比较过程一样，单行实际是chunk的size为1的特例)。&nbsp; &nbsp; 7）如果发现某行不一致，则标记下来。继续检测剩余行，直到这个chunk结束。&nbsp; &nbsp; 8）对找到的主从不一致的行，采用replace into语句，在主库执行一遍以生成该行全量的binlog，并同步到从库，这会以主库数据为基准来修复从库；对于主库有的行而从库没有的行，采用replace在主库上插入(必须不能是insert)；对于从库有而主库没有的行，通过在主库执行delete来删除(pt-table-sync强烈建议所有的数据修复都只在主库进行，而不建议直接修改从库数据；但是也有特例，后面会讲到)。&nbsp; &nbsp; 9）直到修复该chunk所有不一致的行。继续检查和修复下一个chunk。&nbsp; &nbsp;10）直到这个从库上所有的表修复结束。开始修复下一个从库。\r\n</p>\r\n<p>\r\n	重要选项--print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;显示同步需要执行的语句--execute &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行数据同步--charset=utf8 &nbsp; &nbsp; &nbsp; &nbsp;设置字符集，避免从库乱码。\r\n</p>\r\n<p>\r\n	实例说明：mk-table-sync的工作方式是：先一行一行检查主从库的表是否一样，如果哪里不一样，就执行删除，更新，插入等操作，使其达到一致。通过上面mk-table-checksum的检查结果可以看出，同步的两个库huanqiu和huanpc的数据并不一致，这时就可以使用mk-table-sync进行数据修复了。\r\n</p>\r\n<p>\r\n	数据修复命令如下：（如果mysql端口是默认的3306，则下面命令中的P=3306可以省略）由于上面在mk-table-checksum检查时用的data_check只有select权限，权限太小，不能用于mk-table-sync修复数据只用。所以还需要在主库和从库数据库里创建用于mk-table-sync修复数据之用的账号权限\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT ALL ON *.* to mksync@\'%\' identified by \"sync@123\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	[root@master-server lib]# mk-table-sync --execute --charset=utf8 --print --no-check-slave --databases huanqiu,huanpc h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.102,u=mksync,p=sync@123,P=3306\r\n</p>\r\n<p>\r\n	UPDATE `huanpc`.`checksums` SET `chunk_time`=\'0.002821\', `chunk_index`=NULL, `lower_boundary`=NULL, `upper_boundary`=NULL, `this_crc`=\'5681c480\', `this_cnt`=\'7\', `master_crc`=\'5681c480\', `master_cnt`=\'7\', `ts`=\'2017-01-12 14:29:14\' WHERE `db`=\'huanpc\' AND `tbl`=\'heihei\' AND `chunk`=\'1\' LIMIT 1 /*maatkit src_db:huanpc src_tbl:checksums src_dsn:A=utf8,P=3306,h=192.168.1.101,p=...,u=mksync dst_db:huanpc dst_tbl:checksums dst_dsn:A=utf8,P=3306,h=192.168.1.102,p=...,u=mksync lock:0 transaction:1 changing_src:0 replicate:0 bidirectional:0 pid:13702 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	DELETE FROM `huanpc`.`heihei` WHERE `member`=\'90\' LIMIT 1 /*maatkit src_db:huanpc src_tbl:heihei src_dsn:A=utf8,P=3306,h=192.168.1.101,p=...,u=mksync dst_db:huanpc dst_tbl:heihei dst_dsn:A=utf8,P=3306,h=192.168.1.102,p=...,u=mksync lock:0 transaction:1 changing_src:0 replicate:0 bidirectional:0 pid:13702 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	UPDATE `huanqiu`.`checksums` SET `chunk_time`=\'0.002495\', `chunk_index`=NULL, `lower_boundary`=NULL, `upper_boundary`=NULL, `this_crc`=\'ecb4850b\', `this_cnt`=\'5\', `master_crc`=\'ecb4850b\', `master_cnt`=\'5\', `ts`=\'2017-01-12 14:27:45\' WHERE `db`=\'huanqiu\' AND `tbl`=\'haha\' AND `chunk`=\'1\' LIMIT 1 /*maatkit src_db:huanqiu src_tbl:checksums src_dsn:A=utf8,P=3306,h=192.168.1.101,p=...,u=mksync dst_db:huanqiu dst_tbl:checksums dst_dsn:A=utf8,P=3306,h=192.168.1.102,p=...,u=mksync lock:0 transaction:1 changing_src:0 replicate:0 bidirectional:0 pid:13702 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	DELETE FROM `huanqiu`.`haha` WHERE `id`=\'90\' LIMIT 1 /*maatkit src_db:huanqiu src_tbl:haha src_dsn:A=utf8,P=3306,h=192.168.1.101,p=...,u=mksync dst_db:huanqiu dst_tbl:haha dst_dsn:A=utf8,P=3306,h=192.168.1.102,p=...,u=mksync lock:0 transaction:1 changing_src:0 replicate:0 bidirectional:0 pid:13702 user:root host:master-server*/;\r\n</p>\r\n<p>\r\n	上面那条命令执行后，再次检查主从数据，发现主从已经同步：\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306  h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu,huanpc --count\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.101 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  checksums     0 192.168.1.102 InnoDB          1         705c5e2e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.101 InnoDB          3         b9b29a07    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanqiu  haha          0 192.168.1.102 InnoDB          3         b9b29a07    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	DATABASE TABLE     CHUNK HOST          ENGINE      COUNT         CHECKSUM TIME WAIT STAT  LAG\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.101 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   checksums     0 192.168.1.102 InnoDB          1          5af891e    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.101 InnoDB          7         22a57b1c    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	huanpc   heihei        0 192.168.1.102 InnoDB          7         22a57b1c    0    0 NULL NULL\r\n</p>\r\n<p>\r\n	或者加mk-checksum-filter\r\n</p>\r\n<p>\r\n	[root@master-server ~]# mk-table-checksum h=192.168.1.101,u=data_check,p=check@123,P=3306  h=192.168.1.102,u=data_check,p=check@123,P=3306 -dhuanqiu,huanpc --count | mk-checksum-filter\r\n</p>\r\n<p>\r\n	[root@master-server ~]#\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------------------------------------------------如有报错：DBD::mysql::db do failed: Access denied; you need (at least one of) the SUPER privilege(s) for this operation [for Statement \"/*!50105 SET @@binlog_format=\"STATEMENT\"*/\"] at /usr/local/bin/mk-table-sync line 8568.Issuing rollback() due to DESTROY without explicit disconnect() of DBD::mysql::db handle ;host=192.168.1.101;port=3306;mysql_read_default_group=client at /usr/local/bin/mk-table-sync line 8568.\r\n</p>\r\n<p>\r\n	解决办法：安装DBI和DBD-MySQL下载地址：http://ftp.cuhk.edu.hk/pub/packages/perl/CPAN/authors/id/T/TI/TIMB/http://search.cpan.org/dist/DBD-mysql/  或者百度云盘下载：https://pan.baidu.com/s/1miv0S8g     （提取密码：fh24）\r\n</p>\r\n<p>\r\n	[root@master-server src]# tar -zvxf DBI-1.634.tar.gz [root@master-server src]# cd DBI-1.634[root@master-server DBI-1.634]# perl Makefile.PL[root@master-server DBI-1.634]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	[root@master-server src]# tar -zvxf DBD-mysql-4.041_01.tar.gz [root@master-server src]# cd DBD-mysql-4.041_01[root@master-server DBD-mysql-4.041_01]# perl Makefile.PL --mysql_config=/usr/local/mysql/bin/mysql_config &nbsp; &nbsp; &nbsp; &nbsp; //主库mysql安装路径/usr/local/mysql[root@master-server DBD-mysql-4.041_01]# make[root@master-server DBD-mysql-4.041_01]# make install--------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	这里要说明一下：主从数据库表和表结构必须一致,否则会报错！--no-check-slave这个参数，如果不加这个参数，会提示报错，因为此工具默认不允许在从库上修改数据，但这里为了不在主库上dump出来，再到从库上导入进去，加了这个参数。\r\n</p>\r\n<p>\r\n	特别注意的是：1）如果想要看下到底哪些数据不同步，可以这样做：（如果不跟-t参数，就是说同步整个库的所有表的数据）mk-table-sync --execute --charset=utf8 --print --no-check-slave --databases huanqiu,huanpc h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.102,u=mksync,p=sync@123,P=3306 &gt; /root/result2）如果有好几个从库的话，建议分开同步，除非几个从库的checksum一样！ 因为每个从库同步的步调不一定都一致，如果几个从库一块同步的话，很容易造成主键冲突，导致主从同步中断。举个例子来说：主库：192.168.1.101从库1: 192.168.1.102从库2: 192.168.1.103从库3: 192.168.1.104\r\n</p>\r\n<p>\r\n	建议(分开同步，一个个操作)：mk-table-sync --execute --charset=utf8 --print --no-check-slave -d huanqiu -t haha h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.102,u=mksync,p=sync@123,P=3306 &gt; /root/result1mk-table-sync --execute --charset=utf8 --print --no-check-slave -d huanqiu -t haha h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.103,u=mksync,p=sync@123,P=3306 &gt; /root/result2mk-table-sync --execute --charset=utf8 --print --no-check-slave -d huanqiu -t haha h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.104,u=mksync,p=sync@123,P=3306 &gt; /root/result3不建议（放在一起同步）：mk-table-sync --execute --charset=utf8 --print --no-check-slave -d huanqiu -t haha h=192.168.1.101,u=mksync,p=sync@123,P=3306 h=192.168.1.102,u=mksync,p=sync@123,P=3306 h=192.168.1.103,u=mksync,p=sync@123,P=3306 h=192.168.1.104,u=data_check,p=check@123,P=3306 &gt; /root/result\r\n</p>\r\n<p>\r\n	4）为了减少重复操作，也可以一次同步好几个表，多个表时可以在-t后加=号，即-t=tables1,tables2,table3...比如：mk-table-sync --execute --charset=utf8 --print --no-check-slave -d huanqiu -t=haha,heihei,hehe,name h=192.168.1.101,u=data_check,p=check@123,P=3306 h=192.168.1.102,u=mksync,p=sync@123,P=3306 &gt; /root/result\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('3027a190-d2fc-4b6f-8a9e-073b6fe8480d','mysql完整备份时过滤掉某些库','mysql完整备份时过滤掉某些库','<p>\r\n	mysql进行完整备份时使用--all-database参数比如：#mysqldump -u root -h localhost -p --all-database &gt; /root/all.sql\r\n</p>\r\n<p>\r\n	数据导入的时候，可以先登陆mysql数据库中，使用source /root/all.sql进行导入。\r\n</p>\r\n<p>\r\n	问题：想要在mysqldump备份数据库的时候，过滤掉某些库。这种情况mysqldump备份的时候就不能使用--all-database了，而是使用--database。\r\n</p>\r\n<p>\r\n	如下：备份数据库的时候过滤掉information_schema、mysql 、test和jkhw_db库\r\n</p>\r\n<p>\r\n	[root@fangfull-backup ~]# mysql -uroot -p -e \"show databases\"Enter password:\r\n</p>\r\n<p>\r\n	+--------------------+| Database           |+--------------------+| information_schema || hqsb_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || jkhw_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || mysql &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || test &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| tech_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || hqtime_o2o_db      || hq_o2o_db &nbsp; &nbsp; &nbsp; &nbsp;|| hqtime_o2o_db_new  |+--------------------+9 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	操作方法：\r\n</p>\r\n<p>\r\n	[root@fangfull-backup ~]# mysql -uroot -p -e \"show databases\"|grep -Ev \"Database|information_schema|mysql|test|jkhw_db\"Enter password: hqsb_dbtech_db            hqtime_o2o_db      hq_o2o_db          hqtime_o2o_db_new&nbsp;\r\n</p>\r\n<p>\r\n	[root@fangfull-backup ~]# mysql -uroot -p -e \"show databases\"|grep -Ev \"Database|information_schema|mysql|test|jkhw_db\"|xargsEnter password: hqsb_db tech_db hqtime_o2o_db hq_o2o_db hqtime_o2o_db_new&nbsp;\r\n</p>\r\n<p>\r\n	[root@fangfull-backup ~]# mysql -uroot -p -e \"show databases\"|grep -Ev \"Database|information_schema|mysql|test|jkhw_db\"|xargs mysqldump -uroot -p --databases &gt; mysql_dump.sqlEnter password:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('30e9081d-fc4e-4b99-8941-d321c216c5b0','nginx应用总结（2）--突破高并发的性能优化','nginx应用总结（2）--突破高并发的性能优化','<p>\r\n	在日常的运维工作中，经常会用到nginx服务，也时常会碰到nginx因高并发导致的性能瓶颈问题。今天这里简单梳理下nginx性能优化的配置（仅仅依据本人的实战经验而述，如有不妥，敬请指出~）\r\n</p>\r\n<p>\r\n	一、这里的优化主要是指对nginx的配置优化，一般来说nginx配置文件中对优化比较有作用的主要有以下几项：1）nginx进程数，建议按照cpu数目来指定，一般跟cpu核数相同或为它的倍数。 worker_processes 8;2）为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。 worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;3）下面这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是系统的最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。 worker_rlimit_nofile 65535;4）使用epoll的I/O模型，用这个模型来高效处理异步事件 use epoll;5）每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。 worker_connections 65535;6）http连接超时时间，默认是60s，功能是使客户端到服务器端的连接在设定的时间内持续有效，当出现对服务器的后继请求时，该功能避免了建立或者重新建立连接。切记这个参数也不能设置过大！否则会导致许多无效的http连接占据着nginx的连接数，终nginx崩溃！ keepalive_timeout 60;7）客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 4k;8）下面这个参数将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=102400 inactive=20s;9）下面这个是指多长时间检查一次缓存的有效信息。 open_file_cache_valid 30s;10）open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 open_file_cache_min_uses 1;\r\n</p>\r\n<p>\r\n	11）隐藏响应头中的有关操作系统和web server（Nginx）版本号的信息，这样对于安全性是有好处的。server_tokens off;12）可以让sendfile()发挥作用。sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile)。sendfile on;13）告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。就是说数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。tcp_nopush on; 14）告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。tcp_nodelay on;比如：http { server_tokens off; sendfile on; tcp_nopush on; tcp_nodelay on; ......} 15）客户端请求头部的缓冲区大小，这个可以根据系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 client_header_buffer_size 4k;客户端请求头部的缓冲区大小，这个可以根据系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 分页大小可以用命令getconf PAGESIZE取得。[root@test-huanqiu ~]# getconf PAGESIZE 4096但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。16）为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。open_file_cache max=65535 inactive=60s;17）open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。open_file_cache_min_uses 1;18）指定多长时间检查一次缓存的有效信息。open_file_cache_valid 80s;\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------- 下面是一个本人使用的简单的nginx配置文件：\r\n</p>\r\n<p>\r\n	[root@dev-huanqiu ~]# cat /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	user   www www;\r\n</p>\r\n<p>\r\n	worker_processes 8;\r\n</p>\r\n<p>\r\n	worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000;\r\n</p>\r\n<p>\r\n	error_log   /www/log/nginx_error.log   crit;\r\n</p>\r\n<p>\r\n	pid         /usr/local/nginx/nginx.pid;\r\n</p>\r\n<p>\r\n	worker_rlimit_nofile 65535;\r\n</p>\r\n<p>\r\n	events\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	use epoll;\r\n</p>\r\n<p>\r\n	worker_connections 65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type   application/octet-stream;\r\n</p>\r\n<p>\r\n	charset   utf-8;\r\n</p>\r\n<p>\r\n	server_names_hash_bucket_size 128;\r\n</p>\r\n<p>\r\n	client_header_buffer_size 2k;\r\n</p>\r\n<p>\r\n	large_client_header_buffers 4 4k;\r\n</p>\r\n<p>\r\n	client_max_body_size 8m;\r\n</p>\r\n<p>\r\n	sendfile on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	keepalive_timeout 60;\r\n</p>\r\n<p>\r\n	fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2\r\n</p>\r\n<p>\r\n	keys_zone=TEST:10m\r\n</p>\r\n<p>\r\n	inactive=5m;\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 300;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 300;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 300;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 16k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 16 16k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 16k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 16k;\r\n</p>\r\n<p>\r\n	fastcgi_cache TEST;\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid 200 302 1h;\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid 301 1d;\r\n</p>\r\n<p>\r\n	fastcgi_cache_valid any 1m;\r\n</p>\r\n<p>\r\n	fastcgi_cache_min_uses 1;\r\n</p>\r\n<p>\r\n	fastcgi_cache_use_stale error timeout invalid_header http_500;\r\n</p>\r\n<p>\r\n	open_file_cache max=204800 inactive=20s;\r\n</p>\r\n<p>\r\n	open_file_cache_min_uses 1;\r\n</p>\r\n<p>\r\n	open_file_cache_valid 30s;\r\n</p>\r\n<p>\r\n	tcp_nodelay on;\r\n</p>\r\n<p>\r\n	gzip on;\r\n</p>\r\n<p>\r\n	gzip_min_length   1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.0;\r\n</p>\r\n<p>\r\n	gzip_comp_level 2;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen       8080;\r\n</p>\r\n<p>\r\n	server_name   huan.wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.php index.htm;\r\n</p>\r\n<p>\r\n	root   /www/html/;\r\n</p>\r\n<p>\r\n	location /status\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	stub_status on;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(php|php5)?$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	fastcgi_pass 127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	include fcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|js|css)$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	expires       30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	log_format   access   \'$remote_addr - $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" $http_x_forwarded_for\';\r\n</p>\r\n<p>\r\n	access_log   /www/log/access.log   access;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	二、关于FastCGI的几个指令\r\n</p>\r\n<p>\r\n	1）这个指令为FastCGI缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间。 fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m;2）指定连接到后端FastCGI的超时时间。 fastcgi_connect_timeout 300;3）向FastCGI传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI传送请求的超时时间。 fastcgi_send_timeout 300;4）接收FastCGI应答的超时时间，这个值是指已经完成两次握手后接收FastCGI应答的超时时间。 fastcgi_read_timeout 300;5）指定读取FastCGI应答第一部分 需要用多大的缓冲区，这里可以设置为fastcgi_buffers指令指定的缓冲区大小，上面的指令指定它将使用1个 16k的缓冲区去读取应答的第一部分，即应答头，其实这个应答头一般情况下都很小（不会超过1k），但是你如果在fastcgi_buffers指令中指 定了缓冲区的大小，那么它也会分配一个fastcgi_buffers指定的缓冲区大小去缓存。 fastcgi_buffer_size 16k;6）指定本地需要用多少和多大的缓冲区来 缓冲FastCGI的应答，如上所示，如果一个php脚本所产生的页面大小为256k，则会为其分配16个16k的缓冲区来缓存，如果大于256k，增大 于256k的部分会缓存到fastcgi_temp指定的路径中， 当然这对服务器负载来说是不明智的方案，因为内存中处理数据速度要快于硬盘，通常这个值 的设置应该选择一个你的站点中的php脚本所产生的页面大小的中间值，比如你的站点大部分脚本所产生的页面大小为 256k就可以把这个值设置为16 16k，或者4 64k 或者64 4k，但很显然，后两种并不是好的设置方法，因为如果产生的页面只有32k，如果用4 64k它会分配1个64k的缓冲区去缓存，而如果使用64 4k它会分配8个4k的缓冲区去缓存，而如果使用16 16k则它会分配2个16k去缓存页面，这样看起来似乎更加合理。 fastcgi_buffers 16 16k;7）这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers的两倍。 fastcgi_busy_buffers_size 32k;8）在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍。 fastcgi_temp_file_write_size 32k;9）开启FastCGI缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU负载，并且防止502错误。但是这个缓存会引起很多问题，因为它缓存的是动态页面。具体使用还需根据自己的需求。 fastcgi_cache TEST10）为指定的应答代码指定缓存时间，如上例中将200，302应答缓存一小时，301应答缓存1天，其他为1分钟。 fastcgi_cache_valid 200 302 1h;   fastcgi_cache_valid 301 1d;   fastcgi_cache_valid any 1m;11）缓存在fastcgi_cache_path指令inactive参数值时间内的最少使用次数，如上例，如果在5分钟内某文件1次也没有被使用，那么这个文件将被移除。 fastcgi_cache_min_uses 1;12）不知道这个参数的作用，猜想应该是让nginx知道哪些类型的缓存是没用的。 fastcgi_cache_use_stale error timeout invalid_header http_500;\r\n</p>\r\n<p>\r\n	-----------------------------------以上为nginx中FastCGI相关参数，另外，FastCGI自身也有一些配置需要进行优化，如果你使用php-fpm来管理FastCGI，可以修改配置文件中的以下值：1）同时处理的并发请求数，即它将开启最多60个子线程来处理并发连接。602）最多打开文件数。655353）每个进程在重置之前能够执行的最多请求数。65535\r\n</p>\r\n<p>\r\n	三、关于内核参数的优化，在/etc/sysctl.conf文件内1）timewait的数量，默认是180000。(Deven:因此如果想把timewait降下了就要把tcp_max_tw_buckets值减小) net.ipv4.tcp_max_tw_buckets = 60002）允许系统打开的端口范围。 net.ipv4.ip_local_port_range = 1024     650003）启用TIME-WAIT状态sockets快速回收功能;用于快速减少在TIME-WAIT状态TCP连接数。1表示启用;0表示关闭。但是要特别留意的是：这个选项一般不推荐启用，因为在NAT(Network Address Translation)网络下，会导致大量的TCP连接建立错误，从而引起网站访问故障。 net.ipv4.tcp_tw_recycle = 0----------------------------------------------------------------------------------------------------------------------------------实际上，net.ipv4.tcp_tw_recycle功能的开启，要需要net.ipv4.tcp_timestamps（一般系统默认是开启这个功能的）这个开关开启后才有效果；当tcp_tw_recycle 开启时（tcp_timestamps 同时开启，快速回收 socket 的效果达到），对于位于NAT设备后面的 Client来说，是一场灾难！会导致到NAT设备后面的Client连接Server不稳定（有的 Client 能连接 server，有的 Client 不能连接 server）。也就是说，tcp_tw_recycle这个功能，是为内部网络（网络环境自己可控 ” ——不存在NAT 的情况）设计的，对于公网环境下，不宜使用。通常来说，回收TIME_WAIT状态的socket是因为“无法主动连接远端”，因为无可用的端口，而不应该是要回收内存（没有必要）。即：需求是Client的需求，Server会有“端口不够用”的问题吗？除非是前端机，需要大量的连接后端服务，也就是充当着Client的角色。\r\n</p>\r\n<p>\r\n	正确的解决这个总是办法应该是：net.ipv4.ip_local_port_range = 9000 6553 #默认值范围较小net.ipv4.tcp_max_tw_buckets = 10000 #默认值较小，还可适当调小net.ipv4.tcp_tw_reuse = 1&nbsp;net.ipv4.tcp_fin_timeout = 10&nbsp;----------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	4）开启重用功能，允许将TIME-WAIT状态的sockets重新用于新的TCP连接。这个功能启用是安全的，一般不要去改动！ net.ipv4.tcp_tw_reuse = 15）开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。 net.ipv4.tcp_syncookies = 16）web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。 net.core.somaxconn = 2621447）每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 net.core.netdev_max_backlog = 2621448）系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。 net.ipv4.tcp_max_orphans = 2621449）记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。 net.ipv4.tcp_max_syn_backlog = 26214410）时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。 net.ipv4.tcp_timestamps = 1 -------------------------------------------------------------------------------------------------------------------------------------------------------   有不少服务器为了提高性能，开启net.ipv4.tcp_tw_recycle选项，在NAT网络环境下，容易导致网站访问出现了一些connect失败的问题   个人建议：   关闭net.ipv4.tcp_tw_recycle选项，而不是net.ipv4.tcp_timestamps；   因为在net.ipv4.tcp_timestamps关闭的条件下，开启net.ipv4.tcp_tw_recycle是不起作用的；而net.ipv4.tcp_timestamps可以独立开启并起作用。   -------------------------------------------------------------------------------------------------------------------------------------------------------11）为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。 net.ipv4.tcp_synack_retries = 112）在内核放弃建立连接之前发送SYN包的数量。 net.ipv4.tcp_syn_retries = 113）如果套接字由本端要求关闭，这个参数 决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。 net.ipv4.tcp_fin_timeout = 3014）当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。 net.ipv4.tcp_keepalive_time = 30\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------下面贴出一个本人常用的内核参数的标准配置[root@dev-huanqiu ~]# cat /etc/sysctl.confnet.ipv4.ip_forward = 0net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1net.ipv4.tcp_syncookies = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//这四行标红内容，一般是发现大量TIME_WAIT时的解决办法kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 4096         87380   4194304net.ipv4.tcp_wmem = 4096         16384   4194304net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//在net.ipv4.tcp_tw_recycle设置为1的时候，这个选择最好加上net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_tw_recycle = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //开启此功能可以减少TIME-WAIT状态，但是NAT网络模式下打开有可能会导致tcp连接错误，慎重。net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 30net.ipv4.ip_local_port_range = 1024     65000net.ipv4.ip_conntrack_max = 6553500\r\n</p>\r\n<p>\r\n	-------------------------------------记一次小事故----------------------------------------------------net.ipv4.tcp_tw_recycle = 1 这个功能打开后，确实能减少TIME-WAIT状态，习惯上我都会将这个参数打开。但是也因为这个参数踩过一次坑：公司的一个发布新闻的CMS后台系统，采用haproxy+keepalived代理架构，后端的real server服务器外网ip全部拿掉。现象：在某一天早上发文高峰期，CMS后台出现访问故障，重启php服务后会立刻见效，但持续一段时间后，访问就又出现故障。排查nginx和php日志也没有发现什么，后来google了一下，发现就是net.ipv4.tcp_tw_recycle这个参数捣的鬼！这种网络架构对于后端的realserver来说是NAT模式，打开这个参数后，会导致大量的TCP连接建立错误，从而引起网站访问故障。最后将net.ipv4.tcp_tw_recycle设置为0，关闭这个功能后，后台访问即刻恢复正常-----------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	-------------------------------Nginx安全配置小提示------------------------------------下面是一个常见安全陷阱和解决方案的列表，它可以辅助来确保你的Nginx部署是安全的。\r\n</p>\r\n<p>\r\n	1）禁用autoindex模块。这个可能在你使用的Nginx版本中已经更改了，如果没有的话只需在配置文件的location块中增加autoindex off;声明即可。\r\n</p>\r\n<p>\r\n	2）禁用服务器上的ssi (服务器端引用)。这个可以通过在location块中添加ssi off; 。\r\n</p>\r\n<p>\r\n	3）关闭服务器标记。如果开启的话（默认情况下）所有的错误页面都会显示服务器的版本和信息。将server_tokens off;声明添加到Nginx配置文件来解决这个问题。\r\n</p>\r\n<p>\r\n	4）在配置文件中设置自定义缓存以限制缓冲区溢出攻击的可能性。\r\n</p>\r\n<p>\r\n	client_body_buffer_size  1K;\r\n</p>\r\n<p>\r\n	client_header_buffer_size 1k;\r\n</p>\r\n<p>\r\n	client_max_body_size 1k;\r\n</p>\r\n<p>\r\n	large_client_header_buffers 2 1k;\r\n</p>\r\n<p>\r\n	5）将timeout设低来防止DOS攻击。所有这些声明都可以放到主配置文件中。\r\n</p>\r\n<p>\r\n	client_body_timeout   10;\r\n</p>\r\n<p>\r\n	client_header_timeout 10;\r\n</p>\r\n<p>\r\n	keepalive_timeout     65;\r\n</p>\r\n<p>\r\n	send_timeout          10;\r\n</p>\r\n<p>\r\n	6）限制用户连接数来预防DOS攻击。\r\n</p>\r\n<p>\r\n	limit_zone slimits $binary_remote_addr 5m;\r\n</p>\r\n<p>\r\n	limit_conn slimits 5;\r\n</p>\r\n<p>\r\n	7）试着避免使用HTTP认证。HTTP认证默认使用crypt，它的哈希并不安全。如果你要用的话就用MD5（这也不是个好选择但负载方面比crypt好） 。\r\n</p>','2017-07-31 17:16:48',1,2,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('311ce9c7-b1bc-44a5-a4cd-95e529c5a783','Nginx采用https加密访问后出现的问题','Nginx采用https加密访问后出现的问题','<p>\r\n	线上的一个网站运行了一段时间，应领导要求，将其访问方式更改为https加密方式。更改为https后，网站访问正常，但网站注册功能不能正常使用了！\r\n</p>\r\n<p>\r\n	经过排查，是nginx配置里结合php部分漏洞了一个参数（fastcgi_param&nbsp; HTTPS ）导致，添加上这个参数后，问题迎刃而解！nginx支持https的配置时，需要在php区域配置中添加FastCGI服务，否则https不支持php文件。\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {            root           /var/www/vhosts/fff/main;            fastcgi_pass   127.0.0.1:9000;            fastcgi_read_timeout 30;            fastcgi_index  fff.php;            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;            #include        fastcgi_params;            include        fastcgi.conf; fastcgi_param  HTTPS on; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【或者fastcgi_param HTTPS &nbsp; &nbsp; $https if_not_empty;&nbsp;】    }    }\r\n</p>\r\n<p>\r\n	*************************************************************************************************\r\n</p>\r\n<p>\r\n	如何开启 Nginx 的 SSL 或者 HTTPS呢？\r\n</p>\r\n<p>\r\n	大家有没有试过使用HTTPS登陆 phpmyadmin 的时候会自动返回“The plain HTTP request was sent to HTTPS port”？\r\n</p>\r\n<p>\r\n	这是个 fastcgi 的配置问题！\r\n</p>\r\n<p>\r\n	解决方法：\r\n</p>\r\n<p>\r\n	location ~ .*\\.(php|php5)?${    try_files $uri =404;    fastcgi_pass  unix:/tmp/php-cgi.sock; fastcgi_param HTTPS &nbsp; &nbsp; $https if_not_empty;    fastcgi_index index.php;    include fcgi.conf;}\r\n</p>\r\n<p>\r\n	解释：\r\n</p>\r\n<p>\r\n	很多人认为使用 fastcgi_param HTTPS on;，这样是没错啦，不过强迫使用这个参数，可能不太有效！\r\n</p>\r\n<p>\r\n	最好的答案是上面的配置（参考下面 nginx 官方的链接）\r\n</p>\r\n<p>\r\n	fastcgi_param HTTPS $https if_not_empty;\r\n</p>\r\n<p>\r\n	有 https 协议时才自动使用 https on，否则忽略这个参数。\r\n</p>\r\n<p>\r\n	内嵌的变量：\r\n</p>\r\n<p>\r\n	$https – 如果链接是 SSL 就返回 “ON”，否则返回空字符串。\r\n</p>\r\n<p>\r\n	if_not_empty; – 当参数有值时才传递到服务器\r\n</p>\r\n<p>\r\n	注意：这个 if_not_empty 额外参数只适合 Nginx 1.1.11 之后的版本\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('34172740-c531-483c-9955-3283b48597c8','Tornado框架自定义404页面','Tornado框架自定义404页面','自己用Tornado框架开发写了一个博客，想自定义一下404页面，网上找了一些资料，大致有以下几种思路，仅供参考<br />\r\n刚开始找网上找资料 大致说的都是重写RequestHandler的write_error方法，但不生效于是注释掉了，代码如下：<br />\r\n&nbsp;class BaseHandler(tornado.web.RequestHandler,SessionMixin):<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; *RequestHandler SessionMixin基类*<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; def get_current_user(self):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; user=self.session.get(\"username\",None)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; user_obj=DBHandler(User,User.name).query(user)[0] if user else None<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; return user_obj if user_obj else None<br />\r\n<br />\r\n&nbsp; &nbsp;# def write_error(self, status_code, **kwargs):<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; if status_code == 404:<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; self.render(\'404.html\')<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; elif status_code == 500:<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; self.render(\'500.html\')<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; else:<br />\r\n&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; super(BaseHandler, self).write_error(status_code, **kwargs)<br />\r\n<br />\r\n&nbsp; &nbsp; def on_finish(self):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; DBsession.close()<br />\r\n于是查看了RequestHandler的write_error源代码，发现可以直接修改源代码，如下：<br />\r\ndef write_error(self, status_code, **kwargs):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"Override to implement custom error pages.<br />\r\n<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; ``write_error`` may call `write`, `render`, `set_header`, etc<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; to produce output as usual.<br />\r\n<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; If this error was caused by an uncaught exception (including<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; HTTPError), an ``exc_info`` triple will be available as<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; ``kwargs[\"exc_info\"]``. &nbsp;Note that this exception may not be<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; the \"current\" exception for purposes of methods like<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; ``sys.exc_info()`` or ``traceback.format_exc``.<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # in debug mode, try to send a traceback<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.set_header(\'Content-Type\', \'text/plain\')<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for line in traceback.format_exception(*kwargs[\"exc_info\"]):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.write(line)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.finish()<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.render(\"%s.html\"%(status_code))<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except IOError:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.finish(\"&lt;html&gt;&lt;title&gt;%(code)d: %(message)s&lt;/title&gt;\"<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"&lt;body&gt;%(code)d: %(message)s&lt;/body&gt;&lt;/html&gt;\" % {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"code\": status_code,<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"message\": self._reason,<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })<br />\r\n<br />\r\ntry: self.render(\"%s.html\"%(status_code)) except IOError::这三行我是手动修改添加，这样有点投机了，不知后期有没有什么影响<br />\r\n<br />\r\n第二种是在urls.py里最后添加一个(r\'/*\', NotFoundHandler),这种方法没试过<br />\r\nclass NotFoundHandler(BaseHandler):<br />\r\n&nbsp; &nbsp; def get(self):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; self.write_error(404)<br />\r\n&nbsp; &nbsp; def write_error(self, status_code, **kwargs):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if status_code == 404:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.render(\'public/404.html\')<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; elif status_code == 500:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.render(\'public/500.html\')<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.write(\'error:\' + str(status_code))<br />','2017-08-01 10:55:29',2,7,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('358afe84-a3a4-4d1c-90b4-3ab10257d907','分享一例测试环境下nginx+tomcat的视频业务部署记录','分享一例测试环境下nginx+tomcat的视频业务部署记录','<p>\r\n	需求说明：在测试环境下(192.168.1.28)部署一套公司某业务环境，其中：该业务前台访问地址：&nbsp;http://testhehe.wangshibo.com该业务后台访问地址： http://testhehe.wangshibo.com/admin/\r\n</p>\r\n<p>\r\n	涉及到视频读写需求，要求视频在测试机上写入，然后在另一台图片服务器(192.168.1.6)上读，这就需要做nfs共享。需要给开发同事提供视频写入和读取的url地址：视频写地址：http://testhehe.wangshibo/static/video视频读地址：http://static.wangshibo.com/video\r\n</p>\r\n<p>\r\n	部署记录：一、测试机上的操作\r\n</p>\r\n<p>\r\n	（1）nginx的配置[root@dev-test ~]#  cat testhehe.wangshibo.com.conf server {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen       80;\r\n</p>\r\n<p>\r\n	server_name  testhehe.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /var/log/testhehe.log  main;\r\n</p>\r\n<p>\r\n	location   / {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8383; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#前台访问&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_connect_timeout   30;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_send_timeout      60;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_read_timeout      60;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header REMOTE-HOST $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header Host $host;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	location   /admin {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_pass http://127.0.0.1:8484/; &nbsp; #后台访问跳转（注意这里8484后面的斜杠/要加上，不然访问跳转会有问题，8484端口的tomcat目录下不需要有admin实际目录存在）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_connect_timeout   30;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_send_timeout      60;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_read_timeout      60;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header REMOTE-HOST $remote_addr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header Host $host;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	location   /static/video { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #视频写地址，这里不需要另启tomcat进程进行nginx跳转设置(没有war包数据),直接nginx设置访问地址即可&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root  /Data/app/tomcat-7-hehe/static/video;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	} ##end server\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动nginx[root@dev-test ~]# /Data/app/nginx/sbin/nginx -t[root@dev-test ~]# /Data/app/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	以上nginx的配置说明：1）该业务前台http://testhehe.wangshibo.com访问转向8383端口的tomcat，代码放到/Data/app/tomcat-7-hehe/webapp目录下2) 该业务后台http://testhehe.wangshibo.com/admin/访问转向8484端口的tomcat，代码放到/Data/app/tomcat-7-admin-hehe/webapp目录下3）视频写入的地址是：http://testhehe.wangshibo.com/static/video，根目录为/Data/app/tomcat-7-hehe/static/video，由于tomcat和nginx进程权限不一样，最好将此目录设置成777权限。\r\n</p>\r\n<p>\r\n	[root@dev-test ~]# chmod -R 777&nbsp;/Data/app/tomcat-7-hehe/static/video\r\n</p>\r\n<p>\r\n	（2）tomcat设置\r\n</p>\r\n<p>\r\n	1）前台访问跳转的tomcat设置(8383端口)[root@dev-test ~]#  cd /Data/app/tomcat-7-hehe/conf/[root@dev-test conf]# cat server.xml............................\r\n</p>\r\n<p>\r\n	注意：tomcat默认的根目录是webapps/ROOT,所以现将webapps目录下默认的文件都删除[root@dev-test webapps]# pwd/Data/app/tomcat-7-hehe/webapps[root@dev-test webapps]# rm -rf ./*\r\n</p>\r\n<p>\r\n	将前台代码的war包拷贝到webapps下，war包名称最好是ROOT.war，如果不是这个名称，可以手动将war包改成这个ROOT.war名称.这样访问的时候就直接使用tomcat的默认目录了，比如&nbsp;http://127.0.0.1:8383;（当然如果不改成ROOT.war也无妨，比如war包名叫hehe.war，需要提前将webapps目录清空，那么tomcat启动后，访问就是http://127.0.0.1:8383/hehe,这样在nginx反向代理里的proxy_pass配置也要改成proxy_pass http://127.0.0.1:8383/hehe;&nbsp;）例如开发提供的业务代码war包名称是hehe.war，将其上传到webapp下，并更名为ROOT.war[root@dev-test webapp]# ll hehe.war-rw-r--r-- 1 root root 52673678 11月 21 17:40 hehe.war[root@dev-test webapp]# mv hehe.war ROOT.war &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;[root@dev-test webapp]# ll -rw-r--r--  1 root root 124491469 11月 22 17:59 ROOT.war\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------------------------------------------这里注意一下：tomcat默认的根目录是webapp/ROOT，为了方便tomcat访问时采用默认目录（并且前端nginx反向代理里直接是转到tomcat默认的端口访问上），所以需要将业务代码war包改成ROOT.war放到webapp下，如果war包名不是ROOT.war，那么重启tomcat后，访问会失败（404页面）。-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	接着启动8383端口的tomcat进程，这个ROOT.war包就会自动解压[root@dev-test webapps]# ../bin/startup.shUsing CATALINA_BASE:   /Data/app/tomcat-7-heheUsing CATALINA_HOME:   /Data/app/tomcat-7-heheUsing CATALINA_TMPDIR: /Data/app/tomcat-7-heheUsing JRE_HOME:        /usr/java/jdk1.7.0_79Using CLASSPATH:       /Data/app/tomcat-7-hehe/bin/bootstrap.jar:/Data/app/tomcat-7-hehe/bin/tomcat-juli.jarTomcat started.\r\n</p>\r\n<p>\r\n	[root@dev-test webapps]# ll总用量 121580drwxr-xr-x 10 root root      4096 11月 22 17:57 ROOT-rw-r--r--  1 root root 124491469 11月 22 17:59 ROOT.war\r\n</p>\r\n<p>\r\n	[root@dev-test webapps]# lsof -i:8383COMMAND   PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAMEjava    26155 root   43u  IPv6 214715915      0t0  TCP *:m2mservices (LISTEN)\r\n</p>\r\n<p>\r\n	由于业务代码每次发版都需要重启tomcat，而tomcat没有自带的重启脚本，重启需要先kill，然后start启动，这样很不方面。这里分享一个简单的发版后的tomcat重启脚本：[root@dev-test tomcat-7-hehe]# pwd/Data/app/tomcat-7-hehe[root@dev-test tomcat-7-hehe]# cat start.sh #!/bin/bash\r\n</p>\r\n<p>\r\n	cd /Data/app/tomcat-7-hehe/#pkill -9 javakill -9 `ps -ef|grep java|grep -v grep|grep tomcat-7-hehe |awk -F\" \" \'{print $2}\'`rm -rf temp/*rm -rf work/*rm -rf webapps/ROOT\r\n</p>\r\n<p>\r\n	sh bin/startup.sh\r\n</p>\r\n<p>\r\n	2）同理，设置后台访问跳转的tomcat设置(8484端口)[root@dev-test ~]#  cd /Data/app/tomcat-7-admin-hehe/conf[root@dev-test conf]# cat server.xml............................\r\n</p>\r\n<p>\r\n	注意：tomcat默认的根目录是webapps/ROOT,所以现将webapps目录下默认的文件都删除[root@dev-test webapps]# pwd/Data/app/tomcat-7-admin-hehe/webapps[root@dev-test webapps]# rm -rf ./*\r\n</p>\r\n<p>\r\n	然后将前台代码的war包拷贝到webapps下，war包名称最好是ROOT.war，如果不是这个名称，就手动改成这个ROOT.war名称.[root@dev-test webapps]# ll总用量 121580-rw-r--r--  1 root root 124491469 11月 22 17:59 ROOT.war\r\n</p>\r\n<p>\r\n	接着启动8383端口的tomcat进程，这个ROOT.war包就会自动解压[root@dev-test webapps]# ../bin/startup.shUsing CATALINA_BASE:   /Data/app/tomcat-7-admin-heheUsing CATALINA_HOME:   /Data/app/tomcat-7-admin-heheUsing CATALINA_TMPDIR: /Data/app/tomcat-7-admin-heheUsing JRE_HOME:        /usr/java/jdk1.7.0_79Using CLASSPATH:       /Data/app/tomcat-7-admin-hehe/bin/bootstrap.jar:/Data/app/tomcat-7-admin-hehe/bin/tomcat-juli.jarTomcat started.\r\n</p>\r\n<p>\r\n	[root@dev-test webapps]# ll总用量 121580drwxr-xr-x 10 root root      4096 11月 22 17:57 ROOT-rw-r--r--  1 root root 124491469 11月 22 17:59 ROOT.war\r\n</p>\r\n<p>\r\n	[root@dev-test webapps]# lsof -i:8383COMMAND   PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAMEjava    26155 root   43u  IPv6 214715915      0t0  TCP *:m2mservices (LISTEN)\r\n</p>\r\n<p>\r\n	由于业务代码每次发版都需要重启tomcat，而tomcat没有自带的重启脚本，重启需要先kill，然后start启动，这样很不方面。这里分享一个简单的发版后的tomcat重启脚本：[root@dev-test tomcat-7-admin-hehe]# pwd/Data/app/tomcat-7-admin-hehe[root@dev-test tomcat-7-admin-hehe]# cat start.sh #!/bin/bash\r\n</p>\r\n<p>\r\n	cd /Data/app/tomcat-7-admin-hehe/#pkill -9 javakill -9 `ps -ef|grep java|grep -v grep|grep tomcat-7-admin-hehe |awk -F\" \" \'{print $2}\'`rm -rf temp/*rm -rf work/*rm -rf webapps/ROOT\r\n</p>\r\n<p>\r\n	sh bin/startup.sh\r\n</p>\r\n<p>\r\n	接着说下挂载nfs共享：即将视频写入到本机的/Data/app/tomcat-7-hehe/static/video目录下(写地址是http://testhehe.wangshibo/static/video)，然后共享给图片服务器192.168.1.6的/usr/local/nginx/html/hehe/video[root@dev-test webapp]# /bin/mount -t nfs 192.168.1.6:/usr/local/nginx/html/hehe/video /Data/app/tomcat-7-hehe/static/video[root@dev-test webapp]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup-lv_root 50G 12G 36G 26% /tmpfs 32G 72K 32G 1% /dev/shm/dev/sda1 485M 39M 421M 9% /boot/dev/mapper/VolGroup-lv_home 844G 69G 732G 9% /home192.168.1.6:/usr/local/nginx/html/hehe/video 97G 64G 28G 70% /home/Data/app/tomcat-7-hehe/static/video\r\n</p>\r\n<p>\r\n	设置开机挂载[root@dev-test webapp]# cat /etc/rc.local....../bin/mount -t nfs 192.168.1.6:/usr/local/nginx/html/hehe/video /Data/app/tomcat-7-hehe/static/video\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	nfs的部署参考：nfs服务部署记录\r\n</p>\r\n<p>\r\n	二、图片服务器上的操作（1）nginx的配置\r\n</p>\r\n<p>\r\n	[root@static ~]# cat /usr/loca/nginx/conf/vhost/static.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen  80;\r\n</p>\r\n<p>\r\n	server_name  static.wangshibo.com;\r\n</p>\r\n<p>\r\n	root   /usr/local/nginx/html/hehe;\r\n</p>\r\n<p>\r\n	error_page 403 /403.html;\r\n</p>\r\n<p>\r\n	location = /403.html {\r\n</p>\r\n<p>\r\n	root   html;\r\n</p>\r\n<p>\r\n	allow all;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ \\.mp4(.*)$  {                   #针对mp4格式的视频读取限制\r\n</p>\r\n<p>\r\n	mp4;\r\n</p>\r\n<p>\r\n	mp4_buffer_size 4M;\r\n</p>\r\n<p>\r\n	mp4_max_buffer_size 10M;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@static ~]# /usr/loca/nginx/sbin/nginx -t\r\n</p>\r\n<p>\r\n	[root@static ~]# /usr/loca/nginx/sbin/nginx\r\n</p>\r\n<p>\r\n	[root@static ~]# mkdir /usr/local/nginx/html/hehe/video\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------下面随便说下该业务前后台代码发版脚本：\r\n</p>\r\n<p>\r\n	脚本在svn机器上：[root@svn-server ~]# pwd/Data/webroot_svncode/wangshibo\r\n</p>\r\n<p>\r\n	前台代码发版脚本[root@svn-server ~]# cat up_pub_test_wangshibo.sh #!/bin/bashREMOTE_SERVER_IP=\"192.168.1.28\" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #测试服务器，ssh端口是25791DEST_DIR=\"/Data/app/tomcat-7-hehe/webapps\"cd /Data/webroot_svncode/wangshibo/test/front &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#在svn本机下载前台代码的存放路径，第一次svn下载需要用户名和密码，后面就只需要update更新代码即可\r\n</p>\r\n<p>\r\n	/usr/bin/svn update\r\n</p>\r\n<p>\r\n	/usr/bin/ssh -p25791 ${REMOTE_SERVER_IP} \"rm -rf /Data/app/tomcat-7-hehe/webapps/ROOT*\"; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #svn里面的war包名次是ROOT.war，具体理由上面已说明 /usr/bin/rsync -av -e \"/usr/bin/ssh -p25791\" --rsync-path=\"/usr/bin/rsync\" --progress /Data/webroot_svncode/wangshibo/test/front/ROOT.war ${REMOTE_SERVER_IP}:${DEST_DIR};sleep 10\r\n</p>\r\n<p>\r\n	/usr/bin/ssh -p25791 ${REMOTE_SERVER_IP} \"/bin/sh /Data/app/tomcat-7-hehe/start.sh\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	后台代码发版脚本[root@svn-server ~]# cat up_pub_testadmin_wangshibo.sh #!/bin/bashREMOTE_SERVER_IP=\"192.168.1.28\"DEST_DIR=\"/Data/app/tomcat-7-admin-hehe/webapps\"cd /Data/webroot_svncode/wangshibo/test/bg\r\n</p>\r\n<p>\r\n	/usr/bin/svn update\r\n</p>\r\n<p>\r\n	/usr/bin/ssh -p25791 ${REMOTE_SERVER_IP} \"rm -rf /Data/app/tomcat-7-admin-hehe/webapps/ROOT*\";/usr/bin/rsync -av -e \"/usr/bin/ssh -p25791\" --rsync-path=\"/usr/bin/rsync\" --progress /Data/webroot_svncode/wangshibo/test/bg/ROOT.war ${REMOTE_SERVER_IP}:${DEST_DIR};sleep 10\r\n</p>\r\n<p>\r\n	/usr/bin/ssh -p25791 ${REMOTE_SERVER_IP} \"/bin/sh /Data/app/tomcat-7-admin-hehe/start.sh\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('37fca21a-b447-4151-849e-6c530c5307d3','mysql操作命令梳理（2）-alter（update、insert）','mysql操作命令梳理（2）-alter（update、insert）','<p>\r\n	在mysql运维操作中会经常使用到alter这个修改表的命令，alter tables允许修改一个现有表的结构，比如增加或删除列、创造或消去索引、改变现有列的类型、或重新命名列或表本身，也能改变表的注释和表的类型。下面就针对alter修改命令的使用做一梳理：\r\n</p>\r\n<p>\r\n	在mysql运维操作中会经常使用到alter这个修改表的命令，alter tables允许修改一个现有表的结构，比如增加或删除列、创造或消去索引、改变现有列的类型、或重新命名列或表本身，也能改变表的注释和表的类型。下面就针对alter修改命令的使用做一梳理：\r\n</p>\r\n<p>\r\n	1）删除列alter table 表名 DROP 列名; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //或者&nbsp; alter table 表名 drop column 列名;-------------------------------------------------------------------------------------drop database 库名; &nbsp; &nbsp; &nbsp;//删除库drop table 表名; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //删除表delete from 表名; &nbsp; &nbsp; &nbsp; &nbsp; //清空表中所有数据，但这张表没有删除，保留的是空表。delete from 表名 where ...; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//删除表中字段------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）增加列alter table 表名 ADD 列名 列的属性(如INT NOT NULL  COMMENT \'注释说明\')\r\n</p>\r\n<p>\r\n	3）修改列的类型信息。alter table 表名 CHANGE 列名 新列名 新列属性; &nbsp;alter table 表名 CHANGE 列名 新列名(这里可以用和原来列同名即可) BIGINT NOT NULL  COMMENT \'注释说明\'\r\n</p>\r\n<p>\r\n	4）重命名列alter table 表名 CHANGE 列名 新列名 BIGINT NOT NULL  COMMENT \'注释说明\'\r\n</p>\r\n<p>\r\n	5）重命名表alter table 表名 RENAME 表新名\r\n</p>\r\n<p>\r\n	6）删除表中主键alter table 表名 drop primary key-------------------------------------------------------------------------------------如若删除带自增属性的主键，那么要先删除自增长，再删除主键Alter table haha change id id int(10); &nbsp; &nbsp; &nbsp; &nbsp;//删除自增长Alter table haha drop primary key; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //删除主建-------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	7）添加主键alter table 表名 ADD CONSTRAINT PK_表名 PRIMARY KEY(列名1,列名2)-------------------------------------------------------------------------------------Alter table haha add primary key(id); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //将haha表的id列添加主键Alter table haha change id id int(10) not null auto_increment; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//自增长属性-------------------------------------------------------------------------------------sql中constraint前缀的用意（PK、UK、DF、CK、FK）--主键constraint PK_字段 primary key(字段),--唯一约束constraint UK_字段 unique key(字段),--默认约束constrint DF_字段 default(\'默认值\') for 字段,--检查约束constraint CK_字段 check(约束。如：len(字段)&gt;1),--主外键关系constraint FK_主表_从表 foreign(外键字段) references 主表(主表主键字段)-------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	8）添加/创建索引alter table 表名 add index 索引名 列名; &nbsp; &nbsp; &nbsp; &nbsp; //普通索引ALTER TABLE 表名 ADD UNIQUE index 索引名 (列名1，列名2); &nbsp; &nbsp; &nbsp; &nbsp; //联合索引ALTER TABLE 表名 ADD PRIMARY index KEY 索引名 列名; &nbsp; &nbsp; &nbsp; &nbsp; //主键索引-------------------------------------------------------------------------------------SHOW INDEX FROM 表名字; &nbsp; &nbsp; &nbsp; //查询索引\r\n</p>\r\n<p>\r\n	删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理DROP index 索引名 ON 表名字 列名; &nbsp; &nbsp; &nbsp; //删除普通索引ALTER TABLE 表名 DROP INDEX 索引名 列名; &nbsp; &nbsp; &nbsp; //删除普通索引ALTER TABLE 表名 DROP UNIQUE 索引名 (列名1,列名2); &nbsp; &nbsp; //删除联合索引ALTER TABLE 表名 DROP PRIMARY KEY 索引名 列名; &nbsp; &nbsp; &nbsp;//删除主键索引-------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	9）添加唯一限制条件索引alter table 表名 add unique emp_name2(cardnumber); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //empname 类型 为String 字符串类型\r\n</p>\r\n<p>\r\n	10）创建联合唯一索引alter table 表名 ADD UNIQUE INDEX 索引名 (列名1，列名2);alter ignore table 表名 add unique index(user_id,user_name); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//它会删除重复的记录（别怕，会保留一条），然后建立唯一索引，高效而且人性化.(慎用)\r\n</p>\r\n<p>\r\n	11）修改字段属性alter table 表名 modify column 字段名 类型alter table 表名 modify column 字段1 类型，字段2 类型例如：将class表的name列属性改成varchar(100)alter table class modify column name varchar(100);或者：alter table 表名 change 列名 列名 varchar(100);alter table class change name name varchar(100);\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------------------------------上面提到了使用alter命令修改表名，修改列名；那么修改字段值，就需要使用update命令，如下：\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	| 11 | ouou      |\r\n</p>\r\n<p>\r\n	| 19 | hahahahha |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; update huanqiu.haha set name=\"wangshikui\" where id=11;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| id | name       |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo  |\r\n</p>\r\n<p>\r\n	| 11 | wangshikui |\r\n</p>\r\n<p>\r\n	| 19 | hahahahha  |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	修改root登陆密码：\r\n</p>\r\n<p>\r\n	mysql&gt; update mysql.user set password=password(\"654321\") where host=\'192.168.1.101\' and user=\"root\";\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	update 表名 set 列名=\"新的字段值\" [where 限制条件1 and 限制条件1]；update 表名 set 列名1=\"新的字段值\",列名2=\"新的字段值\" [where 限制条件1 and 限制条件1] [ORDER BY ...] [LIMIT row_count]；\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	insert into 表名 values(所有字段的插入值);insert into 表名(指定字段) values(指定字段);insert into 表名 values(所有字段的插入值),(所有字段的插入值),(所有字段的插入值); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//批量插入\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| id | name       |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| 11 | wangshikui |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiu.haha values(1,\"wangshibo\"),(2,\"wangshikui\"),(3,\"wangjuan\"),(4,\"wangman\");\r\n</p>\r\n<p>\r\n	Query OK, 4 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	Records: 4  Duplicates: 0  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| id | name       |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo  |\r\n</p>\r\n<p>\r\n	|  2 | wangshikui |\r\n</p>\r\n<p>\r\n	|  3 | wangjuan   |\r\n</p>\r\n<p>\r\n	|  4 | wangman    |\r\n</p>\r\n<p>\r\n	| 11 | wangshikui |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------------------------------创建表时指定AUTO_INCREMENT自增值的初始值:\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE TABLE 表名 (ID INT(5) PRIMARY KEY AUTO_INCREMENT)AUTO_INCREMENT=100;\r\n</p>\r\n<p>\r\n	通过ALTER TABLE 修改初始值(但要大于表中的AUTO_INCREMENT自增值，否则设置无效):\r\n</p>\r\n<p>\r\n	mysql&gt;ATLER TABLE 表名 AUTO_INCREMENT=100;\r\n</p>\r\n<p>\r\n	如果自增序列的最大值被删除了，则在插入新记录时，该值被重用。就是说如果表中原本有AUTO_INCREMENT属性值连续为78、100的值，但100这个数据被删除了，下此再添加数据的时候自增值为101,100被重用了。即使在你将整个表中的所有数据delete清空后，之前的自增序列最大值还是会被重用。解决办法是使用下面命令：\r\n</p>\r\n<p>\r\n	ATLER TABLE 表名 AUTO_INCREMENT=0;         //重新设置自增初始值\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------------------------设置AUTO_INCREMENT_INCREMENT以及AUTO_INCREMENT_offset用户变量值(重启MySQL之后，这些修改会恢复为初始值1)：\r\n</p>\r\n<p>\r\n	mysql&gt;SET auto_increment_increment=10;     //自增量每次增加的值改为10，\r\n</p>\r\n<p>\r\n	mysql&gt;SET auto_increment_offset=2;        //第一次加载数值时的偏移值的个位值\r\n</p>\r\n<p>\r\n	mysql&gt;SHOW VARIABLES LIKE \'AUTO_INC%\';      //查看修改后变量的值\r\n</p>\r\n<p>\r\n	mysql&gt;SHOW TABLE STATUS FROM NAME_DB;      //显示数据库NAME_DB中所有表的信息\r\n</p>\r\n<p>\r\n	mysql&gt;SHOW CREATE TABLE NAME_TBL;       //显示表NAME_TBL创建时的信息\r\n</p>\r\n<p>\r\n	mysql&gt;SHOW VARIABLES LIKE \'AUTO_INC%\';      //显示MySQL的AUTO_INC开头的用户会话变量(SHOW GLOBAL VARIABLES)\r\n</p>\r\n<p>\r\n	+--------------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name | Value |\r\n</p>\r\n<p>\r\n	+--------------------------+-------+\r\n</p>\r\n<p>\r\n	| auto_increment_increment | 1 |\r\n</p>\r\n<p>\r\n	| auto_increment_offset | 1 |\r\n</p>\r\n<p>\r\n	+--------------------------+-------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('399eaec8-78d3-4146-b1ad-b5febfe50e9c','centos 6x系统下源码安装mysql操作记录','centos 6x系统下源码安装mysql操作记录','<p>\r\n	在运维工作中经常部署各种运维环境，涉及mysql数据库的安装也是时常需要的。mysql数据库安装可以选择yum在线安装，但是这种安装的mysql一般是系统自带的，版本方面可能跟需求不太匹配。可以通过源码安装的方式，自定义安装自己所需版本的mysql。---------------------------------------------------------------------------------------------------------------------------------mysql数据库yum在线安装：[root@host-test-huanqiu ~]# yum -y install mysql mysql-server[root@host-test-huanqiu ~]# /etc/init.d/mysqld start[root@host-test-huanqiu ~]# mysqladmin password \"123456\"[root@host-test-huanqiu ~]# mysql -p123456mysql&gt; select version();+-----------+| version() |+-----------+| 5.1.73    |+-----------+1 row in set (0.00 sec---------------------------------------------------------------------------------------------------------------------------------废话不多说，以下是centos6x系统下源码安装Mysql的操作记录，方便参考~\r\n</p>\r\n<p>\r\n	1、卸载旧版本[root@host-test-huanqiu ~]# rpm -qa | grep mysqlmysql-5.1.73-7.el6.x86_64mysql-libs-5.1.73-7.el6.x86_64mysql-server-5.1.73-7.el6.x86_64\r\n</p>\r\n<p>\r\n	#普通删除模式[root@host-test-huanqiu ~]# rpm -e mysql-5.1.73-7.el6.x86_64  mysql-libs-5.1.73-7.el6.x86_64 mysql-server-5.1.73-7.el6.x86_64 # 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除    [root@host-test-huanqiu ~]# rpm -e --nodeps mysql-5.1.73-7.el6.x86_64  mysql-libs-5.1.73-7.el6.x86_64 mysql-server-5.1.73-7.el6.x86_64\r\n</p>\r\n<p>\r\n	#删除/etc/my.cnf [root@host-test-huanqiu ~]# rm /etc/my.cnf\r\n</p>\r\n<p>\r\n	2、安装编译代码需要的包[root@host-test-huanqiu ~]# yum -y install make gcc-c++ cmake bison-devel ncurses-devel\r\n</p>\r\n<p>\r\n	3、创建mysql用户，不建立mysql用户家目录（加-M参数），也就是禁用mysql账号登陆系统 [root@host-test-huanqiu ~]# groupadd mysql [root@host-test-huanqiu ~]# useradd -g mysql mysql -M -s /sbin/nologin\r\n</p>\r\n<p>\r\n	4、下载MySQL，源码编译安装\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu ~]# cd /usr/local/src\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu src]# wget -c http://ftp.ntu.edu.tw/MySQL/Downloads/MySQL-5.6/mysql-5.6.34.tar.gz\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu src]# tar -zxvf mysql-5.6.34.tar.gz\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu src]# cd mysql-5.6.34/\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	5、配置MySQL\r\n</p>\r\n<p>\r\n	修改/usr/local/mysql权限\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# mkdir -p /data/mysql/data\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# chown -R mysql:mysql /usr/local/mysql\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# chown -R mysql:mysql /data/mysql/data\r\n</p>\r\n<p>\r\n	执行初始化配置脚本，创建系统自带的数据库和表\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql-5.6.34]# cd /usr/local/mysql\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# ./scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/data/mysql/data --user=mysql   //如果后续不小心删除了这个数据目录或这个目录下的文件被误操作删除了，还可以利用这个命令重新初始化\r\n</p>\r\n<p>\r\n	需要特别注意：在启动MySQL服务时，会按照一定次序搜索my.cnf，先在/etc目录下找，找不到则会搜索\"$basedir/my.cnf\"，在本例中就是 /usr/local/mysql/my.cnf，这是新版MySQL的配置文件的默认位置！\r\n</p>\r\n<p>\r\n	另外：在CentOS 6.4版操作系统最小安装完成后，默认会在/etc目录下存在一个my.cnf，需要将此文件更名为其他的名字，如：/etc/my.cnf.bak，否则，该文件会干扰源码安装的MySQL的正确配置，造成无法启动。在使用\"yum update\"更新系统后，需要检查下/etc目录下是否会多出一个my.cnf，如果多出，将它重命名成别的。否则，MySQL将使用这个配置文件启动，可能造成无法正常启动等问题。--------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	启动MySQL添加服务，拷贝服务脚本到init.d目录，并设置开机启动[root@host-test-huanqiu mysql]# cp support-files/mysql.server /etc/init.d/mysql[root@host-test-huanqiu mysql]# chkconfig mysql on[root@host-test-huanqiu mysql]# service mysql start &nbsp; //启动前，要先配置my.cnf文件（如下）， 并确保/data/mysql/data和/usr/local/mysql的mysql权限\r\n</p>\r\n<p>\r\n	如果启动报错：\r\n</p>\r\n<p>\r\n	[root@slave-server mysql]# service mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.Logging to \'/data/mysql/data/mysql-error.log\'.\r\n</p>\r\n<p>\r\n	170416 12:55:28 mysqld_safe Directory \'/usr/local/mysql/var\' for UNIX socket file don\'t exists.\r\n</p>\r\n<p>\r\n	ERROR! The server quit without updating PID file (/data/mysql/data/mysql.pid).\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	[root@slave-server mysql]# mkdir ／usr/local/mysql/var\r\n</p>\r\n<p>\r\n	[root@slave-server mysql]# chown -R mysql:mysql /usr/local/mysql\r\n</p>\r\n<p>\r\n	[root@slave-server mysql]# service mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	配置用户和环境变量\r\n</p>\r\n<p>\r\n	MySQL启动成功后，root默认没有密码，需要设置root密码，设置之前，需要先设置PATH，否则不能直接调用mysql\r\n</p>\r\n<p>\r\n	修改/etc/profile文件，在文件末尾添加\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# vim /etc/profile\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	export PATH=$PATH:/usr/local/mysql/bin\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# source /etc/profile\r\n</p>\r\n<p>\r\n	到此，就可以直接mysql登陆了\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# mysql -uroot\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	mysql&gt; select version();\r\n</p>\r\n<p>\r\n	+-----------+\r\n</p>\r\n<p>\r\n	| version() |\r\n</p>\r\n<p>\r\n	+-----------+\r\n</p>\r\n<p>\r\n	| 5.6.33 |\r\n</p>\r\n<p>\r\n	+-----------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	登陆mysql，若是报错如下：\r\n</p>\r\n<p>\r\n	[root@test2-235 mysql]# mysql\r\n</p>\r\n<p>\r\n	ERROR 2002 (HY000): Can\'t connect to local MySQL server through socket \'/var/lib/mysql/mysql.sock\' (2)\r\n</p>\r\n<p>\r\n	解决办法\r\n</p>\r\n<p>\r\n	[root@test2-235 mysql]# mkdir /var/lib/mysql/\r\n</p>\r\n<p>\r\n	[root@test2-235 mysql]# ln -s /usr/local/mysql/var/mysql.sock /var/lib/mysql/mysql.sock\r\n</p>\r\n<p>\r\n	修改root密码，执行命令如下\r\n</p>\r\n<p>\r\n	mysql&gt; SET PASSWORD = PASSWORD(\'123456\');\r\n</p>\r\n<p>\r\n	若要设置root用户可以远程访问，执行\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'password\' WITH GRANT OPTION;\r\n</p>\r\n<p>\r\n	使授权立即生效\r\n</p>\r\n<p>\r\n	mysql&gt; FLUSH PRIVILEGES;\r\n</p>\r\n<p>\r\n	也可以使用mysqladmin命令设置mysql密码\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# mysqladmin password 123456 #安装mysql后第一次设置密码\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# mysqladmin -p 旧密码 password 新密码 #重置密码\r\n</p>\r\n<p>\r\n	最后配置防火墙\r\n</p>\r\n<p>\r\n	默认防火墙的3306端口默认没有开启，若要远程访问，需要开启这个端口.也可以做下白名单，比如只允许192.168.1.0/24网段的客户机访问本机的mysql。\r\n</p>\r\n<p>\r\n	[root@host-test-huanqiu mysql]# vim /etc/sysconfig/iptables\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	-A INPUT -s 192.168.1.0/24 -p tcp -m tcp -m state --state NEW -dport 3306 -j ACCEPT\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------------------------------下面贴下mysql6.x的my.cnf配置\r\n</p>\r\n<p>\r\n	[client]\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	[mysqld]\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	basedir = /usr/local/mysql/\r\n</p>\r\n<p>\r\n	datadir = /data/mysql/data\r\n</p>\r\n<p>\r\n	pid-file = /data/mysql/data/mysql.pid\r\n</p>\r\n<p>\r\n	user = mysql\r\n</p>\r\n<p>\r\n	bind-address = 0.0.0.0\r\n</p>\r\n<p>\r\n	server-id = 1\r\n</p>\r\n<p>\r\n	sync_binlog=1\r\n</p>\r\n<p>\r\n	log_bin = mysql-bin\r\n</p>\r\n<p>\r\n	skip-name-resolve\r\n</p>\r\n<p>\r\n	back_log = 600\r\n</p>\r\n<p>\r\n	max_connections = 3000\r\n</p>\r\n<p>\r\n	max_connect_errors = 3000\r\n</p>\r\n<p>\r\n	table_open_cache = 512\r\n</p>\r\n<p>\r\n	max_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	binlog_cache_size = 16M\r\n</p>\r\n<p>\r\n	max_heap_table_size = 16M\r\n</p>\r\n<p>\r\n	tmp_table_size = 256M\r\n</p>\r\n<p>\r\n	read_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	read_rnd_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	sort_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	join_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	key_buffer_size = 8192M\r\n</p>\r\n<p>\r\n	thread_cache_size = 8\r\n</p>\r\n<p>\r\n	query_cache_size = 512M\r\n</p>\r\n<p>\r\n	query_cache_limit = 1024M\r\n</p>\r\n<p>\r\n	ft_min_word_len = 4\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	expire_logs_days = 30\r\n</p>\r\n<p>\r\n	log_error = /data/mysql/data/mysql-error.log\r\n</p>\r\n<p>\r\n	slow_query_log = 1\r\n</p>\r\n<p>\r\n	long_query_time = 1\r\n</p>\r\n<p>\r\n	slow_query_log_file = /data/mysql/data/mysql-slow.log\r\n</p>\r\n<p>\r\n	performance_schema = 0\r\n</p>\r\n<p>\r\n	explicit_defaults_for_timestamp\r\n</p>\r\n<p>\r\n	skip-external-locking\r\n</p>\r\n<p>\r\n	default_storage_engine = InnoDB\r\n</p>\r\n<p>\r\n	innodb_file_per_table = 1\r\n</p>\r\n<p>\r\n	innodb_open_files = 500\r\n</p>\r\n<p>\r\n	innodb_buffer_pool_size = 1024M\r\n</p>\r\n<p>\r\n	innodb_write_io_threads = 1000\r\n</p>\r\n<p>\r\n	innodb_read_io_threads = 1000\r\n</p>\r\n<p>\r\n	innodb_thread_concurrency = 8\r\n</p>\r\n<p>\r\n	innodb_purge_threads = 1\r\n</p>\r\n<p>\r\n	innodb_flush_log_at_trx_commit = 2\r\n</p>\r\n<p>\r\n	innodb_log_buffer_size = 4M\r\n</p>\r\n<p>\r\n	innodb_log_file_size = 32M\r\n</p>\r\n<p>\r\n	innodb_log_files_in_group = 3\r\n</p>\r\n<p>\r\n	innodb_max_dirty_pages_pct = 90\r\n</p>\r\n<p>\r\n	innodb_lock_wait_timeout = 120\r\n</p>\r\n<p>\r\n	bulk_insert_buffer_size = 8M\r\n</p>\r\n<p>\r\n	myisam_sort_buffer_size = 8M\r\n</p>\r\n<p>\r\n	myisam_max_sort_file_size = 10G\r\n</p>\r\n<p>\r\n	myisam_repair_threads = 1\r\n</p>\r\n<p>\r\n	interactive_timeout = 28800\r\n</p>\r\n<p>\r\n	wait_timeout = 28800\r\n</p>\r\n<p>\r\n	[mysqldump]\r\n</p>\r\n<p>\r\n	quick\r\n</p>\r\n<p>\r\n	max_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	[myisamchk]\r\n</p>\r\n<p>\r\n	key_buffer_size = 8M\r\n</p>\r\n<p>\r\n	sort_buffer_size = 8M\r\n</p>\r\n<p>\r\n	read_buffer = 4M\r\n</p>\r\n<p>\r\n	write_buffer = 4M\r\n</p>\r\n<p>\r\n	sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	针对上面的部署过程，为了便于以后安装mysql环境，编写了下面的安装脚本，直接运行这个脚本就能自动化构建mysql环境了。[root@slave-server ~]# cat mysql.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	#卸载系统自带的Mysql\r\n</p>\r\n<p>\r\n	/bin/rpm -e $(/bin/rpm -qa | grep mysql|xargs) --nodeps\r\n</p>\r\n<p>\r\n	/bin/rm -f /etc/my.cnf\r\n</p>\r\n<p>\r\n	#安装编译代码需要的包\r\n</p>\r\n<p>\r\n	/usr/bin/yum -y install make gcc-c++ cmake bison-devel ncurses-devel\r\n</p>\r\n<p>\r\n	#编译安装mysql5.6\r\n</p>\r\n<p>\r\n	/usr/sbin/groupadd mysql\r\n</p>\r\n<p>\r\n	/usr/sbin/useradd -g mysql mysql -M -s /sbin/nologin\r\n</p>\r\n<p>\r\n	cd /usr/local/src\r\n</p>\r\n<p>\r\n	wget -c http://ftp.ntu.edu.tw/MySQL/Downloads/MySQL-5.6/mysql-5.6.34.tar.gz\r\n</p>\r\n<p>\r\n	/bin/tar -zxvf mysql-5.6.34.tar.gz\r\n</p>\r\n<p>\r\n	cd mysql-5.6.34/\r\n</p>\r\n<p>\r\n	/usr/bin/cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci\r\n</p>\r\n<p>\r\n	make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	#修改/usr/local/mysql权限\r\n</p>\r\n<p>\r\n	mkdir -p /data/mysql/data\r\n</p>\r\n<p>\r\n	/bin/chown -R mysql:mysql /usr/local/mysql\r\n</p>\r\n<p>\r\n	/bin/chown -R mysql:mysql /data/mysql/data\r\n</p>\r\n<p>\r\n	#执行初始化配置脚本，创建系统自带的数据库和表\r\n</p>\r\n<p>\r\n	/usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/data/mysql/data --user=mysql\r\n</p>\r\n<p>\r\n	#配置my.cnf\r\n</p>\r\n<p>\r\n	cat &gt; /usr/local/mysql/my.cnf &lt;&lt; EOF\r\n</p>\r\n<p>\r\n	[client]\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	[mysqld]\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	basedir = /usr/local/mysql/\r\n</p>\r\n<p>\r\n	datadir = /data/mysql/data\r\n</p>\r\n<p>\r\n	pid-file = /data/mysql/data/mysql.pid\r\n</p>\r\n<p>\r\n	user = mysql\r\n</p>\r\n<p>\r\n	bind-address = 0.0.0.0\r\n</p>\r\n<p>\r\n	server-id = 1\r\n</p>\r\n<p>\r\n	sync_binlog=1\r\n</p>\r\n<p>\r\n	log_bin = mysql-bin\r\n</p>\r\n<p>\r\n	skip-name-resolve\r\n</p>\r\n<p>\r\n	#skip-networking\r\n</p>\r\n<p>\r\n	back_log = 600\r\n</p>\r\n<p>\r\n	max_connections = 3000\r\n</p>\r\n<p>\r\n	max_connect_errors = 3000\r\n</p>\r\n<p>\r\n	##open_files_limit = 65535\r\n</p>\r\n<p>\r\n	table_open_cache = 512\r\n</p>\r\n<p>\r\n	max_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	binlog_cache_size = 16M\r\n</p>\r\n<p>\r\n	max_heap_table_size = 16M\r\n</p>\r\n<p>\r\n	tmp_table_size = 256M\r\n</p>\r\n<p>\r\n	read_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	read_rnd_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	sort_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	join_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	key_buffer_size = 8192M\r\n</p>\r\n<p>\r\n	thread_cache_size = 8\r\n</p>\r\n<p>\r\n	query_cache_size = 512M\r\n</p>\r\n<p>\r\n	query_cache_limit = 1024M\r\n</p>\r\n<p>\r\n	ft_min_word_len = 4\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	expire_logs_days = 30\r\n</p>\r\n<p>\r\n	log_error = /data/mysql/data/mysql-error.log\r\n</p>\r\n<p>\r\n	slow_query_log = 1\r\n</p>\r\n<p>\r\n	long_query_time = 1\r\n</p>\r\n<p>\r\n	slow_query_log_file = /data/mysql/data/mysql-slow.log\r\n</p>\r\n<p>\r\n	performance_schema = 0\r\n</p>\r\n<p>\r\n	explicit_defaults_for_timestamp\r\n</p>\r\n<p>\r\n	##lower_case_table_names = 1\r\n</p>\r\n<p>\r\n	skip-external-locking\r\n</p>\r\n<p>\r\n	default_storage_engine = InnoDB\r\n</p>\r\n<p>\r\n	##default-storage-engine = MyISAM\r\n</p>\r\n<p>\r\n	innodb_file_per_table = 1\r\n</p>\r\n<p>\r\n	innodb_open_files = 500\r\n</p>\r\n<p>\r\n	innodb_buffer_pool_size = 1024M\r\n</p>\r\n<p>\r\n	innodb_write_io_threads = 1000\r\n</p>\r\n<p>\r\n	innodb_read_io_threads = 1000\r\n</p>\r\n<p>\r\n	innodb_thread_concurrency = 8\r\n</p>\r\n<p>\r\n	innodb_purge_threads = 1\r\n</p>\r\n<p>\r\n	innodb_flush_log_at_trx_commit = 2\r\n</p>\r\n<p>\r\n	innodb_log_buffer_size = 4M\r\n</p>\r\n<p>\r\n	innodb_log_file_size = 32M\r\n</p>\r\n<p>\r\n	innodb_log_files_in_group = 3\r\n</p>\r\n<p>\r\n	innodb_max_dirty_pages_pct = 90\r\n</p>\r\n<p>\r\n	innodb_lock_wait_timeout = 120\r\n</p>\r\n<p>\r\n	bulk_insert_buffer_size = 8M\r\n</p>\r\n<p>\r\n	myisam_sort_buffer_size = 8M\r\n</p>\r\n<p>\r\n	myisam_max_sort_file_size = 10G\r\n</p>\r\n<p>\r\n	myisam_repair_threads = 1\r\n</p>\r\n<p>\r\n	interactive_timeout = 28800\r\n</p>\r\n<p>\r\n	wait_timeout = 28800\r\n</p>\r\n<p>\r\n	[mysqldump]\r\n</p>\r\n<p>\r\n	quick\r\n</p>\r\n<p>\r\n	max_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	[myisamchk]\r\n</p>\r\n<p>\r\n	key_buffer_size = 8M\r\n</p>\r\n<p>\r\n	sort_buffer_size = 8M\r\n</p>\r\n<p>\r\n	read_buffer = 4M\r\n</p>\r\n<p>\r\n	write_buffer = 4M\r\n</p>\r\n<p>\r\n	sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\r\n</p>\r\n<p>\r\n	port = 3306\r\n</p>\r\n<p>\r\n	EOF\r\n</p>\r\n<p>\r\n	#启动mysql服务\r\n</p>\r\n<p>\r\n	cd /usr/local/mysql\r\n</p>\r\n<p>\r\n	cp support-files/mysql.server /etc/init.d/mysql\r\n</p>\r\n<p>\r\n	/sbin/chkconfig mysql on\r\n</p>\r\n<p>\r\n	service mysql start\r\n</p>\r\n<p>\r\n	#设置环境变量\r\n</p>\r\n<p>\r\n	echo \"export PATH=$PATH:/usr/local/mysql/bin\" &gt;&gt; /etc/profile\r\n</p>\r\n<p>\r\n	source /etc/profile\r\n</p>\r\n<p>\r\n	#设置mysql登陆密码,初始密码为123456\r\n</p>\r\n<p>\r\n	/bin/mkdir -p /var/lib/mysql\r\n</p>\r\n<p>\r\n	ln -s /usr/local/mysql/var/mysql.sock /var/lib/mysql/mysql.sock\r\n</p>\r\n<p>\r\n	mysql -e \"SET PASSWORD = PASSWORD(\'123456\');\"\r\n</p>\r\n<p>\r\n	mysql -p123456 -e \"GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'password\' WITH GRANT OPTION;\"\r\n</p>\r\n<p>\r\n	mysql -p123456 -e \"FLUSH PRIVILEGES;\"\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('39a221e9-4145-4ccd-b51d-7a1479f9fc60','mysql表名忽略大小写问题记录','mysql表名忽略大小写问题记录','<p>\r\n	问题描述：一开发同事在linux下调一个程序老是报错说找不到表，但是登陆mysql，show tables查看明明是已经创建了这张表的！！如下：\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huan_db                         |\r\n</p>\r\n<p>\r\n	+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| advertisement                             |\r\n</p>\r\n<p>\r\n	| message_queue                             |\r\n</p>\r\n<p>\r\n	| message_sys_user                          |\r\n</p>\r\n<p>\r\n	| message_user                              |\r\n</p>\r\n<p>\r\n	| opHistory                                 |\r\n</p>\r\n<p>\r\n	| opHistory_queue                           |\r\n</p>\r\n<p>\r\n	| opHistory_queue_result_log                |\r\n</p>\r\n<p>\r\n	| opHistory_queue_send_fail_log             |\r\n</p>\r\n<p>\r\n	+-------------------------------------------+\r\n</p>\r\n<p>\r\n	8 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; desc opHistory;\r\n</p>\r\n<p>\r\n	ERROR 1146 (42S02): Table \'haun_db.opHistory\' doesn\'t exist\r\n</p>\r\n<p>\r\n	mysql&gt; desc opHistory_queue;\r\n</p>\r\n<p>\r\n	ERROR 1146 (42S02): Table \'haun_db.opHistory_queue\' doesn\'t exist\r\n</p>\r\n<p>\r\n	mysql&gt; desc opHistory_queue_result_log;\r\n</p>\r\n<p>\r\n	ERROR 1146 (42S02): Table \'haun_db.opHistory\' doesn\'t exist\r\n</p>\r\n<p>\r\n	mysql&gt; desc opHistory_queue_send_fail_log;\r\n</p>\r\n<p>\r\n	ERROR 1146 (42S02): Table \'haun_db.opHistory_queue_send_fail_log\' doesn\'t exist\r\n</p>\r\n<p>\r\n	这张表明明存在，为什么程序就找不到表呢？？\r\n</p>\r\n<p>\r\n	原因查找：因为linux下mysql默认是要区分表名大小写的。mysql是否区分大小写设置是由参数lower_case_table_names决定的，其中：1）lower_case_table_names = 0 区分大小写（即对大小写不敏感），默认是这种设置。这样设置后，在mysql里创建的表名带不带大写字母都没有影响，都可以正常读出和被引用。\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%case%\";\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name          | Value |\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	| lower_case_file_system | ON    |\r\n</p>\r\n<p>\r\n	| lower_case_table_names | 0     |\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）lower_case_table_names = 1 不区分大小写（即对大小写敏感）。这样设置后，表名在硬盘上以小写保存，MySQL将所有表名转换为小写存储和查找表上。该行为也适合数据库名和表的别名。也就是说，mysql设置为不分区大小写后，创建库或表时，不管创建时使用大写字母，创建成功后，都是强制以小写保存！\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%case%\";\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name          | Value |\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	| lower_case_file_system | OFF   |\r\n</p>\r\n<p>\r\n	| lower_case_table_names | 1     |\r\n</p>\r\n<p>\r\n	+------------------------+-------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	上面的报错是因为：开发之前在mysql里创建这张带有大写字母的表时，mysql还是默认的区分大小写设置，即对大小写不敏感。后来运维同事又将mysql改成不分区大小写设置了，此时mysql都是强制以小写保存的表，所以开发后面再次在程序里引用这张表的时候，就会报错说不存在！\r\n</p>\r\n<p>\r\n	解决办法：1）先在my.cnf里将lower_case_table_names参数再次调整为0，改成区分大小写2）然后mysqladmin -uroot -p shutdown 以安全模式关闭数据库3）登陆mysql数据库，\"alter table 旧表名 rename 新表名\" 将带大写字母的旧表改为小写表名4）最后再启动mysql即可！\r\n</p>\r\n<p>\r\n	-------------------------------这里多说一下----------------------------------------------------MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：1）数据库名与表名是严格区分大小写的；2）表的别名是严格区分大小写的；3）列名与列的别名在所有的情况下均是忽略大小写的；4）变量名也是严格区分大小写的；5）MySQL在Windows下都不区分大小写，但是在Linux下默认是区分大小写的。6）如果想在查询时区分字段值的大小写，则字段值需要设置BINARY属性，设置的方法有多种：&nbsp; &nbsp; &nbsp;a）创建时设置：&nbsp; &nbsp; &nbsp;CREATE TABLE T(A VARCHAR(10) BINARY);&nbsp; &nbsp; &nbsp;b）使用alter修改\r\n</p>\r\n<p>\r\n	所以在不同操作系统中为了能使程序和数据库都能正常运行，最好的办法是在设计表的时候都转为小写！！\r\n</p>\r\n<p>\r\n	修改mysql为不区分大小写设置：[root@test-huanqiu ~]# mysqladmin -uroot -p shutdown //以安全模式关闭数据库[root@test-huanqiu ~]# cat /etc/my.cnf //添加下面一行设置.....[mysqld]lower_case_table_names=1.....\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# /etc/init.d/mysql start //启动mysql-----------------------------------------------------------------------------------------------\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('3c5cc265-a5e6-4493-bc83-70ff9b3ebb44','Beautiful Soup 4.4.0 基本使用方法','Beautiful Soup 4.4.0 基本使用方法','Beautiful Soup 4.4.0 基本使用方法<br />\r\nBeautiful Soup 安装 pip install &nbsp;beautifulsoup4 标准库有html.parser解析器但速度不是很快一般还需安装第三方的解析器：<br />\r\npip install lxml pip install html5lib<br />\r\nhtml_doc = \"\"\"<br />\r\n&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse\'s story&lt;/title&gt;&lt;/head&gt;<br />\r\n&lt;body&gt;<br />\r\n&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse\'s story&lt;/b&gt;&lt;/p&gt;<br />\r\n<br />\r\n&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were<br />\r\n&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and<br />\r\n&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;<br />\r\nand they lived at the bottom of a well.&lt;/p&gt;<br />\r\n<br />\r\n&lt;p class=\"story\"&gt;...&lt;/p&gt;<br />\r\n\"\"\"<br />\r\nfrom bs4 import BeautifulSoup<br />\r\nsoup=BeautifulSoup(html_doc,\'html.parser\')<br />\r\nsoup.title &nbsp; #title标签 &lt;title&gt;The Dormouse\'s story&lt;/title&gt;<br />\r\nsoup.title.string &nbsp;#title标签内容 The Dormouse\'s story<br />\r\nsoup.title.name#title标签名称 title<br />\r\nsoup.title.parent #head标签 &lt;head&gt;&lt;title&gt;The Dormouse\'s story&lt;/title&gt;&lt;/head&gt; children<br />\r\nsoup.head.contents#取head标签里的所有子标签 &lt;title&gt;The Dormouse\'s story&lt;/title&gt;<br />\r\nsoup.head.contents[0]#取head标签的第一个子标签&nbsp;<br />\r\nsoup.p #第一个p标签 &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse\'s story&lt;/b&gt;&lt;/p&gt;<br />\r\nsoup.p[\'class\']#第一个p标签class名称 html解析器返回结果是一个列表[title] xml返回是一个字符串“title”<br />\r\nsoup.prettify() #按照标准的缩进格式的结构完整输出（自动补结尾的&lt;/body&gt;&lt;/html&gt;<br />\r\nsoup.find_all(\'a\')#找所有的a标签<br />\r\nsoup.find(id=\'link3\')#找id为link3的标签<br />\r\nsoup.find_all([\"a\", \"b\"])#查找a b标签<br />\r\nsoup.find_all(\"p\", \"title\")#查找p标签并且属性为title<br />\r\nsoup.find_all(\"a\", class_=\"sister\")<br />\r\nsoup.find_all(\"a\", limit=2)<br />\r\nsoup.get_text()#从文档中获取所有文字内容:<br />\r\nfor a in soup.find_all(\'a\'):<br />\r\n&nbsp; &nbsp; print a.get(\'href\') &nbsp;#取得所有a标签的href值<br />\r\n调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False&nbsp;<br />\r\ncss选择器：<br />\r\n<br />\r\n通过tag标签逐层查找:<br />\r\n<br />\r\nsoup.select(\"body a\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" &nbsp;id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"html head title\")<br />\r\n# [&lt;title&gt;The Dormouse\'s story&lt;/title&gt;]<br />\r\n找到某个tag标签下的直接子标签 [6] :<br />\r\n<br />\r\nsoup.select(\"head &gt; title\")<br />\r\n# [&lt;title&gt;The Dormouse\'s story&lt;/title&gt;]<br />\r\n<br />\r\nsoup.select(\"p &gt; a\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" &nbsp;id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"p &gt; a:nth-of-type(2)\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"p &gt; #link1\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"body &gt; a\")<br />\r\n# []<br />\r\n找到兄弟节点标签:<br />\r\n<br />\r\nsoup.select(\"#link1 ~ .sister\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" &nbsp;id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"#link1 + .sister\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]<br />\r\n通过CSS的类名查找:<br />\r\n<br />\r\nsoup.select(\".sister\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"[class~=sister]\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n通过tag的id查找:<br />\r\n<br />\r\nsoup.select(\"#link1\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\"a#link2\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]<br />\r\n同时用多种CSS选择器查询元素:<br />\r\n<br />\r\nsoup.select(\"#link1,#link2\")<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]<br />\r\n通过是否存在某个属性来查找:<br />\r\n<br />\r\nsoup.select(\'a[href]\')<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n通过属性的值来查找:<br />\r\n<br />\r\nsoup.select(\'a[href=\"http://example.com/elsie\"]\')<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\'a[href^=\"http://example.com/\"]\')<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,<br />\r\n# &nbsp;&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\'a[href$=\"tillie\"]\')<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]<br />\r\n<br />\r\nsoup.select(\'a[href*=\".com/el\"]\')<br />\r\n# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;]<br />\r\n<br />\r\n<br />\r\n<br />\r\n<br />','2017-08-01 10:55:29',2,4,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('40de8c0c-2e2a-4e22-b47b-8e2083658857','MySQL高可用架构-MHA环境部署记录','MySQL高可用架构-MHA环境部署记录','<p>\r\n	一、MHA介绍\r\n</p>\r\n<p>\r\n	MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是日本的一位\r\n</p>\r\n<p>\r\n	MySQL专家采用Perl语言编写的一个脚本管理工具，该工具仅适用于MySQLReplication（二层）环境，目的在于维持Master主库的高可用性。是一套优秀的作为MySQL高可用性\r\n</p>\r\n<p>\r\n	环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上\r\n</p>\r\n<p>\r\n	保证数据的一致性，以达到真正意义上的高可用。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MHA是自动的master故障转移和Slave提升的软件包.它是基于标准的MySQL复制(异步/半同步).该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。\r\n</p>\r\n<p>\r\n	1）MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Manager会定时探测集群中的node节点,当发现master\r\n</p>\r\n<p>\r\n	出现故障的时候,它可以自动将具有最新数据的slave提升为新的master,然后将所有其它的slave导向新的master上.整个故障转移过程对应用程序是透明的。\r\n</p>\r\n<p>\r\n	2）MHA Node运行在每台MySQL服务器上，它通过监控具备解析和清理logs功能的脚本来加快故障转移的。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，\r\n</p>\r\n<p>\r\n	MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave\r\n</p>\r\n<p>\r\n	已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至\r\n</p>\r\n<p>\r\n	少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。\r\n</p>\r\n<p>\r\n	二、MHA工作架构说明\r\n</p>\r\n<p>\r\n	展示了如何通过MHA Manager管理多组主从复制。可以将MHA工作原理总结为如下：\r\n</p>\r\n<p>\r\n	相较于其它HA软件，MHA的目的在于维持MySQL Replication中Master库的高可用性，其最大特点是可以修复多个Slave之间的差异日志，最终使所有Slave保持数据一致，\r\n</p>\r\n<p>\r\n	然后从中选择一个充当新的Master，并将其它Slave指向它。工作流程主要如下：\r\n</p>\r\n<p>\r\n	1）从宕机崩溃的master保存二进制日志事件（binlog events）;\r\n</p>\r\n<p>\r\n	2）识别含有最新更新的slave；\r\n</p>\r\n<p>\r\n	3）应用差异的中继日志（relay log）到其他的slave；\r\n</p>\r\n<p>\r\n	4）应用从master保存的二进制日志事件（binlog events）；\r\n</p>\r\n<p>\r\n	5）提升一个slave为新的master；\r\n</p>\r\n<p>\r\n	6）使其他的slave连接新的master进行复制；\r\n</p>\r\n<p>\r\n	MHA工作原理\r\n</p>\r\n<p>\r\n	当master出现故障时，通过对比slave之间I/O线程读取master binlog的位置，选取最接近的slave做为latest slave。其它slave通过与latest slave对比生成差异中继日志。\r\n</p>\r\n<p>\r\n	在latest slave上应用从master保存的binlog，同时将latest slave提升为master。最后在其它slave上应用相应的差异中继日志并开始从新的master开始复制。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在MHA实现Master故障切换过程中，MHA Node会试图访问故障的master（通过SSH），如果可以访问（不是硬件故障，比如InnoDB数据文件损坏等），会保存二进制文件，以最大程度\r\n</p>\r\n<p>\r\n	保证数据不丢失。MHA和半同步复制一起使用会大大降低数据丢失的危险。\r\n</p>\r\n<p>\r\n	MHA软件的架构：由两部分组成，Manager工具包和Node工具包，具体的说明如下。Manager工具包主要包括以下几个工具：\r\n</p>\r\n<p>\r\n	masterha_check_ssh              检查MHA的SSH配置状况\r\n</p>\r\n<p>\r\n	masterha_check_repl             检查MySQL复制状况\r\n</p>\r\n<p>\r\n	masterha_manger                 启动MHA\r\n</p>\r\n<p>\r\n	masterha_check_status           检测当前MHA运行状态\r\n</p>\r\n<p>\r\n	masterha_master_monitor         检测master是否宕机\r\n</p>\r\n<p>\r\n	masterha_master_switch          控制故障转移（自动或者手动）\r\n</p>\r\n<p>\r\n	masterha_conf_host              添加或删除配置的server信息\r\n</p>\r\n<p>\r\n	Node工具包（这些工具通常由MHA Manager的脚本触发，无需人为操作）主要包括以下几个工具：\r\n</p>\r\n<p>\r\n	save_binary_logs（保存二进制日志）             保存和复制master的二进制日志\r\n</p>\r\n<p>\r\n	apply_diff_relay_logs（应用差异中继日志）      识别差异的中继日志事件并将其差异的事件应用于其他的slave\r\n</p>\r\n<p>\r\n	filter_mysqlbinlog                          去除不必要的ROLLBACK事件（MHA已不再使用这个工具）\r\n</p>\r\n<p>\r\n	purge_relay_logs（清理中继日志）               清除中继日志（不会阻塞SQL线程）\r\n</p>\r\n<p>\r\n	.....................................................................................................\r\n</p>\r\n<p>\r\n	MHA如何保持数据的一致性呢？主要通过MHA node的以下几个工具实现，但是这些工具由mha manager触发：\r\n</p>\r\n<p>\r\n	save_binary_logs         如果master的二进制日志可以存取的话，保存复制master的二进制日志，最大程度保证数据不丢失\r\n</p>\r\n<p>\r\n	apply_diff_relay_logs    相对于最新的slave，生成差异的中继日志并将所有差异事件应用到其他所有的slave\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	对比的是relay log，relay log越新就越接近于master，才能保证数据是最新的。\r\n</p>\r\n<p>\r\n	purge_relay_logs删除中继日志而不阻塞sql线程\r\n</p>\r\n<p>\r\n	MHA的优势\r\n</p>\r\n<p>\r\n	1）故障切换快\r\n</p>\r\n<p>\r\n	在主从复制集群中，只要从库在复制上没有延迟，MHA通常可以在数秒内实现故障切换。9-10秒内检查到master故障，可以选择在7-10秒关闭master以避免出现裂脑，几秒钟内，\r\n</p>\r\n<p>\r\n	将差异中继日志（relay log）应用到新的master上，因此总的宕机时间通常为10-30秒。恢复新的master后，MHA并行的恢复其余的slave。即使在有数万台slave，也不会\r\n</p>\r\n<p>\r\n	影响master的恢复时间。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	DeNA在超过150个MySQL（主要5.0/5.1版本）主从环境下使用了MHA。当mater故障后，MHA在4秒内就完成了故障切换。在传统的主动/被动集群解决方案中，4秒内完成故障切换是不可能的。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）master故障不会导致数据不一致\r\n</p>\r\n<p>\r\n	当目前的master出现故障时，MHA自动识别slave之间中继日志（relay log）的不同，并应用到所有的slave中。这样所有的salve能够保持同步，只要所有的slave处于存活\r\n</p>\r\n<p>\r\n	状态。和Semi-Synchronous Replication一起使用，（几乎）可以保证没有数据丢失。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	3）无需修改当前的MySQL设置\r\n</p>\r\n<p>\r\n	MHA的设计的重要原则之一就是尽可能地简单易用。MHA工作在传统的MySQL版本5.0和之后版本的主从复制环境中。和其它高可用解决方法比，MHA并不需要改变MySQL的部署环境。\r\n</p>\r\n<p>\r\n	MHA适用于异步和半同步的主从复制。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动/停止/升级/降级/安装/卸载MHA不需要改变（包扩启动/停止）MySQL复制。当需要升级MHA到新的版本，不需要停止MySQL，仅仅替换到新版本的MHA，然后重启MHA　Manager\r\n</p>\r\n<p>\r\n	就好了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MHA运行在MySQL 5.0开始的原生版本上。一些其它的MySQL高可用解决方案需要特定的版本（比如MySQL集群、带全局事务ID的MySQL等等），但并不仅仅为了master的高可用才迁移应用的。在大多数情况下，已经部署了比较旧MySQL应用，并且不想仅仅为了实现Master的高可用，花太多的时间迁移到不同的存储引擎或更新的前沿发行版。MHA工作的包括5.0/5.1/5.5的原生版本的MySQL上，所以并不需要迁移。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	4）无需增加大量的服务器\r\n</p>\r\n<p>\r\n	MHA由MHA Manager和MHA Node组成。MHA Node运行在需要故障切换/恢复的MySQL服务器上，因此并不需要额外增加服务器。MHA Manager运行在特定的服务器上，因此需要\r\n</p>\r\n<p>\r\n	增加一台（实现高可用需要2台），但是MHA Manager可以监控大量（甚至上百台）单独的master，因此，并不需要增加大量的服务器。即使在一台slave上运行MHA Manager也是\r\n</p>\r\n<p>\r\n	可以的。综上，实现MHA并没用额外增加大量的服务。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	5）无性能下降\r\n</p>\r\n<p>\r\n	MHA适用与异步或半同步的MySQL复制。监控master时，MHA仅仅是每隔几秒（默认是3秒）发送一个ping包，并不发送重查询。可以得到像原生MySQL复制一样快的性能。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	6）适用于任何存储引擎\r\n</p>\r\n<p>\r\n	MHA可以运行在只要MySQL复制运行的存储引擎上，并不仅限制于InnoDB，即使在不易迁移的传统的MyISAM引擎环境，一样可以使用MHA。\r\n</p>\r\n<p>\r\n	三、MHA高可用环境部署记录\r\n</p>\r\n<p>\r\n	1）机器环境\r\n</p>\r\n<p>\r\n	ip地址             主机名           角色\r\n</p>\r\n<p>\r\n	182.48.115.236    Node_Master     写入，数据节点\r\n</p>\r\n<p>\r\n	182.48.115.237    Node_Slave      读，数据节点，备选Master(candicate master)\r\n</p>\r\n<p>\r\n	182.48.115.238    Manager_Slave   读，数据节点，也作为Manager server(即也作为manager节点)\r\n</p>\r\n<p>\r\n	........................................................................................................\r\n</p>\r\n<p>\r\n	为了节省机器，这里选择只读的从库182.48.115.237(从库不对外提供读的服务)作为候选主库,即candicate master，或是专门用于备份\r\n</p>\r\n<p>\r\n	同样，为了节省机器，这里选择182.48.115.238这台从库作为manager server（实际生产环节中，机器充足的情况下, 一般是专门选择一台机器作为Manager server）\r\n</p>\r\n<p>\r\n	........................................................................................................\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	关闭三台机器的iptables和selinux\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	部署节点之间ssh无密码登陆的信任关系（即在所有节点上做ssh免密码登录，包括对节点本机的信任）\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# ssh-copy-id 182.48.115.236\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# ssh-copy-id 182.48.115.237\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# ssh-copy-id 182.48.115.238\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# ssh-copy-id 182.48.115.236\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# ssh-copy-id 182.48.115.237\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# ssh-copy-id 182.48.115.238\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# ssh-copy-id 182.48.115.236\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# ssh-copy-id 182.48.115.237\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# ssh-copy-id 182.48.115.238\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	现在3台节点已经能实现两两互相ssh通了，不需要输入密码即可。如果不能实现任何两台主机互相之间可以无密码登录，后面的环节可能会有问题。\r\n</p>\r\n<p>\r\n	2）实现主机名hostname登录(在三台节点上都需要执行）（这一步不是必须要操作的）\r\n</p>\r\n<p>\r\n	分别设置三台节点机器的主机名（主机名上面已提出），并绑定hosts.\r\n</p>\r\n<p>\r\n	三台机器的/etc/hosts文件的绑定信息如下：\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# vim /etc/hosts\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	182.48.115.236    Node_Master\r\n</p>\r\n<p>\r\n	182.48.115.237    Node_Slave\r\n</p>\r\n<p>\r\n	182.48.115.238    Manager_Slave\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	相互验证下使用主机名登陆是否正常，是否可以相互使用主机名ssh无密码登陆到对方。\r\n</p>\r\n<p>\r\n	3）准备好Mysql主从环境\r\n</p>\r\n<p>\r\n	架构如下，一主二从的架构：\r\n</p>\r\n<p>\r\n	主库：182.48.115.236    从库：182.48.115.237\r\n</p>\r\n<p>\r\n	主库：182.48.115.236    从库：182.48.115.238\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Mysql主从环境部署可以参考：http://www.cnblogs.com/kevingrace/p/6256603.html\r\n</p>\r\n<p>\r\n	.......................................................................................\r\n</p>\r\n<p>\r\n	------主库配置------\r\n</p>\r\n<p>\r\n	server-id=1\r\n</p>\r\n<p>\r\n	log-bin=mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db=mysql\r\n</p>\r\n<p>\r\n	sync_binlog = 1\r\n</p>\r\n<p>\r\n	binlog_checksum = none\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	------从库1配置-------\r\n</p>\r\n<p>\r\n	server-id=2\r\n</p>\r\n<p>\r\n	log-bin=mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db=mysql       //千万要注意：主从同步中的过滤字段要一致，否则后面使用masterha_check_repl 检查复制时就会出错！\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	------从库2配置-------\r\n</p>\r\n<p>\r\n	server-id=3\r\n</p>\r\n<p>\r\n	log-bin=mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db=mysql\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后主库授权给从库连接的权限，设置后，最好在从库上验证下是否能使用授予的权限连接主库。\r\n</p>\r\n<p>\r\n	然后在从库上根据主库的“show master status;” 信心进行change master.....同步设置。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	主从设置时，如果设置了bbinlog-ignore-db 和 replicate-ignore-db 过滤规则，则主从必须相同。即要使用binlog-ignore-db过滤字段，则主从配置都使用这个，\r\n</p>\r\n<p>\r\n	要是使用replicate-ignore-db过滤字段，则主从配置都使用这个，千万不能主从配置使用的过滤字段不一样！因为MHA 在启动时候会检测过滤规则，如果过滤规则不同，MHA 不启动监控和故障转移。\r\n</p>\r\n<p>\r\n	.......................................................................................\r\n</p>\r\n<p>\r\n	4）创建用户mha管理的账号(在三台节点上都需要执行）\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT SUPER,RELOAD,REPLICATION CLIENT,SELECT ON *.* TO manager@\'182.48.115.%\' IDENTIFIED BY \'manager_1234\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.06 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT CREATE,INSERT,UPDATE,DELETE,DROP ON*.* TO manager@\'182.48.115.%\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.05 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	创建主从账号(在三台节点上都需要执行）:\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT RELOAD, SUPER, REPLICATION SLAVE ON*.* TO \'repl\'@\'182.48.115.%\' IDENTIFIED BY \'repl_1234\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.09 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.06 sec)\r\n</p>\r\n<p>\r\n	5）开始安装mhamha包括manager节点和data节点，其中：data节点包括原有的MySQL复制结构中的主机，至少3台，即1主2从，当master failover后，还能保证主从结构；只需安装node包。manager server：运行监控脚本，负责monitoring 和 auto-failover；需要安装node包和manager包。\r\n</p>\r\n<p>\r\n	5.1）在所有data数据节点机上安装安装MHA node\r\n</p>\r\n<p>\r\n	下载mha4mysql-node-0.56.tar.gz\r\n</p>\r\n<p>\r\n	下载地址：http://pan.baidu.com/s/1cphgLo\r\n</p>\r\n<p>\r\n	提取密码：7674\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# yum -y install perl-DBD-MySQL      //先安装所需的perl模块\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# tar -zvxf mha4mysql-node-0.56.tar.gz\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# cd mha4mysql-node-0.56\r\n</p>\r\n<p>\r\n	[root@Node_Master mha4mysql-node-0.56]# perl Makefile.PL\r\n</p>\r\n<p>\r\n	................................................................................................................\r\n</p>\r\n<p>\r\n	这一步可能报错如下：\r\n</p>\r\n<p>\r\n	1）Can\'t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: inc /usr/local/lib64/perl5 /usr/local/share/perl5......\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	[root@Node_Master mha4mysql-node-0.56]# yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）Can\'t locate CPAN.pm in @INC (@INC contains: inc /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5....\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	[root@Node_Master mha4mysql-node-0.56]# yum install -y perl-CPAN\r\n</p>\r\n<p>\r\n	................................................................................................................\r\n</p>\r\n<p>\r\n	[root@Node_Master mha4mysql-node-0.56]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	5.2）在manager节点（即182.48.115.238）上安装MHA Manager（注意manager节点也要安装MHA node）\r\n</p>\r\n<p>\r\n	首先下载第三方yum源\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	安装perl的mysql包：\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# yum install -y perl-DBD-MySQL perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-Config-IniFiles perl-Time-HiRes -y\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	安装MHA Manager软件包：\r\n</p>\r\n<p>\r\n	下载地址：https://pan.baidu.com/s/1slyfXN3\r\n</p>\r\n<p>\r\n	提取密码：86wb\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# tar -vxf mha4mysql-manager-0.56.tar\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# cd mha4mysql-manager-0.56\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# perl Makefile.PL\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	安装完MHA Manager后，在/usr/local/bin目录下会生成以下脚本：\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# ll /usr/local/bin/\r\n</p>\r\n<p>\r\n	总用量 84\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root 16367 5月  31 21:37 apply_diff_relay_logs\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  4807 5月  31 21:37 filter_mysqlbinlog\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  1995 5月  31 22:23 masterha_check_repl\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  1779 5月  31 22:23 masterha_check_ssh\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  1865 5月  31 22:23 masterha_check_status\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  3201 5月  31 22:23 masterha_conf_host\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  2517 5月  31 22:23 masterha_manager\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  2165 5月  31 22:23 masterha_master_monitor\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  2373 5月  31 22:23 masterha_master_switch\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  5171 5月  31 22:23 masterha_secondary_check\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  1739 5月  31 22:23 masterha_stop\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  8261 5月  31 21:37 purge_relay_logs\r\n</p>\r\n<p>\r\n	-r-xr-xr-x. 1 root root  7525 5月  31 21:37 save_binary_logs\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	其中：\r\n</p>\r\n<p>\r\n	masterha_check_repl             检查MySQL复制状况\r\n</p>\r\n<p>\r\n	masterha_check_ssh              检查MHA的SSH配置状况\r\n</p>\r\n<p>\r\n	masterha_check_status           检测当前MHA运行状态\r\n</p>\r\n<p>\r\n	masterha_conf_host              添加或删除配置的server信息\r\n</p>\r\n<p>\r\n	masterha_manager                启动MHA\r\n</p>\r\n<p>\r\n	masterha_stop                   停止MHA\r\n</p>\r\n<p>\r\n	masterha_master_monitor         检测master是否宕机\r\n</p>\r\n<p>\r\n	masterha_master_switch          控制故障转移（自动或者手动）\r\n</p>\r\n<p>\r\n	masterha_secondary_check        多种线路检测master是否存活\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	另外:\r\n</p>\r\n<p>\r\n	在../mha4mysql-manager-0.56/samples/scripts下还有以下脚本，需要将其复制到/usr/local/bin\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# cd samples/scripts/\r\n</p>\r\n<p>\r\n	[root@Manager_Slave scripts]# ll\r\n</p>\r\n<p>\r\n	总用量 32\r\n</p>\r\n<p>\r\n	-rwxr-xr-x. 1 4984 users  3648 4月   1 2014 master_ip_failover            //自动切换时VIP管理脚本,不是必须，如果我们使用keepalived的，我们可以自己编写脚本完成对vip的管理，比如监控mysql，如果mysql异常，我们停止keepalived就行，这样vip就会自动漂移\r\n</p>\r\n<p>\r\n	-rwxr-xr-x. 1 4984 users  9870 4月   1 2014 master_ip_online_change       //在线切换时VIP脚本,不是必须，同样可以可以自行编写简单的shell完成\r\n</p>\r\n<p>\r\n	-rwxr-xr-x. 1 4984 users 11867 4月   1 2014 power_manager                 //故障发生后关闭master脚本,不是必须\r\n</p>\r\n<p>\r\n	-rwxr-xr-x. 1 4984 users  1360 4月   1 2014 send_report                   //故障切换发送报警脚本，不是必须，可自行编写简单的shell完成\r\n</p>\r\n<p>\r\n	[root@Manager_Slave scripts]# cp ./* /usr/local/bin/\r\n</p>\r\n<p>\r\n	5.3）在管理节点（182.48.115.238）上进行下面配置\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# mkdir -p /etc/masterha\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# cp samples/conf/app1.cnf /etc/masterha/\r\n</p>\r\n<p>\r\n	[root@Manager_Slave mha4mysql-manager-0.56]# vim /etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	[server default]\r\n</p>\r\n<p>\r\n	manager_workdir=/var/log/masterha/app1            //设置manager的工作目录\r\n</p>\r\n<p>\r\n	manager_log=/var/log/masterha/app1/manager.log    //设置manager的日志\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ssh_user=root                                     //ssh免密钥登录的帐号名\r\n</p>\r\n<p>\r\n	repl_user=repl                                    //mysql复制帐号，用来在主从机之间同步二进制日志等\r\n</p>\r\n<p>\r\n	repl_password=repl_1234                           //设置mysql中root用户的密码，这个密码是前文中创建监控用户的那个密码\r\n</p>\r\n<p>\r\n	ping_interval=1                                   //设置监控主库，发送ping包的时间间隔,用来检查master是否正常，默认是3秒，尝试三次没有回应的时候自动进行railover\r\n</p>\r\n<p>\r\n	master_ip_failover_script= /usr/local/bin/master_ip_failover               //设置自动failover时候的切换脚本\r\n</p>\r\n<p>\r\n	master_ip_online_change_script= /usr/local/bin/master_ip_online_change     //设置手动切换时候的切换脚本\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[server1]\r\n</p>\r\n<p>\r\n	hostname=182.48.115.236\r\n</p>\r\n<p>\r\n	port=3306\r\n</p>\r\n<p>\r\n	master_binlog_dir=/data/mysql/data/       //设置master 保存binlog的位置，以便MHA可以找到master的日志，我这里的也就是mysql的数据目录\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[server2]\r\n</p>\r\n<p>\r\n	hostname=182.48.115.237\r\n</p>\r\n<p>\r\n	port=3306\r\n</p>\r\n<p>\r\n	candidate_master=1          //设置为候选master，即master机宕掉后,优先启用这台作为新master，如果设置该参数以后，发生主从切换以后将会将此从库提升为主库，即使这个主库不是集群中事件最新的slave\r\n</p>\r\n<p>\r\n	check_repl_delay=0         //默认情况下如果一个slave落后master 100M的relay logs的话，MHA将不会选择该slave作为一个新的master，因为对于这个slave的恢复需要花费很长时间，通过设置check_repl_delay=0,MHA触发切换在选择一个新的master的时候将会忽略复制延时，这个参数对于设置了candidate_master=1的主机非常有用，因为这个候选主在切换的过程中一定是新的master\r\n</p>\r\n<p>\r\n	master_binlog_dir=/data/mysql/data/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[server3]\r\n</p>\r\n<p>\r\n	hostname=182.48.115.238\r\n</p>\r\n<p>\r\n	port=3306\r\n</p>\r\n<p>\r\n	#candidate_master=1\r\n</p>\r\n<p>\r\n	master_binlog_dir=/data/mysql/data/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#[server4]\r\n</p>\r\n<p>\r\n	#hostname=host4\r\n</p>\r\n<p>\r\n	#no_master=1\r\n</p>\r\n<p>\r\n	5.4）设置relay log的清除方式（在两台slave节点上）\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# mysql -p123456 -e \'set global relay_log_purge=0\'\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# mysql -p123456 -e \'set global relay_log_purge=0\'\r\n</p>\r\n<p>\r\n	..................................................................................................\r\n</p>\r\n<p>\r\n	温馨提示：\r\n</p>\r\n<p>\r\n	MHA在发生切换的过程中，从库的恢复过程中依赖于relay log的相关信息，所以这里要将relay log的自动清除设置为OFF，采用手动清除relay log的方式。\r\n</p>\r\n<p>\r\n	在默认情况下，从服务器上的中继日志会在SQL线程执行完毕后被自动删除。但是在MHA环境中，这些中继日志在恢复其他从服务器时可能会被用到，因此需要禁用\r\n</p>\r\n<p>\r\n	中继日志的自动删除功能。定期清除中继日志需要考虑到复制延时的问题。在ext3的文件系统下，删除大的文件需要一定的时间，会导致严重的复制延时。为了避\r\n</p>\r\n<p>\r\n	免复制延时，需要暂时为中继日志创建硬链接，因为在linux系统中通过硬链接删除大文件速度会很快。（在mysql数据库中，删除大表时，通常也采用建立硬链接的方式）\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MHA节点中包含了pure_relay_logs命令工具，它可以为中继日志创建硬链接，执行SET GLOBAL relay_log_purge=1,等待几秒钟以便SQL线程切换到新的中继日志，\r\n</p>\r\n<p>\r\n	再执行SET GLOBAL relay_log_purge=0。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	pure_relay_logs脚本参数如下所示：\r\n</p>\r\n<p>\r\n	--user mysql            用户名\r\n</p>\r\n<p>\r\n	--password mysql        密码\r\n</p>\r\n<p>\r\n	--port                  端口号\r\n</p>\r\n<p>\r\n	--workdir               指定创建relay log的硬链接的位置，默认是/var/tmp，由于系统不同分区创建硬链接文件会失败，故需要执行硬链接具体位置，成功执行脚本后，硬链接的中继日志文件被删除\r\n</p>\r\n<p>\r\n	--disable_relay_log_purge     默认情况下，如果relay_log_purge=1，脚本会什么都不清理，自动退出，通过设定这个参数，当relay_log_purge=1的情况下会将relay_log_purge设置为0。清理relay log之后，最后将参数设置为OFF。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	设置定期清理relay脚本（在两台slave节点上操作）\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# vim /root/purge_relay_log.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	user=root\r\n</p>\r\n<p>\r\n	passwd=123456\r\n</p>\r\n<p>\r\n	port=3306\r\n</p>\r\n<p>\r\n	host=localhost\r\n</p>\r\n<p>\r\n	log_dir=\'/data/masterha/log\'\r\n</p>\r\n<p>\r\n	work_dir=\'/data\'\r\n</p>\r\n<p>\r\n	purge=\'/usr/local/bin/purge_relay_logs\'\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if [ ! -d $log_dir ]\r\n</p>\r\n<p>\r\n	then\r\n</p>\r\n<p>\r\n	mkdir $log_dir -p\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	$purge --user=$user --host=$host --password=$passwd --disable_relay_log_purge --port=$port --workdir=$work_dir &gt;&gt; $log_dir/purge_relay_logs.log 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# chmod 755 /root/purge_relay_log.sh\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	添加到crontab定期执行\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# crontab -e\r\n</p>\r\n<p>\r\n	0 4 * * * /bin/bash /root/purge_relay_log.sh\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	purge_relay_logs脚本删除中继日志不会阻塞SQL线程。下面手动执行看看什么情况。\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# /usr/local/bin/purge_relay_logs --user=root --host=localhost --password=123456 --disable_relay_log_purge --port=3306 --workdir=/data\r\n</p>\r\n<p>\r\n	2017-05-31 23:27:13: purge_relay_logs script started.\r\n</p>\r\n<p>\r\n	Found relay_log.info: /data/mysql/data/relay-log.info\r\n</p>\r\n<p>\r\n	Opening /data/mysql/data/mysql-relay-bin.000002 ..\r\n</p>\r\n<p>\r\n	Opening /data/mysql/data/mysql-relay-bin.000003 ..\r\n</p>\r\n<p>\r\n	Executing SET GLOBAL relay_log_purge=1; FLUSH LOGS; sleeping a few seconds so that SQL thread can delete older relay log files (if it keeps up); SET GLOBAL relay_log_purge=0; .. ok.\r\n</p>\r\n<p>\r\n	2017-05-31 23:27:17: All relay log purging operations succeeded.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# ll /data/masterha/log/\r\n</p>\r\n<p>\r\n	总用量 4\r\n</p>\r\n<p>\r\n	-rw-r--r--. 1 root root 905 5月  31 23:26 purge_relay_logs.log\r\n</p>\r\n<p>\r\n	5.5）检查SSH配置\r\n</p>\r\n<p>\r\n	检查MHA Manger到所有MHA Node的SSH连接状态：\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_ssh --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [info] Reading application default configuration from /etc/masterha/app1.cnf..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [info] Reading server configuration from /etc/masterha/app1.cnf..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [info] Starting SSH connection tests..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [debug]\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [debug]  Connecting via SSH from root@182.48.115.236(182.48.115.236:22) to root@182.48.115.237(182.48.115.237:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:02 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:02 2017 - [debug]  Connecting via SSH from root@182.48.115.236(182.48.115.236:22) to root@182.48.115.238(182.48.115.238:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:03 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [debug]\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:01 2017 - [debug]  Connecting via SSH from root@182.48.115.237(182.48.115.237:22) to root@182.48.115.236(182.48.115.236:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:03 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:03 2017 - [debug]  Connecting via SSH from root@182.48.115.237(182.48.115.237:22) to root@182.48.115.238(182.48.115.238:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [debug]\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:02 2017 - [debug]  Connecting via SSH from root@182.48.115.238(182.48.115.238:22) to root@182.48.115.236(182.48.115.236:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:03 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:03 2017 - [debug]  Connecting via SSH from root@182.48.115.238(182.48.115.238:22) to root@182.48.115.237(182.48.115.237:22)..\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [debug]   ok.\r\n</p>\r\n<p>\r\n	Wed May 31 23:06:04 2017 - [info] All SSH connection tests passed successfully.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	可以看见各个节点ssh验证都是ok的。\r\n</p>\r\n<p>\r\n	5.6）使用mha工具check检查repl环境\r\n</p>\r\n<p>\r\n	通过masterha_check_repl脚本查看整个mysql集群的复制状态\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_repl --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [info] Reading application default configuration from /etc/masterha/app1.cnf..\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [info] Reading server configuration from /etc/masterha/app1.cnf..\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [info] MHA::MasterMonitor version 0.56.\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln301] Got MySQL error when connecting 182.48.115.237(182.48.115.237:3306) :1045:Access denied for user \'root\'@\'182.48.115.238\' (using password: NO), but this is not a MySQL crash. Check MySQL server settings.\r\n</p>\r\n<p>\r\n	at /usr/local/share/perl5/MHA/ServerManager.pm line 297\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln301] Got MySQL error when connecting 182.48.115.236(182.48.115.236:3306) :1045:Access denied for user \'root\'@\'182.48.115.238\' (using password: NO), but this is not a MySQL crash. Check MySQL server settings.\r\n</p>\r\n<p>\r\n	at /usr/local/share/perl5/MHA/ServerManager.pm line 297\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln301] Got MySQL error when connecting 182.48.115.238(182.48.115.238:3306) :1045:Access denied for user \'root\'@\'182.48.115.238\' (using password: NO), but this is not a MySQL crash. Check MySQL server settings.\r\n</p>\r\n<p>\r\n	at /usr/local/share/perl5/MHA/ServerManager.pm line 297\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/ServerManager.pm, ln309] Got fatal error, stopping operations\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln424] Error happened on checking configurations.  at /usr/local/share/perl5/MHA/MasterMonitor.pm line 326\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [error][/usr/local/share/perl5/MHA/MasterMonitor.pm, ln523] Error happened on monitoring servers.\r\n</p>\r\n<p>\r\n	Wed May 31 23:43:43 2017 - [info] Got exit code 1 (Not master dead).\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MySQL Replication Health is NOT OK!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现上面的复制环节是不ok的！！！\r\n</p>\r\n<p>\r\n	原因是通过root用户远程连接节点的mysql不通\r\n</p>\r\n<p>\r\n	..............................................................................................................\r\n</p>\r\n<p>\r\n	解决办法：在三个节点机器上的mysql上授权，允许182.48.115.％的机器通过root用户无密码登陆，即\r\n</p>\r\n<p>\r\n	mysql&gt; update mysql.user set password=password(\"\") where user=\"root\" and host=\"182.48.115.%\";   //如果没有这个权限，就grant命令创建这个用户权限\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; select user,host,password from mysql.user;\r\n</p>\r\n<p>\r\n	+---------+--------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	| user    | host         | password                                  |\r\n</p>\r\n<p>\r\n	+---------+--------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	| root    | 182.48.115.% |                                           |\r\n</p>\r\n<p>\r\n	+---------+--------------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	11 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	..............................................................................................................\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后再次通过masterha_check_repl脚本查看整个mysql集群的复制状态\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_repl --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	..............................\r\n</p>\r\n<p>\r\n	Bareword \"FIXME_xxx\" not allowed while \"strict subs\" in use at /usr/local/bin/master_ip_failover line 93.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	还是出现如上报错，原因是：\r\n</p>\r\n<p>\r\n	原来Failover两种方式：一种是虚拟IP地址，一种是全局配置文件。MHA并没有限定使用哪一种方式，而是让用户自己选择，虚拟IP地址的方式会牵扯到其它的软件,比如keepalive软件，而且还要修改脚本master_ip_failover。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解决办法如下：\r\n</p>\r\n<p>\r\n	添加软连接（所有节点）：\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# ln -s /usr/local/mysql/bin/mysqlbinlog /usr/local/bin/mysqlbinlog\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# ln -s /usr/local/mysql/bin/mysql /usr/local/bin/mysql\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	先暂时注释掉管理节点的/etc/masterha/app1.cnf文件中的master_ip_failover_script= /usr/local/bin/master_ip_failover这个选项。\r\n</p>\r\n<p>\r\n	后面引入keepalived后和修改该脚本以后再开启该选项。\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# cat /etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	#master_ip_failover_script= /usr/local/bin/master_ip_failover\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	最后在通过masterha_check_repl脚本查看整个mysql集群的复制状态\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_repl --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info] Reading application default configuration from /etc/masterha/app1.cnf..\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info]  read_only=1 is not set on slave 182.48.115.237(182.48.115.237:3306).\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [warning]  relay_log_purge=0 is not set on slave 182.48.115.237(182.48.115.237:3306).\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info]  read_only=1 is not set on slave 182.48.115.238(182.48.115.238:3306).\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [warning]  relay_log_purge=0 is not set on slave 182.48.115.238(182.48.115.238:3306).\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info] Checking replication filtering settings..\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info]  binlog_do_db= , binlog_ignore_db= mysql\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info]  Replication filtering check ok.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info] GTID (with auto-pos) is not supported\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:20:58 2017 - [info] Starting SSH connection tests..\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:02 2017 - [info] All SSH connection tests passed successfully.\r\n</p>\r\n<p>\r\n	...........\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [info] Checking replication health on 182.48.115.237..\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [info]  ok.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [info] Checking replication health on 182.48.115.238..\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [info]  ok.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [warning] master_ip_failover_script is not defined.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [warning] shutdown_script is not defined.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:21:07 2017 - [info] Got exit code 0 (Not master dead).\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MySQL Replication Health is OK.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这个时候，发现整个复制环境状况是ok的了！！\r\n</p>\r\n<p>\r\n	6）管理mha操作6.1）检查MHA Manager的状态\r\n</p>\r\n<p>\r\n	通过master_check_status脚本查看Manager的状态\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_status --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	app1 is stopped(2:NOT_RUNNING).\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：如果正常，会显示\"PING_OK\"，否则会显示\"NOT_RUNNING\"，这代表MHA监控没有开启\r\n</p>\r\n<p>\r\n	6.2）开启MHA Manager监控\r\n</p>\r\n<p>\r\n	使用下面命令放在后台执行启动动作\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# nohup masterha_manager --conf=/etc/masterha/app1.cnf --remove_dead_master_conf --ignore_last_failover &lt; /dev/null &gt; /var/log/masterha/app1/manager.log 2&gt;&amp;1 &amp;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动参数介绍：\r\n</p>\r\n<p>\r\n	--remove_dead_master_conf      该参数代表当发生主从切换后，老的主库的ip将会从配置文件中移除。\r\n</p>\r\n<p>\r\n	--manger_log                   日志存放位置\r\n</p>\r\n<p>\r\n	--ignore_last_failover         在缺省情况下，如果MHA检测到连续发生宕机，且两次宕机间隔不足8小时的话，则不会进行Failover，之所以这样限制是为了\r\n</p>\r\n<p>\r\n	避免ping-pong效应。该参数代表忽略上次MHA触发切换产生的文件，默认情况下，MHA发生切换后会在日志目录，也就是上面我\r\n</p>\r\n<p>\r\n	设置的/data产生app1.failover.complete文件，下次再次切换的时候如果发现该目录下存在该文件将不允许触发切换，除非\r\n</p>\r\n<p>\r\n	在第一次切换后收到删除该文件，为了方便，这里设置为--ignore_last_failover。\r\n</p>\r\n<p>\r\n	再次查看MHA Manager监控是否正常：\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_status --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	app1 (pid:2542) is running(0:PING_OK), master:182.48.115.236\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	可以看见已经在监控了，而且master的主机为182.48.115.236\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看启动日志\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# tail -n20 /var/log/masterha/app1/manager.log\r\n</p>\r\n<p>\r\n	Checking slave recovery environment settings..\r\n</p>\r\n<p>\r\n	Opening /data/mysql/data/relay-log.info ... ok.\r\n</p>\r\n<p>\r\n	Relay log found at /data/mysql/data, up to mysql-relay-bin.000006\r\n</p>\r\n<p>\r\n	Temporary relay log file is /data/mysql/data/mysql-relay-bin.000006\r\n</p>\r\n<p>\r\n	Testing mysql connection and privileges..Warning: Using a password on the command line interface can be insecure.\r\n</p>\r\n<p>\r\n	done.\r\n</p>\r\n<p>\r\n	Testing mysqlbinlog output.. done.\r\n</p>\r\n<p>\r\n	Cleaning up test file(s).. done.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [info] Slaves settings check done.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [info]\r\n</p>\r\n<p>\r\n	182.48.115.236(182.48.115.236:3306) (current master)\r\n</p>\r\n<p>\r\n	+--182.48.115.237(182.48.115.237:3306)\r\n</p>\r\n<p>\r\n	+--182.48.115.238(182.48.115.238:3306)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [warning] master_ip_failover_script is not defined.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [warning] shutdown_script is not defined.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [info] Set master ping interval 1 seconds.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [warning] secondary_check_script is not defined. It is highly recommended setting it to check master reachability from two or more routes.\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [info] Starting ping health check on 182.48.115.236(182.48.115.236:3306)..\r\n</p>\r\n<p>\r\n	Thu Jun  1 00:37:29 2017 - [info] Ping(SELECT) succeeded, waiting until MySQL doesn\'t respond..\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	其中\"Ping(SELECT) succeeded, waiting until MySQL doesn\'t respond..\"说明整个系统已经开始监控了。\r\n</p>\r\n<p>\r\n	6.3）关闭MHA Manage监控\r\n</p>\r\n<p>\r\n	关闭很简单，使用masterha_stop命令完成。\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_stop --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	Stopped app1 successfully.\r\n</p>\r\n<p>\r\n	[1]+  Exit 1                  nohup masterha_manager --conf=/etc/masterha/app1.cnf --remove_dead_master_conf --ignore_last_failover &lt; /dev/null &gt; /var/log/masterha/app1/manager.log 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]#\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看MHA Manager监控，发现已关闭\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_status --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	app1 is stopped(2:NOT_RUNNING).\r\n</p>\r\n<p>\r\n	7）配置VIPvip配置可以采用两种方式，一种通过keepalived的方式管理虚拟ip浮动；另外一种通过脚本方式启动虚拟ip的方式（即不需要keepalived或者heartbeat类似的软件）。\r\n</p>\r\n<p>\r\n	第一种方式：通过keepalive的方式管理vip\r\n</p>\r\n<p>\r\n	7.1）下载软件进行并进行安装（在两台master上都要安装，准确的说一台是master（182.48.115.236）；另外一台是备选master（182.48.115.237），在没有切换以前是slave)\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# yum install -y openssl-devel\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# wget http://www.keepalived.org/software/keepalived-1.3.5.tar.gz\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# tar -zvxf keepalived-1.3.5.tar.gz\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# cd keepalived-1.3.5\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# ./configure --prefix=/usr/local/keepalived\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# cp keepalived/etc/init.d/keepalived /etc/init.d/\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# mkdir /etc/keepalived\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/\r\n</p>\r\n<p>\r\n	[root@Node_Master keepalived-1.3.5]# cp /usr/local/keepalived/sbin/keepalived /usr/sbin/\r\n</p>\r\n<p>\r\n	7.2）keepalived配置\r\n</p>\r\n<p>\r\n	------------在master上配置（182.48.115.236节点上的配置）------------------\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	wangshibo@huanqiu.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@huanqiu.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id MySQL-HA\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface eth1\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 150\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	nopreempt\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.48.115.239\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	其中router_id MySQL HA表示设定keepalived组的名称，将182.48.115.239这个虚拟ip绑定到该主机的eth1网卡上，并且设置了状态为backup模式，\r\n</p>\r\n<p>\r\n	将keepalived的模式设置为非抢占模式（nopreempt），priority 150表示设置的优先级为150。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	------------在candicate master上配置（182.48.115.237节点上的配置）------------------\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	wangshibo@huanqiu.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@huanqiu.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id MySQL-HA\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface eth1\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 120\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	nopreempt\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.48.115.239\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	7.3）启动keepalived服务\r\n</p>\r\n<p>\r\n	--------------在master上启动并查看日志----------------\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:5f:58:dc brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.236/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.239/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe5f:58dc/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Node_Master ~]# tail -100 /var/log/messages\r\n</p>\r\n<p>\r\n	..........\r\n</p>\r\n<p>\r\n	Jun  1 02:12:10 percona1 Keepalived_vrrp[10329]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.48.115.239\r\n</p>\r\n<p>\r\n	Jun  1 02:12:10 percona1 Keepalived_vrrp[10329]: Sending gratuitous ARP on eth0 for 182.48.115.239\r\n</p>\r\n<p>\r\n	Jun  1 02:12:10 percona1 Keepalived_vrrp[10329]: Sending gratuitous ARP on eth0 for 182.48.115.239\r\n</p>\r\n<p>\r\n	Jun  1 02:12:10 percona1 Keepalived_vrrp[10329]: Sending gratuitous ARP on eth0 for 182.48.115.239\r\n</p>\r\n<p>\r\n	Jun  1 02:12:10 percona1 Keepalived_vrrp[10329]: Sending gratuitous ARP on eth0 for 182.48.115.239\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现vip资源已经绑定到182.48.115.236这个master节点机上了\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	--------------在candicate master上启动----------------\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	[root@Node_Slave ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:1b:6e:53 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.237/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe1b:6e53/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	.....................................................................\r\n</p>\r\n<p>\r\n	从上面的信息可以看到keepalived已经配置成功。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	上面两台服务器的keepalived都设置为了BACKUP模式，在keepalived中2种模式，分别是master-&gt;backup模式和backup-&gt;backup模式。这两种模式有很大区别。\r\n</p>\r\n<p>\r\n	在master-&gt;backup模式下，一旦主库宕机，虚拟ip会自动漂移到从库，当主库修复后，keepalived启动后，还会把虚拟ip抢占过来，即使设置了非抢占模式（nopreempt）\r\n</p>\r\n<p>\r\n	抢占ip的动作也会发生。在backup-&gt;backup模式下，当主库宕机后虚拟ip会自动漂移到从库上，当原主库恢复和keepalived服务启动后，并不会抢占新主的虚拟ip，即使是\r\n</p>\r\n<p>\r\n	优先级高于从库的优先级别，也不会发生抢占。为了减少ip漂移次数，通常是把修复好的主库当做新的备库。\r\n</p>\r\n<p>\r\n	7.4）MHA引入keepalived（MySQL服务进程挂掉时通过MHA 停止keepalived）\r\n</p>\r\n<p>\r\n	要想把keepalived服务引入MHA，只需要修改切换是触发的脚本文件master_ip_failover即可，在该脚本中添加在master发生宕机时对keepalived的处理。\r\n</p>\r\n<p>\r\n	编辑脚本/usr/local/bin/master_ip_failover，修改后如下:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# vim /usr/local/bin/master_ip_failover\r\n</p>\r\n<p>\r\n	#!/usr/bin/env perl\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	use strict;\r\n</p>\r\n<p>\r\n	use warnings FATAL =&gt; \'all\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	use Getopt::Long;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my (\r\n</p>\r\n<p>\r\n	$command,          $ssh_user,        $orig_master_host, $orig_master_ip,\r\n</p>\r\n<p>\r\n	$orig_master_port, $new_master_host, $new_master_ip,    $new_master_port\r\n</p>\r\n<p>\r\n	);\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $vip = \'182.48.115.239\';\r\n</p>\r\n<p>\r\n	my $ssh_start_vip = \"/etc/init.d/keepalived start\";\r\n</p>\r\n<p>\r\n	my $ssh_stop_vip = \"/etc/init.d/keepalived stop\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	GetOptions(\r\n</p>\r\n<p>\r\n	\'command=s\'          =&gt; \\$command,\r\n</p>\r\n<p>\r\n	\'ssh_user=s\'         =&gt; \\$ssh_user,\r\n</p>\r\n<p>\r\n	\'orig_master_host=s\' =&gt; \\$orig_master_host,\r\n</p>\r\n<p>\r\n	\'orig_master_ip=s\'   =&gt; \\$orig_master_ip,\r\n</p>\r\n<p>\r\n	\'orig_master_port=i\' =&gt; \\$orig_master_port,\r\n</p>\r\n<p>\r\n	\'new_master_host=s\'  =&gt; \\$new_master_host,\r\n</p>\r\n<p>\r\n	\'new_master_ip=s\'    =&gt; \\$new_master_ip,\r\n</p>\r\n<p>\r\n	\'new_master_port=i\'  =&gt; \\$new_master_port,\r\n</p>\r\n<p>\r\n	);\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	exit &amp;main();\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sub main {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print \"\\n\\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\\n\\n\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if ( $command eq \"stop\" || $command eq \"stopssh\" ) {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $exit_code = 1;\r\n</p>\r\n<p>\r\n	eval {\r\n</p>\r\n<p>\r\n	print \"Disabling the VIP on old master: $orig_master_host \\n\";\r\n</p>\r\n<p>\r\n	&amp;stop_vip();\r\n</p>\r\n<p>\r\n	$exit_code = 0;\r\n</p>\r\n<p>\r\n	};\r\n</p>\r\n<p>\r\n	if ($@) {\r\n</p>\r\n<p>\r\n	warn \"Got Error: $@\\n\";\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	elsif ( $command eq \"start\" ) {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $exit_code = 10;\r\n</p>\r\n<p>\r\n	eval {\r\n</p>\r\n<p>\r\n	print \"Enabling the VIP - $vip on the new master - $new_master_host \\n\";\r\n</p>\r\n<p>\r\n	&amp;start_vip();\r\n</p>\r\n<p>\r\n	$exit_code = 0;\r\n</p>\r\n<p>\r\n	};\r\n</p>\r\n<p>\r\n	if ($@) {\r\n</p>\r\n<p>\r\n	warn $@;\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	elsif ( $command eq \"status\" ) {\r\n</p>\r\n<p>\r\n	print \"Checking the Status of the script.. OK \\n\";\r\n</p>\r\n<p>\r\n	#`ssh $ssh_user\\@cluster1 \\\" $ssh_start_vip \\\"`;\r\n</p>\r\n<p>\r\n	exit 0;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	else {\r\n</p>\r\n<p>\r\n	&amp;usage();\r\n</p>\r\n<p>\r\n	exit 1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# A simple system call that enable the VIP on the new master\r\n</p>\r\n<p>\r\n	sub start_vip() {\r\n</p>\r\n<p>\r\n	`ssh $ssh_user\\@$new_master_host \\\" $ssh_start_vip \\\"`;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# A simple system call that disable the VIP on the old_master\r\n</p>\r\n<p>\r\n	sub stop_vip() {\r\n</p>\r\n<p>\r\n	return 0  unless  ($ssh_user);\r\n</p>\r\n<p>\r\n	`ssh $ssh_user\\@$orig_master_host \\\" $ssh_stop_vip \\\"`;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sub usage {\r\n</p>\r\n<p>\r\n	print\r\n</p>\r\n<p>\r\n	\"Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\\n\";\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	现在已经修改这个脚本了，现在打开在上面提到过的参数，再检查集群状态，看是否会报错\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# grep \'master_ip_failover_script\' /etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	master_ip_failover_script= /usr/local/bin/master_ip_failover\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_repl --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	Checking the Status of the script.. OK\r\n</p>\r\n<p>\r\n	Thu Jun  1 03:31:57 2017 - [info]  OK.\r\n</p>\r\n<p>\r\n	Thu Jun  1 03:31:57 2017 - [warning] shutdown_script is not defined.\r\n</p>\r\n<p>\r\n	Thu Jun  1 03:31:57 2017 - [info] Got exit code 0 (Not master dead).\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MySQL Replication Health is OK.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	可以看出复制情况正常！\r\n</p>\r\n<p>\r\n	/usr/local/bin/master_ip_failover添加或者修改的内容意思是当主库数据库发生故障时，会触发MHA切换，MHA Manager会停掉主库上的keepalived服务，\r\n</p>\r\n<p>\r\n	触发虚拟ip漂移到备选从库，从而完成切换。当然可以在keepalived里面引入脚本，这个脚本监控mysql是否正常运行，如果不正常，则调用该脚本杀掉keepalived进程。\r\n</p>\r\n<p>\r\n	第二种方式：通过脚本的方式管理VIP这里是修改/usr/local/bin/master_ip_failover，修改完成后内容如下。还需要手动在master服务器上绑定一个vip\r\n</p>\r\n<p>\r\n	1）现在master节点上绑定vip\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# ifconfig eth0:0 182.48.115.239/27            //本机子网掩码是27，一般都是24\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:5F:58:DC\r\n</p>\r\n<p>\r\n	inet addr:182.48.115.236  Bcast:182.48.115.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe5f:58dc/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:25505 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:3358 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:3254957 (3.1 MiB)  TX bytes:482420 (471.1 KiB)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	eth0:0    Link encap:Ethernet  HWaddr 52:54:00:5F:58:DC\r\n</p>\r\n<p>\r\n	inet addr:182.48.115.239  Bcast:182.48.115.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lo        Link encap:Local Loopback\r\n</p>\r\n<p>\r\n	inet addr:127.0.0.1  Mask:255.0.0.0\r\n</p>\r\n<p>\r\n	inet6 addr: ::1/128 Scope:Host\r\n</p>\r\n<p>\r\n	UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:0 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:0\r\n</p>\r\n<p>\r\n	RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)\r\n</p>\r\n<p>\r\n	2）manager节点修改/usr/local/bin/master_ip_failover\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# cat /usr/local/bin/master_ip_failover\r\n</p>\r\n<p>\r\n	#!/usr/bin/env perl\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	use strict;\r\n</p>\r\n<p>\r\n	use warnings FATAL =&gt; \'all\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	use Getopt::Long;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my (\r\n</p>\r\n<p>\r\n	$command,          $ssh_user,        $orig_master_host, $orig_master_ip,\r\n</p>\r\n<p>\r\n	$orig_master_port, $new_master_host, $new_master_ip,    $new_master_port\r\n</p>\r\n<p>\r\n	);\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $vip = \'182.48.115.239/27\';\r\n</p>\r\n<p>\r\n	my $key = \'1\';\r\n</p>\r\n<p>\r\n	my $ssh_start_vip = \"/sbin/ifconfig eth0:$key $vip\";\r\n</p>\r\n<p>\r\n	my $ssh_stop_vip = \"/sbin/ifconfig eth0:$key down\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	GetOptions(\r\n</p>\r\n<p>\r\n	\'command=s\'          =&gt; \\$command,\r\n</p>\r\n<p>\r\n	\'ssh_user=s\'         =&gt; \\$ssh_user,\r\n</p>\r\n<p>\r\n	\'orig_master_host=s\' =&gt; \\$orig_master_host,\r\n</p>\r\n<p>\r\n	\'orig_master_ip=s\'   =&gt; \\$orig_master_ip,\r\n</p>\r\n<p>\r\n	\'orig_master_port=i\' =&gt; \\$orig_master_port,\r\n</p>\r\n<p>\r\n	\'new_master_host=s\'  =&gt; \\$new_master_host,\r\n</p>\r\n<p>\r\n	\'new_master_ip=s\'    =&gt; \\$new_master_ip,\r\n</p>\r\n<p>\r\n	\'new_master_port=i\'  =&gt; \\$new_master_port,\r\n</p>\r\n<p>\r\n	);\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	exit &amp;main();\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sub main {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print \"\\n\\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\\n\\n\";\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if ( $command eq \"stop\" || $command eq \"stopssh\" ) {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $exit_code = 1;\r\n</p>\r\n<p>\r\n	eval {\r\n</p>\r\n<p>\r\n	print \"Disabling the VIP on old master: $orig_master_host \\n\";\r\n</p>\r\n<p>\r\n	&amp;stop_vip();\r\n</p>\r\n<p>\r\n	$exit_code = 0;\r\n</p>\r\n<p>\r\n	};\r\n</p>\r\n<p>\r\n	if ($@) {\r\n</p>\r\n<p>\r\n	warn \"Got Error: $@\\n\";\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	elsif ( $command eq \"start\" ) {\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	my $exit_code = 10;\r\n</p>\r\n<p>\r\n	eval {\r\n</p>\r\n<p>\r\n	print \"Enabling the VIP - $vip on the new master - $new_master_host \\n\";\r\n</p>\r\n<p>\r\n	&amp;start_vip();\r\n</p>\r\n<p>\r\n	$exit_code = 0;\r\n</p>\r\n<p>\r\n	};\r\n</p>\r\n<p>\r\n	if ($@) {\r\n</p>\r\n<p>\r\n	warn $@;\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	exit $exit_code;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	elsif ( $command eq \"status\" ) {\r\n</p>\r\n<p>\r\n	print \"Checking the Status of the script.. OK \\n\";\r\n</p>\r\n<p>\r\n	exit 0;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	else {\r\n</p>\r\n<p>\r\n	&amp;usage();\r\n</p>\r\n<p>\r\n	exit 1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sub start_vip() {\r\n</p>\r\n<p>\r\n	`ssh $ssh_user\\@$new_master_host \\\" $ssh_start_vip \\\"`;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	sub stop_vip() {\r\n</p>\r\n<p>\r\n	return 0  unless  ($ssh_user);\r\n</p>\r\n<p>\r\n	`ssh $ssh_user\\@$orig_master_host \\\" $ssh_stop_vip \\\"`;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sub usage {\r\n</p>\r\n<p>\r\n	print\r\n</p>\r\n<p>\r\n	\"Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\\n\";\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意要将/etc/masterha/app1.cnf文件中的master_ip_failover_script注释打开\r\n</p>\r\n<p>\r\n	为了防止脑裂发生，推荐生产环境采用脚本的方式来管理虚拟ip，而不是使用keepalived来完成。到此为止，基本MHA集群已经配置完毕。\r\n</p>\r\n<p>\r\n	接下来就是实际的测试环节了。通过一些测试来看一下MHA到底是如何进行工作的。\r\n</p>\r\n<p>\r\n	8）failover故障切换　1）自动切换（必须先启动MHA Manager，否则无法自动切换。（当然手动切换不需要开启MHA Manager监控））\r\n</p>\r\n<p>\r\n	1）在master主库上使用sysbench生成测试数据\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# yum install sysbench -y\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在主库（182.48.115.236）上进行sysbench数据生成，在sbtest库下生成sbtest表，共100W记录。\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# sysbench --test=oltp --oltp-table-size=1000000 --oltp-read-only=off --init-rng=on --num-threads=16 --max-requests=0 --oltp-dist-type=uniform --max-time=1800 --mysql-user=root --mysql-socket=/local/mysql/var/mysql.sock --mysql-password=123456 --db-driver=mysql --mysql-table-engine=innodb --oltp-test-mode=complex prepare\r\n</p>\r\n<p>\r\n	1.2）在candicate master（182.48.115.237）上停掉slave sql线程，模拟主从延时。\r\n</p>\r\n<p>\r\n	mysql&gt; stop slave io_thread;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.08 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：另外一台slave没有停止io线程，所以还在继续接收日志。\r\n</p>\r\n<p>\r\n	1.3）模拟sysbench压力测试\r\n</p>\r\n<p>\r\n	在主库上（182.48.115.236）进行压力测试，持续时间为3分钟，产生大量的binlog\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# sysbench --test=oltp --oltp-table-size=1000000 --oltp-read-only=off --init-rng=on --num-threads=16 --max-requests=0 --oltp-dist-type=uniform --max-time=180 --mysql-user=root --mysql-socket=/local/mysql/var/mysql.sock --mysql-password=123456 --db-driver=mysql --mysql-table-engine=innodb --oltp-test-mode=complex run\r\n</p>\r\n<p>\r\n	1.4）开启在candicate master（182.48.115.237）上的IO线程，追赶落后于master的binlog。\r\n</p>\r\n<p>\r\n	mysql&gt; start slave io_thread;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	1.5）杀掉主库（182.48.115.236）mysql进程，模拟主库发生故障，进行自动failover操作。\r\n</p>\r\n<p>\r\n	[root@Master_node ~]# pkill -9 mysqld\r\n</p>\r\n<p>\r\n	1.6）查看MHA切换日志，了解整个切换过程。在manager管理节点（182.48.115.238）上查看日志\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# cat /var/log/masterha/app1/manager.log\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	----- Failover Report -----\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	app1: MySQL Master failover 182.48.115.236 to 182.48.115.237 succeeded\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Master 182.48.115.236 is down!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Check MHA Manager logs at server01:/var/log/masterha/app1/manager.log for details.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Started automated(non-interactive) failover.\r\n</p>\r\n<p>\r\n	Invalidated master IP address on 182.48.115.236.\r\n</p>\r\n<p>\r\n	The latest slave 182.48.115.237(182.48.115.237:3306) has all relay logs for recovery.\r\n</p>\r\n<p>\r\n	Selected 182.48.115.237 as a new master.\r\n</p>\r\n<p>\r\n	182.48.115.237: OK: Applying all logs succeeded.\r\n</p>\r\n<p>\r\n	182.48.115.237: OK: Activated master IP address.\r\n</p>\r\n<p>\r\n	192.168.0.70: This host has the latest relay log events.\r\n</p>\r\n<p>\r\n	Generating relay diff files from the latest slave succeeded.\r\n</p>\r\n<p>\r\n	192.168.0.70: OK: Applying all logs succeeded. Slave started, replicating from 182.48.115.237.\r\n</p>\r\n<p>\r\n	182.48.115.237: Resetting slave info succeeded.\r\n</p>\r\n<p>\r\n	Master failover to 182.48.115.237(182.48.115.237:3306) completed successfully.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	看到最后的Master failover to 182.48.115.237(182.48.115.237:3306) completed successfully.说明备选master现在已经上位了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	从上面的输出可以看出整个MHA的切换过程，共包括以下的步骤：\r\n</p>\r\n<p>\r\n	1）配置文件检查阶段，这个阶段会检查整个集群配置文件配置\r\n</p>\r\n<p>\r\n	2）宕机的master处理，这个阶段包括虚拟ip摘除操作，主机关机操作（这个我这里还没有实现，需要研究）\r\n</p>\r\n<p>\r\n	3）复制dead maste和最新slave相差的relay log，并保存到MHA Manger具体的目录下\r\n</p>\r\n<p>\r\n	4）识别含有最新更新的slave\r\n</p>\r\n<p>\r\n	5）应用从master保存的二进制日志事件（binlog events）\r\n</p>\r\n<p>\r\n	6）提升一个slave为新的master进行复制\r\n</p>\r\n<p>\r\n	7）使其他的slave连接新的master进行复制\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	最后启动MHA Manger监控，查看集群里面现在谁是master\r\n</p>\r\n<p>\r\n	[root@Manager_Slave ~]# masterha_check_status --conf=/etc/masterha/app1.cnf\r\n</p>\r\n<p>\r\n	app1 (pid:13301) is running(0:PING_OK), master:182.48.115.237\r\n</p>\r\n<p>\r\n	2）手动Failover（MHA Manager必须没有运行）\r\n</p>\r\n<p>\r\n	手动f\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('4a46066e-89c0-4b3a-998a-d319dc2a5978','nginx负载均衡、rewrite重写规则及多server反代配置梳理','nginx负载均衡、rewrite重写规则及多server反代配置梳理','<p>\r\n	Nginx除了可以用作web服务器外，他还可以用来做高性能的反向代理服务器，它能提供稳定高效的负载均衡解决方案。nginx可以用轮询、IP哈希、URL哈希等方式调度后端服务器，同时也能提供健康检查功能。目前有众多公司均已经部署使用nginx实现基于七层的负载均衡功能。\r\n</p>\r\n<p>\r\n	1）Nginx负载均衡为了实现Nginx的反向代理以及负载均衡功能，应用中需要用到两个模块，HttpProxyModule和HttpUpstreamModule模块；其中HttpProxyModule模块的作用是将用户的数据请求转发到其他服务器上，HttpUpstreamModule模块是提供负载均衡技术。\r\n</p>\r\n<p>\r\n	Nginx目前提供的负载均衡算法：a）ngx_http_upstream_round_robin：加权轮询，可均分请求，是默认算法，集成在框架中。b）ngx_http_upstream_ip_hash_module：IP哈希，可保持会话。c）ngx_http_upstream_least_conn_module：最少连接数，可均分连接。d）ngx_http_upstream_hash_module：一致性哈希，可减少缓存数据的失效。\r\n</p>\r\n<p>\r\n	nginx的upstream负载均衡目前支持的几种方式：1）轮询(默认) 默认选项，当weight不指定时，各服务器weight相同， 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\r\n</p>\r\n<p>\r\n	upstream bakend {\r\n</p>\r\n<p>\r\n	server 192.168.1.10;\r\n</p>\r\n<p>\r\n	server 192.168.1.11;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。如果后端服务器down掉，能自动剔除。 比如下面配置，则1.11服务器的访问量为1.10服务器的两倍（后端节点中配置高的服务器可以适当将weight设置大点）。\r\n</p>\r\n<p>\r\n	upstream bakend {\r\n</p>\r\n<p>\r\n	server 192.168.1.10 weight=1;\r\n</p>\r\n<p>\r\n	server 192.168.1.11 weight=2;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	3）ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题，实现session共享。如果后端服务器down掉，要手工处理。\r\n</p>\r\n<p>\r\n	upstream resinserver{\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	server 192.168.1.10:8080;\r\n</p>\r\n<p>\r\n	server 192.168.1.11:8080;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	4）fair（第三方插件） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。\r\n</p>\r\n<p>\r\n	upstream resinserver{\r\n</p>\r\n<p>\r\n	server 192.168.1.10:8080;\r\n</p>\r\n<p>\r\n	server 192.168.1.11:8080;\r\n</p>\r\n<p>\r\n	fair;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	5）url_hash（第三方插件） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器时比较有效。 在upstream中加入hash语句，hash_method是使用的hash算法。\r\n</p>\r\n<p>\r\n	upstream resinserver{\r\n</p>\r\n<p>\r\n	server 192.168.1.10:8080;\r\n</p>\r\n<p>\r\n	server 192.168.1.11:8080;\r\n</p>\r\n<p>\r\n	hash $request_uri;\r\n</p>\r\n<p>\r\n	hash_method crc32;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	设备的状态: down &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;表示单前的server暂时不参与负载 weight &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;权重,默认为1。 weight越大，负载的权重就越大。 max_fails &nbsp; &nbsp; &nbsp;允许请求失败的次数默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误 fail_timeout &nbsp; max_fails次失败后，暂停的时间。 backup &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;备用服务器, 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\r\n</p>\r\n<p>\r\n	下面是负载均衡实现原理拓扑图（多层负载）\r\n</p>\r\n<p>\r\n	Nginx反向代理模块配置方法示例说明：\r\n</p>\r\n<p>\r\n	location ~* \\.(mp3|mp4)$ {        //匹配URL以MP3或者MP4结尾的请求\r\n</p>\r\n<p>\r\n	proxy_pass http://localhost:8080        //转发到本机8080端口\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {                                    //匹配任意URL\r\n</p>\r\n<p>\r\n	proxy_pass http://localhost:8081  //转发到本机8081端口\r\n</p>\r\n<p>\r\n	proxy_set_header    X-Forwarded-For    $remote_addr    //保留用户真实IP\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location指令可以直接匹配字符串，也可以进行正则表达式匹配\r\n</p>\r\n<p>\r\n	~表示区分大小写，~*表示不区分大小写匹配，=表示精确匹配\r\n</p>\r\n<p>\r\n	proxy_pass指令可以根据location匹配的情况建立前后端的代理映射关系\r\n</p>\r\n<p>\r\n	X-Forwarded-For用于实现定义数据包头，记录用户真实IP\r\n</p>\r\n<p>\r\n	Nginx负载均衡模块配置方法示例说明：\r\n</p>\r\n<p>\r\n	upstream backend {\r\n</p>\r\n<p>\r\n	ip_hash；\r\n</p>\r\n<p>\r\n	server web1.test.com weight 1;\r\n</p>\r\n<p>\r\n	server web2.test.com weight 2;\r\n</p>\r\n<p>\r\n	server web3.test.com ;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name web.test.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://backend;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream定义后端服务器集合，backend是服务器组名\r\n</p>\r\n<p>\r\n	proxy-pass和fastcgi_pass将请求转发给一组服务器\r\n</p>\r\n<p>\r\n	ip_hash可以根据用户ip地址的hash值分配固定的后端服务器\r\n</p>\r\n<p>\r\n	2）Nginx负载均衡案例解析服务器名称 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;网路配置nginx.test.com &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eth0:111.122.155.133&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eth1:192.168.1.2web1.test.com &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eht0:192.168.1.3web2.test.com &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eth0:192.168.1.4web3.test.com &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eth0:192.168.1.5\r\n</p>\r\n<p>\r\n	3台web机器配置：\r\n</p>\r\n<p>\r\n	在web1 web2 web3上安装httpd并配置网卡。操作步骤如下：（下面是web1的操作，web2和web3的操作步骤类似。注意修改红色部分的参数）# vim /etc/sysconfig/network-scripts/ifcfg-eth0\r\n</p>\r\n<p>\r\n	DEVICE=eth0\r\n</p>\r\n<p>\r\n	BOOTPROTO=static\r\n</p>\r\n<p>\r\n	IPADDR=192.168.1.3\r\n</p>\r\n<p>\r\n	NETMASK=255.255.255.0\r\n</p>\r\n<p>\r\n	GATEWAY=192.168.1.2\r\n</p>\r\n<p>\r\n	ONBOOT=yes\r\n</p>\r\n<p>\r\n	TYPE=Ethernet\r\n</p>\r\n<p>\r\n	接着执行下面命令：\r\n</p>\r\n<p>\r\n	# service network restart\r\n</p>\r\n<p>\r\n	# yum install -y httpd\r\n</p>\r\n<p>\r\n	# iptables -F\r\n</p>\r\n<p>\r\n	# iptables -X\r\n</p>\r\n<p>\r\n	# service iptables save\r\n</p>\r\n<p>\r\n	# setenforce 0\r\n</p>\r\n<p>\r\n	# sed -i s/enforcing/disabled/g /etc/sysconfig/selinux\r\n</p>\r\n<p>\r\n	# echo \"web1 192.168.1.3\" &gt; /var/www/html/index.html\r\n</p>\r\n<p>\r\n	# service httpd restart\r\n</p>\r\n<p>\r\n	# chkconfig httpd on\r\n</p>\r\n<p>\r\n	nginx代理服务器配置\r\n</p>\r\n<p>\r\n	# vim /etc/sysconfig/network-scripts/ifcfg-eth0\r\n</p>\r\n<p>\r\n	DEVICE=eth0\r\n</p>\r\n<p>\r\n	BOOTPROTO=static\r\n</p>\r\n<p>\r\n	IPADDR=111.122.155.133\r\n</p>\r\n<p>\r\n	NETMASK=255.255.255.0\r\n</p>\r\n<p>\r\n	GATEWAY=111.122.155.0\r\n</p>\r\n<p>\r\n	ONBOOT=yes\r\n</p>\r\n<p>\r\n	TYPE=Ethernet\r\n</p>\r\n<p>\r\n	# vim /etc/sysconfig/network-scripts/ifcfg-eth1\r\n</p>\r\n<p>\r\n	DEVICE=eth1\r\n</p>\r\n<p>\r\n	BOOTPROTO=static\r\n</p>\r\n<p>\r\n	IPADDR=192.168.1.2\r\n</p>\r\n<p>\r\n	NETMASK=255.255.255.0\r\n</p>\r\n<p>\r\n	GATEWAY=192.168.1.1\r\n</p>\r\n<p>\r\n	ONBOOT=yes\r\n</p>\r\n<p>\r\n	TYPE=Ethernet\r\n</p>\r\n<p>\r\n	接着执行下面命令：\r\n</p>\r\n<p>\r\n	# service network restart\r\n</p>\r\n<p>\r\n	# iptables -F\r\n</p>\r\n<p>\r\n	# iptables -X\r\n</p>\r\n<p>\r\n	# service iptables save\r\n</p>\r\n<p>\r\n	# setenforce 0\r\n</p>\r\n<p>\r\n	# sed -i s/enforcing/disabled/g /etc/sysconfig/selinux\r\n</p>\r\n<p>\r\n	# wget http://nginx.org/download/nginx-1.6.3.tar.gz\r\n</p>\r\n<p>\r\n	# tar zxf nginx-1.6.3.tar.gz -C /usr/src/\r\n</p>\r\n<p>\r\n	# yum install gcc pcre pcre-devel openssl openssl-devel gd gd-devel perl perl-ExtUtils-Embed\r\n</p>\r\n<p>\r\n	# cd /usr/src/nginx-1.6.3/\r\n</p>\r\n<p>\r\n	# ./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_gzip_static_module --with-http_perl_module --with-mail_ssl_module\r\n</p>\r\n<p>\r\n	# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	接着修改nginx配置文件# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	user    nobody;\r\n</p>\r\n<p>\r\n	worker_processes    1;\r\n</p>\r\n<p>\r\n	error_log    logs/error.log    notice;\r\n</p>\r\n<p>\r\n	pid    logs/nginx.pid;\r\n</p>\r\n<p>\r\n	events    {\r\n</p>\r\n<p>\r\n	worker_connections    5024；\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http    {\r\n</p>\r\n<p>\r\n	include    mime.types;\r\n</p>\r\n<p>\r\n	default_type    application/octet-stream;\r\n</p>\r\n<p>\r\n	log_format    main    \'$remote_addr - $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_x_forwarded_for\" \';\r\n</p>\r\n<p>\r\n	sendfile    on;\r\n</p>\r\n<p>\r\n	tcp_nopush    on;\r\n</p>\r\n<p>\r\n	server_tokens    off;\r\n</p>\r\n<p>\r\n	keepalive_timeout    65;\r\n</p>\r\n<p>\r\n	keepalive_requests    100;\r\n</p>\r\n<p>\r\n	gzip    on;                                    //开启压缩\r\n</p>\r\n<p>\r\n	gzip_min_length    1000;                //小于1000B内容不压缩\r\n</p>\r\n<p>\r\n	gzip_buffers    16    32k;                //压缩缓存的个数和容量\r\n</p>\r\n<p>\r\n	gzip_types    text/plain    application/xml;        //指定压缩文件类型\r\n</p>\r\n<p>\r\n	gzip_comp_level    2；                    //压缩级别为2，数字越大压缩效果越好\r\n</p>\r\n<p>\r\n	client_body_buffer_size    128k；                        //允许客户端请求缓存大小\r\n</p>\r\n<p>\r\n	client_max_body_size    100m;                            //允许请求的最大文件容量\r\n</p>\r\n<p>\r\n	large-client_header_buffers    4    8k；                //\r\n</p>\r\n<p>\r\n	proxy_buffering    on;                                          //开启代理缓冲功能\r\n</p>\r\n<p>\r\n	proxy_buffer_size    8k;                                        //第一部分响应数据的缓存大小\r\n</p>\r\n<p>\r\n	proxy_buffers    8    128k;                                    //响应数据的缓存个数和容量\r\n</p>\r\n<p>\r\n	proxy_cache_path    /usr/local/nginx/cache    levels=1:2    keys_zone=one:100m    inactive=1d    max_size=2G;\r\n</p>\r\n<p>\r\n	//设置缓存目录，levels设置缓存个数，keys_zone定义缓存名字和容量，inactive定义缓存存活时间，max_size定义硬盘的缓存容量\r\n</p>\r\n<p>\r\n	proxy_connect_timeout    60s;            //与后端服务器建立TCP连接握手超时时间\r\n</p>\r\n<p>\r\n	upstream servers {\r\n</p>\r\n<p>\r\n	//ip_hash；ip_hash确保相同客户端ip使用相同的后端服务器，不适用就默认轮询\r\n</p>\r\n<p>\r\n	server    192.168.1.3:80    max_fails=3    fail_timeout=30s    weight=2;\r\n</p>\r\n<p>\r\n	server    192.168.1.4:80    max_fails=3    fail_timeout=30s    weight=2;\r\n</p>\r\n<p>\r\n	server    192.168.1.5:80    max_fails=3    fail_timeout=30s    weight=2;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen    80;\r\n</p>\r\n<p>\r\n	server_name    web.test.com;\r\n</p>\r\n<p>\r\n	access_log    logs/host.access.log    main;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://servers;\r\n</p>\r\n<p>\r\n	proxy_cache one;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $remote_addr;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}}\r\n</p>\r\n<p>\r\n	配置完成执行：\r\n</p>\r\n<p>\r\n	# echo \"/usr/local/nginx/sbin/nginx\" &gt;&gt; /etc/rc.local\r\n</p>\r\n<p>\r\n	最后浏览器访问http://192.168.1.2 或者http://111.122.155.133 刷新将分别得到不同的web页面信息\r\n</p>\r\n<p>\r\n	3）Nginx rewrite规则nginx的rewrite语法格式和apache非常相似，rewrite regex replacement [flag],其中flag可以被设置为last结束当前指令并重新搜索location匹配、break结束当前rewrite指令、redirect临时重定向302、permanent永久重定向301。\r\n</p>\r\n<p>\r\n	rewrite地址重写及return应用的语法解析：根据浏览器标识，访问资源重定向到指定文件目录,下面用IE浏览器示例：\r\n</p>\r\n<p>\r\n	if ($http_user_agent ~ MSIE ) {\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$ /msie/$1 break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	将移动客户端的请求重定向到其他服务器：\r\n</p>\r\n<p>\r\n	if    ($http_user_agent ~* \'(iphone|ipod)\' )  {\r\n</p>\r\n<p>\r\n	rewrite    ^.+    http://mobile.site.com$uri;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	用户使用POST方式请求数据时候，返回405：\r\n</p>\r\n<p>\r\n	if ($request_method = POST ) {\r\n</p>\r\n<p>\r\n	return 405;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问admin时候重定向到admin目录：\r\n</p>\r\n<p>\r\n	location /php_admin {\r\n</p>\r\n<p>\r\n	rewrite ^/php_admin/.*$ /admin permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-------------------------------------------下面详细说下nginx的rewrite重写指令用法-------------------------------------------nginx通过ngx_http_rewrite_module模块支持url重写、支持if条件判断，但不支持else。该模块需要PCRE支持，因此应在编译nginx时指定PCRE源码目录, nginx安装方法。\r\n</p>\r\n<p>\r\n	1）Nginx Rewrite 基本标记 (flags)\r\n</p>\r\n<p>\r\n	last       基本上都用这个Flag。相当于Apache里的[L]标记，表示完成rewrite，不再匹配后面的规则\r\n</p>\r\n<p>\r\n	break      中止 Rewirte，不再继续匹配\r\n</p>\r\n<p>\r\n	redirect   返回临时重定向的HTTP状态302\r\n</p>\r\n<p>\r\n	permanent  返回永久重定向的HTTP状态301。原有的url支持正则，重写的url不支持正则\r\n</p>\r\n<p>\r\n	2）正则表达式匹配，其中：\r\n</p>\r\n<p>\r\n	* ~ 为区分大小写匹配\r\n</p>\r\n<p>\r\n	* ~* 为不区分大小写匹配\r\n</p>\r\n<p>\r\n	* !~和!~* 分别为区分大小写不匹配及不区分大小写不匹配\r\n</p>\r\n<p>\r\n	3）文件及目录匹配，其中：\r\n</p>\r\n<p>\r\n	* -f 和!-f 用来判断是否存在文件\r\n</p>\r\n<p>\r\n	* -d 和!-d 用来判断是否存在目录\r\n</p>\r\n<p>\r\n	* -e 和!-e 用来判断是否存在文件或目录\r\n</p>\r\n<p>\r\n	* -x 和!-x 用来判断文件是否可执行\r\n</p>\r\n<p>\r\n	4）Nginx的一些可用的全局变量，可用做条件判断：\r\n</p>\r\n<p>\r\n	$args\r\n</p>\r\n<p>\r\n	$content_length\r\n</p>\r\n<p>\r\n	$content_type\r\n</p>\r\n<p>\r\n	$document_root\r\n</p>\r\n<p>\r\n	$document_uri\r\n</p>\r\n<p>\r\n	$host\r\n</p>\r\n<p>\r\n	$http_user_agent\r\n</p>\r\n<p>\r\n	$http_cookie\r\n</p>\r\n<p>\r\n	$limit_rate\r\n</p>\r\n<p>\r\n	$request_body_file\r\n</p>\r\n<p>\r\n	$request_method\r\n</p>\r\n<p>\r\n	$remote_addr\r\n</p>\r\n<p>\r\n	$remote_port\r\n</p>\r\n<p>\r\n	$remote_user\r\n</p>\r\n<p>\r\n	$request_filename\r\n</p>\r\n<p>\r\n	$request_uri\r\n</p>\r\n<p>\r\n	$query_string\r\n</p>\r\n<p>\r\n	$scheme\r\n</p>\r\n<p>\r\n	$server_protocol\r\n</p>\r\n<p>\r\n	$server_addr\r\n</p>\r\n<p>\r\n	$server_name\r\n</p>\r\n<p>\r\n	$server_port\r\n</p>\r\n<p>\r\n	$uri\r\n</p>\r\n<p>\r\n	nginx的rewrite指令执行顺序：\r\n</p>\r\n<p>\r\n	1）执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域，其它xx块类似)\r\n</p>\r\n<p>\r\n	2）执行location匹配\r\n</p>\r\n<p>\r\n	3）执行选定的location中的rewrite指令\r\n</p>\r\n<p>\r\n	如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件\r\n</p>\r\n<p>\r\n	如果循环超过10次，则返回500 Internal Server Error错误\r\n</p>\r\n<p>\r\n	break指令语法：break;默认值：无作用域：server,location,if\r\n</p>\r\n<p>\r\n	停止执行当前虚拟主机的后续rewrite指令集。break指令实例：\r\n</p>\r\n<p>\r\n	if ($slow) {\r\n</p>\r\n<p>\r\n	limit_rate 10k;\r\n</p>\r\n<p>\r\n	break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if指令语法：if(condition){...}默认值：无作用域：server,location对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行。if条件(conditon)可以是如下任何内容:\r\n</p>\r\n<p>\r\n	1）一个变量名；false如果这个变量是空字符串或者以0开始的字符串；\r\n</p>\r\n<p>\r\n	2）使用= ,!= 比较的一个变量和字符串\r\n</p>\r\n<p>\r\n	3）是用~， ~*与正则表达式匹配的变量，如果这个正则表达式中包含}，;则整个表达式需要用\" 或\' 包围\r\n</p>\r\n<p>\r\n	4）使用-f ，!-f 检查一个文件是否存在\r\n</p>\r\n<p>\r\n	5）使用-d, !-d 检查一个目录是否存在\r\n</p>\r\n<p>\r\n	6）使用-e ，!-e 检查一个文件、目录、符号链接是否存在\r\n</p>\r\n<p>\r\n	7）使用-x ， !-x 检查一个文件是否可执行\r\n</p>\r\n<p>\r\n	if指令实例：\r\n</p>\r\n<p>\r\n	if ($http_user_agent ~ MSIE) {\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$ /msie/$1 break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($http_cookie ~* \"id=([^;]+)(?:;|$)\") {\r\n</p>\r\n<p>\r\n	set $id $1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($request_method = POST) {\r\n</p>\r\n<p>\r\n	return 405;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($slow) {\r\n</p>\r\n<p>\r\n	limit_rate 10k;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($invalid_referer) {\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	return指令\r\n</p>\r\n<p>\r\n	语法：\r\n</p>\r\n<p>\r\n	return code;\r\n</p>\r\n<p>\r\n	return code URL;\r\n</p>\r\n<p>\r\n	return URL;\r\n</p>\r\n<p>\r\n	默认值：无\r\n</p>\r\n<p>\r\n	作用域：server,location,if\r\n</p>\r\n<p>\r\n	停止处理并返回指定状态码(code)给客户端。\r\n</p>\r\n<p>\r\n	非标准状态码444，表示关闭连接且不给客户端发响应头。\r\n</p>\r\n<p>\r\n	从0.8.42版本起，return 支持响应URL重定向(对于301，302，303，307），或者文本响应(对于其他状态码).\r\n</p>\r\n<p>\r\n	对于文本或者URL重定向可以包含变量\r\n</p>\r\n<p>\r\n	rewrite指令\r\n</p>\r\n<p>\r\n	语法：rewrite regex replacement [flag];\r\n</p>\r\n<p>\r\n	默认值：无\r\n</p>\r\n<p>\r\n	作用域：server,location,if\r\n</p>\r\n<p>\r\n	如果一个URI匹配指定的正则表达式regex，URI就按照replacement重写。\r\n</p>\r\n<p>\r\n	rewrite按配置文件中出现的顺序执行。flags标志可以停止继续处理。\r\n</p>\r\n<p>\r\n	如果replacement以\"http://\"或\"https://\"开始，将不再继续处理，这个重定向将返回给客户端。\r\n</p>\r\n<p>\r\n	flag可以是如下参数：\r\n</p>\r\n<p>\r\n	last     停止处理后续rewrite指令集，然后对当前重写的新URI在rewrite指令集上重新查找。\r\n</p>\r\n<p>\r\n	break    停止处理后续rewrite指令集，并不在重新查找,但是当前location内剩余非rewrite语句和location外的非rewrite语句可以执行。\r\n</p>\r\n<p>\r\n	redirect 如果replacement不是以http:// 或https://开始，返回302临时重定向\r\n</p>\r\n<p>\r\n	permant  返回301永久重定向\r\n</p>\r\n<p>\r\n	最终完整的重定向URL包括请求scheme(http://,https://等),请求的server_name_in_redirect和port_in_redirec三部分 ，说白了也就是http协议、域名、端口三部分组成。\r\n</p>\r\n<p>\r\n	rewrite实例说明：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra last;\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如果这些rewrite放到 “/download/” location如下所示, 那么应使用break而不是last , 使用last将循环10次匹配，然后返回500错误:\r\n</p>\r\n<p>\r\n	location /download/ {\r\n</p>\r\n<p>\r\n	rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 break;\r\n</p>\r\n<p>\r\n	rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra break;\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	对于重写后的URL（replacement）包含原请求的请求参数，原URL的?后的内容。如果不想带原请求的参数 ，可以在replacement后加一个问号。如下，我们加了一个自定义的参数user=$1,然后在结尾处放了一个问号?,把原请的参数去掉。\r\n</p>\r\n<p>\r\n	rewrite ^/users/(.*)$ /show?user=$1? last;\r\n</p>\r\n<p>\r\n	如果正则表达regex式中包含 “}” 或 “;”, 那么整个表达式需要用双引号或单引号包围.\r\n</p>\r\n<p>\r\n	rewrite_log指令\r\n</p>\r\n<p>\r\n	语法：rewrite_log on|off;\r\n</p>\r\n<p>\r\n	默认值：rewrite_log off;\r\n</p>\r\n<p>\r\n	作用域：http,server,location,if\r\n</p>\r\n<p>\r\n	开启或关闭以notice级别打印rewrite处理日志到error log文件。\r\n</p>\r\n<p>\r\n	nginx打开rewrite log的配置：\r\n</p>\r\n<p>\r\n	rewrite_log on;\r\n</p>\r\n<p>\r\n	error_log logs/xxx.error.log notice;\r\n</p>\r\n<p>\r\n	1）打开rewrite on\r\n</p>\r\n<p>\r\n	2）把error log的级别调整到notice\r\n</p>\r\n<p>\r\n	set指令\r\n</p>\r\n<p>\r\n	语法：set variable value;\r\n</p>\r\n<p>\r\n	默认值：none\r\n</p>\r\n<p>\r\n	作用域：server,location,if\r\n</p>\r\n<p>\r\n	定义一个变量并赋值，值可以是文本，变量或者文本变量混合体。\r\n</p>\r\n<p>\r\n	uninitialized_variable_warn指令\r\n</p>\r\n<p>\r\n	语法：uninitialized_variable_warn on | off;\r\n</p>\r\n<p>\r\n	默认值：uninitialized_variable_warn on\r\n</p>\r\n<p>\r\n	作用域：http,server,location,if\r\n</p>\r\n<p>\r\n	控制是否输出为初始化的变量到日志\r\n</p>\r\n<p>\r\n	根据文件类型expires\r\n</p>\r\n<p>\r\n	# Add expires header for static content\r\n</p>\r\n<p>\r\n	location ~*  \\.(js|css|jpg|jpeg|gif|png|swf)$ {\r\n</p>\r\n<p>\r\n	if (-f $request_filename) {\r\n</p>\r\n<p>\r\n	root /data/www/wwwroot/bbs;\r\n</p>\r\n<p>\r\n	expires 1d;\r\n</p>\r\n<p>\r\n	break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# serve static files\r\n</p>\r\n<p>\r\n	location ~  ^/(images|JavaScript|js|css|flash|media|static)/ {\r\n</p>\r\n<p>\r\n	root /data/www/wwwroot/down;\r\n</p>\r\n<p>\r\n	expires 30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	----------------------------------------Nginx多Server反向代理配置----------------------------------------Nginx强大的正则表达式支持可以使server_name的配置变得很灵活。比如说想要做多用户博客，那么每个用户都会拥有自己的二级域名，这样的话，可以灵活利用server_name配置也是很容易就实现的。\r\n</p>\r\n<p>\r\n	server_name的匹配顺序Nginx中的server_name指令主要用于配置基于名称虚拟主机，server_name指令在接到请求后的匹配顺序分别为：\r\n</p>\r\n<p>\r\n	1）准确的server_name匹配，例如：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ssdr.info www.ssdr.info;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）以*通配符开始的字符串：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name *.ssdr.info;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	3）以*通配符结束的字符串：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.*;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	4）匹配正则表达式：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ~^(?.+)\\.howtocn\\.org$;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	Nginx将按照上面1）,2）,3）,4）的顺序对server name进行匹配，只要有一项匹配以后就会停止搜索，所以在使用这个指令的时候一定要分清楚它的匹配顺序（类似于location指令）。server_name指令一项很实用的功能便是可以在使用正则表达式的捕获功能，这样可以尽量精简配置文件，毕竟太长的配置文件日常维护也很不方便。\r\n</p>\r\n<p>\r\n	下面是2个具体的应用：\r\n</p>\r\n<p>\r\n	1）在一个server块中配置多个站点：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ~^(www\\.)?(.+)$;\r\n</p>\r\n<p>\r\n	index index.php index.html;\r\n</p>\r\n<p>\r\n	root /data/wwwsite/$2;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	站点的主目录应该类似于这样的结构：\r\n</p>\r\n<p>\r\n	/data/wwwsite/ssdr.info\r\n</p>\r\n<p>\r\n	/data/wwwsite/linuxtone.org\r\n</p>\r\n<p>\r\n	/data/wwwsite/baidu.com\r\n</p>\r\n<p>\r\n	/data/wwwsite/google.com\r\n</p>\r\n<p>\r\n	这样就可以只使用一个server块来完成多个站点的配置。\r\n</p>\r\n<p>\r\n	2）在一个server块中为一个站点配置多个二级域名 。实际网站目录结构中通常会为站点的二级域名独立创建一个目录，同样可以使用正则的捕获来实现在一个server块中配置多个二级域名：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ~^(.+)?\\.howtocn\\.org$;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	if ($host = ssdr.info){\r\n</p>\r\n<p>\r\n	rewrite ^ http://www.ssdr.info permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	root /data/wwwsite/ssdr.info/$1/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	站点的目录结构应该如下：\r\n</p>\r\n<p>\r\n	/data/wwwsite/ssdr.info/www/\r\n</p>\r\n<p>\r\n	/data/wwwsite/ssdr.info/nginx/\r\n</p>\r\n<p>\r\n	这样访问www.ssdr.info时root目录为/data/wwwsite/ssdr.info/www/，nginx.ssdr.info时为/data/wwwsite/ssdr.info/nginx/，以此类推。\r\n</p>\r\n<p>\r\n	后面if语句的作用是将ssdr.info的方位重定向到www.ssdr.info，这样既解决了网站的主目录访问，又可以增加seo中对www.ssdr.info的域名权重。\r\n</p>\r\n<p>\r\n	多个正则表达式如果你在server_name中用了正则，而下面的location字段又使用了正则匹配，这样将无法使用$1，$2这样的引用，解决方法是通过set指令将其赋值给一个命名的变量：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name ~^(.+)?\\.howtocn\\.org$;\r\n</p>\r\n<p>\r\n	set $www_root $1;\r\n</p>\r\n<p>\r\n	root /data/wwwsite/ssdr.info/$www_root/;\r\n</p>\r\n<p>\r\n	location ~ .*\\.php?$ {\r\n</p>\r\n<p>\r\n	fastcgi_pass 127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	fastcgi_param SCRIPT_FILENAME /data/wwwsite/ssdr.info/$fastcgi_script_name;\r\n</p>\r\n<p>\r\n	include fastcgi_params;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	Nginx不同域名反向代理到另一台服务器 proxy_pass和$host想让一个VPS专门做另一个VPS的前端，后端VPS每添加一个域名，前端VPS就要同时添加一个域名来反向代理，作为前端的VPS如果一个一个的添加后端VPS的域名，那么这个事情特别麻烦，能不能让其自动反向代理后端VPS呢，用到proxy_pass和$host就可以轻松实现。以下例子为了省事，以lnmp为安装环境进行设置，修改前端VPS的nginx.conf文件，修改成以下内容：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name $host;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://www.31.gd/;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 60;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 600;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	接着修改其他部分\r\n</p>\r\n<p>\r\n	location /.(php|php5)?$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	fastcgi_pass unix:/tmp/php-cgi.sock;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	include fcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /status {\r\n</p>\r\n<p>\r\n	stub_status on;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /.(gif|jpg|jpeg|png|bmp|swf)$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	expires 30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /.(js|css)?$\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	expires 12h;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样就可以实现了前端VPS可以反向代理任意域名到后端VPS，只要将域名解析到前端VPS，后端VPS进行域名绑定，那么就可以直接访问到了。\r\n</p>\r\n<p>\r\n	一台nginx带多个域名多个tomcat情况的配置多个域名，其中2个域名需支持泛域名解析：1）www.abc.com2）www.bcd.com3）*.efg.com4）*.hij.com其中1）,2），3）为一台tomcat，4）为独立tomcat。前端一台nginx，通过配置多个虚拟主机来实现该部署。进入/usr/local/nginx/conf/vhost目录，所有虚拟主机的配置文件都在该目录下存放。\r\n</p>\r\n<p>\r\n	配置支持泛域名\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	# A virtual host using mix of IP-, name-, and port-based configuration\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       81;\r\n</p>\r\n<p>\r\n	server_name  *.efg.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://localhost:8080;\r\n</p>\r\n<p>\r\n	proxy_set_header   Host    $host;\r\n</p>\r\n<p>\r\n	proxy_set_header   X-Real-IP   $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	# A virtual host using mix of IP-, name-, and port-based configuration\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       81;\r\n</p>\r\n<p>\r\n	server_name  *.hij.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://localhost:8081;\r\n</p>\r\n<p>\r\n	proxy_set_header   Host    $host;\r\n</p>\r\n<p>\r\n	proxy_set_header   X-Real-IP   $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	Nginx 多域名配置nginx绑定多个域名可又把多个域名规则写一个配置文件里，也可又分别建立多个域名配置文件，我一般为了管理方便，每个域名建一个文件，有些同类域名也可又写在一个总的配置文件里。\r\n</p>\r\n<p>\r\n	1）每个域名一个文件的写法\r\n</p>\r\n<p>\r\n	首先打开nginx域名配置文件存放目录：/usr/local/nginx/conf/vhost ，如要绑定域名www.wangshibo.com 则在此目录建一个文件：www.wangshibo.com.conf 然后在此文件中写规则，如：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;             #绑定域名\r\n</p>\r\n<p>\r\n	index index.htm index.html index.php;      #默认文件\r\n</p>\r\n<p>\r\n	root /home/www/wangshibo.com;               #网站根目录\r\n</p>\r\n<p>\r\n	include location.conf;                            #调用其他规则，也可去除\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）一个文件多个域名的写法\r\n</p>\r\n<p>\r\n	一个文件添加多个域名的规则也是一样，只要把上面单个域名重复写下来就ok了，如：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;             #绑定域名\r\n</p>\r\n<p>\r\n	index index.htm index.html index.php;      #默认文件\r\n</p>\r\n<p>\r\n	root /home/www/wangshibo.com;               #网站根目录\r\n</p>\r\n<p>\r\n	include location.conf;                            #调用其他规则，也可去除\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name msn.wangshibo.com;             #绑定域名\r\n</p>\r\n<p>\r\n	index index.htm index.html index.php;      #默认文件\r\n</p>\r\n<p>\r\n	root /home/www/msn.wangshibo.com;        #网站根目录\r\n</p>\r\n<p>\r\n	include location.conf;                            #调用其他规则，也可去除\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	3）不带www的域名加301跳转\r\n</p>\r\n<p>\r\n	如果不带www的域名要加301跳转，那也是和绑定域名一样，先绑定不带www的域名，只是不用写网站目录，而是进行301跳转，如：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name wangshibo.com;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*) http://www.wangshibo.com/$1 permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	4）添加404网页\r\n</p>\r\n<p>\r\n	添加404网页，都可又直接在里面添加，如：\r\n</p>\r\n<p>\r\n	server\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;             #绑定域名\r\n</p>\r\n<p>\r\n	index index.htm index.html index.php;      #默认文件\r\n</p>\r\n<p>\r\n	root /home/www/wangshibo.com;               #网站根目录\r\n</p>\r\n<p>\r\n	include location.conf;                            #调用其他规则，也可去除\r\n</p>\r\n<p>\r\n	error_page 404  /404.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	最后还有一个方法需要注意，可能有需要禁止IP直接访问80端口或者禁止非本站的域名绑定我们的IP，这样的话应该\r\n</p>\r\n<p>\r\n	如下处理，放到最前一个server上面即可：\r\n</p>\r\n<p>\r\n	server{\r\n</p>\r\n<p>\r\n	listen   80 default;\r\n</p>\r\n<p>\r\n	server_name      _;\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('4bb7f15b-a496-4216-8b99-83d839e1deb5','Nginx/Apache服务连接数梳理','Nginx/Apache服务连接数梳理','<p>\r\n	统计连接数，使用netstat命令或ss命令都可以1）统计连接数（80端口）[root@wang ~]# netstat -nat|grep -i \"80\"|wc -l872\r\n</p>\r\n<p>\r\n	或者：netstat -ant | grep $ip:80 | wc -l [root@wang ~]# netstat -ant | grep 111.142.132.192:80 | wc -l 872\r\n</p>\r\n<p>\r\n	2）查看当前并发访问数（统计已连接上的），状态为“ESTABLISHED”[root@wang ~]# netstat -na|grep ESTABLISHED|wc -l405\r\n</p>\r\n<p>\r\n	或者：[root@wang ~]# netstat -ant | grep 111.142.132.192:80 | grep EST | wc -l\r\n</p>\r\n<p>\r\n	3）查看IP访问次数 [root@wang ~]# netstat -nat|grep \":80\"|awk \'{print $5}\' |awk -F: \'{print $1}\' | sort| uniq -c|sort -n\r\n</p>\r\n<p>\r\n	查看ip连接数（成功连接上的）[root@wang ~]# netstat -nat |grep ESTABLISHED | awk \'{print $5}\'|awk -F: \'{print $1}\'|sort|uniq -c|sort -nr|head -20\r\n</p>\r\n<p>\r\n	4）查看并发请求数（服务器连接数）及其TCP连接状态：[root@wang ~]# netstat -n | awk \'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}\' FIN_WAIT2 34CLOSING 1SYN_RECV 73CLOSE_WAIT 9TIME_WAIT 139ESTABLISHED 302LAST_ACK 7FIN_WAIT1 11\r\n</p>\r\n<p>\r\n	结果解释: SYN_RECV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;表示正在等待处理的请求数； ESTABLISHED &nbsp; &nbsp; 表示正常数据传输状态； TIME_WAIT &nbsp; &nbsp; &nbsp; &nbsp; 表示处理完毕，等待超时结束的请求数； FIN_WAIT1 &nbsp; &nbsp; &nbsp; &nbsp; 表示server端主动要求关闭tcp连接； FIN_WAIT2 &nbsp; &nbsp; &nbsp; &nbsp; 表示客户端中断连接； LAST_ACK &nbsp; &nbsp; &nbsp; &nbsp; 表示关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接； CLOSING &nbsp; &nbsp; &nbsp; &nbsp;表示两边同时尝试关闭\r\n</p>\r\n<p>\r\n	或者执行下面的命令：会出现一个界面，实时统计并发连接数和TCP连接数[root@wang ~]# watch \"netstat -n | awk \'/^tcp/ {++S[\\$NF]} END {for(a in S) print a, S[a]}\'\"\r\n</p>\r\n<p>\r\n	5）查找较多time_wait连接，降序排列[root@wang ~]# netstat -n|grep TIME_WAIT|awk \'{print $5}\'|sort|uniq -c|sort -rn|head -n20\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------上面是使用netstat命令进行统计查看的，也可以使用ss命令查看。netstat和ss命令的区别，可以参考：http://www.cnblogs.com/kevingrace/p/6211509.html[root@wang ~]# ss -a|wc -l746[root@wang ~]# ss -a|grep ESTAB|wc -l358[root@wang ~]# ss -a|grep TIME-WAIT|wc -l146\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------如发现系统存在大量TIME_WAIT状态的连接，该怎么办？根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方socket将进入TIME_WAIT状态,TIME_WAIT状态下的socket不能被回收使用。具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.\r\n</p>\r\n<p>\r\n	解决办法（参考：http://www.cnblogs.com/kevingrace/p/6094007.html）：通过调整内核参数解决，编辑/etc/sysctl.conf文件，添加下面四行内容：[root@wang ~]# vim /etc/sysctl.conf    .....net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30\r\n</p>\r\n<p>\r\n	配置说明：net.ipv4.tcp_syncookies = 1 &nbsp; &nbsp; 表示开启SYN cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1 &nbsp; &nbsp; &nbsp; 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1 &nbsp; &nbsp; 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout &nbsp; &nbsp; &nbsp; &nbsp; 修改系統默认的TIMEOUT时间\r\n</p>\r\n<p>\r\n	让添加的参数生效[root@wang ~]# /sbin/sysctl -p\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('556d5142-cf47-4698-ba1a-5839e823761c','Mysql慢查询操作梳理','Mysql慢查询操作梳理','<p>\r\n	Mysql慢查询解释MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表；慢查询日志用于记录一些过慢的查询语句，可以帮助管理员分析问题所在，该日志默认是没有开启的，需要在配置文件里添加一系列参数来手动启动\r\n</p>\r\n<p>\r\n	开启Mysql慢查询的理由数据库是很容易产生瓶颈的地方，现在Nosql大家讨论这么热，估计都被数据库搞郁闷了。MySQL中最影响速度的就是那些查询非常慢的语句，这些慢的语句，可能是写的不够合理或者是大数据下多表的联合查询等等，所以我们要找出这些语句，分析原因，加以优化。这也是发这篇博文的原因\r\n</p>\r\n<p>\r\n	开启mysql慢查询方法1）方法一：登陆mysql数据库终端里开启\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%long%\";         //查看一下默认为慢查询的时间10秒\r\n</p>\r\n<p>\r\n	+-----------------+-----------+\r\n</p>\r\n<p>\r\n	| Variable_name   | Value     |\r\n</p>\r\n<p>\r\n	+-----------------+-----------+\r\n</p>\r\n<p>\r\n	| long_query_time | 10.000000 |\r\n</p>\r\n<p>\r\n	+-----------------+-----------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; set global long_query_time=1;          //设置成1秒，加上global,下次进mysql已然生效\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%slow%\";          //查看一下慢查询是不是已经开启\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name       | Value                           |\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	| log_slow_queries    | OFF                             |\r\n</p>\r\n<p>\r\n	| slow_launch_time    | 2                               |\r\n</p>\r\n<p>\r\n	| slow_query_log      | OFF                             |\r\n</p>\r\n<p>\r\n	| slow_query_log_file | /usr/local/mysql/mysql-slow.log |\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; set slow_query_log=\'ON\';                    //加上global，不然会报错的\r\n</p>\r\n<p>\r\n	ERROR 1229 (HY000): Variable \'slow_query_log\' is a GLOBAL variable and should be set with SET GLOBAL\r\n</p>\r\n<p>\r\n	mysql&gt; set global slow_query_log=\'ON\';            //这个参数设置为ON，表示启用慢查询，可以捕获执行时间超过一定数值的SQL语句。\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.28 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \"%slow%\";              //查看是否已经开启\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name       | Value                           |\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	| log_slow_queries    | ON                              |\r\n</p>\r\n<p>\r\n	| slow_launch_time    | 2                               |\r\n</p>\r\n<p>\r\n	| slow_query_log      | ON                              |\r\n</p>\r\n<p>\r\n	| slow_query_log_file | /usr/local/mysql/mysql-slow.log |\r\n</p>\r\n<p>\r\n	+---------------------+---------------------------------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	方法2,修改mysql的配置文件my.cnf[root@www ~]# vim /etc/mysql.cnf在[mysqld]区域配置里添加下面内容......slow_query_log = 1&nbsp; &nbsp; &nbsp; //开启慢查询日志,将1改为ON也可以long_query_time = 1&nbsp; &nbsp; &nbsp;&nbsp;//mysql慢查询时间，指定达到多少秒才算慢查询；这里推荐设置超过1秒的执行语句就会被记录到慢查询日志中slow_query_log_file= /var/lib/mysql/mysql-slow.log&nbsp; &nbsp; &nbsp;//慢查询日志路径。这里slow_query_log_file修改为log-slow-queries 也可以//主要是上面三行内容，还可以添加下面几行细节性配置long-queries-not-using-indexes &nbsp; &nbsp; //记录没有使用索引的查询语句min_examined_row_limit = 1000&nbsp; &nbsp; &nbsp;//记录查找了多达1000次而引起的慢查询log-slow-admin-statements&nbsp; &nbsp; &nbsp; &nbsp;//记录ALTER TABLE等语句引发的慢查询log-slow-slave-statements &nbsp; &nbsp; &nbsp;&nbsp; //记录从服务器产生的慢查询\r\n</p>\r\n<p>\r\n	分析工具分析工具其实就是把mysql-slow.log里面记录下来的数据，分析一下显示出来（其实自己写一个shell脚本也是可以把要的信息取出来的）。[root@www ~]# cat mysql-slow.log &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//查看命令\r\n</p>\r\n<p>\r\n	/usr/local/mysql/libexec/mysqld, Version: 5.1.26-rc-log (Source distribution). started with:\r\n</p>\r\n<p>\r\n	Tcp port: 3306  Unix socket: /tmp/mysql.sock\r\n</p>\r\n<p>\r\n	Time                 Id Command    Argument\r\n</p>\r\n<p>\r\n	# Time: 100814 13:28:30\r\n</p>\r\n<p>\r\n	# User@Host: root[root] @ localhost []\r\n</p>\r\n<p>\r\n	# Query_time: 10.096500  Lock_time: 0.045791 Rows_sent: 1  Rows_examined: 2374192\r\n</p>\r\n<p>\r\n	SET timestamp=1281763710;\r\n</p>\r\n<p>\r\n	select count(distinct ad_code) as x from ad_visit_history where ad_code in (select ad_code from ad_list where media_id=15);\r\n</p>\r\n<p>\r\n	# Time: 100814 13:37:02\r\n</p>\r\n<p>\r\n	# User@Host: root[root] @ localhost []\r\n</p>\r\n<p>\r\n	# Query_time: 10.394134  Lock_time: 0.000091 Rows_sent: 1  Rows_examined: 2374192\r\n</p>\r\n<p>\r\n	SET timestamp=1281764222;\r\n</p>\r\n<p>\r\n	select count(distinct ad_code) as x from ad_visit_history where ad_code in (select ad_code from ad_list where media_id=15);\r\n</p>\r\n<p>\r\n	# Time: 100814 13:37:16\r\n</p>\r\n<p>\r\n	# User@Host: root[root] @ localhost []\r\n</p>\r\n<p>\r\n	# Query_time: 4.608920  Lock_time: 0.000078 Rows_sent: 1  Rows_examined: 1260544\r\n</p>\r\n<p>\r\n	SET timestamp=1281764236;\r\n</p>\r\n<p>\r\n	select count(*) as cou  from ad_visit_history where ad_code in (select ad_code from ad_list where id=41) order by id desc;\r\n</p>\r\n<p>\r\n	看到了，就是记录一下sql语句的执行情况，包括执行时间，锁定时间等，所以要不要分析工具看个人情况，分析工具很多，在这儿只说一下mysql自带的慢查询分析工具mysqldumpslow的使用方法。\r\n</p>\r\n<p>\r\n	[root@www ~]# mysqldumpslow -h\r\n</p>\r\n<p>\r\n	Option h requires an argument\r\n</p>\r\n<p>\r\n	ERROR: bad option\r\n</p>\r\n<p>\r\n	Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]\r\n</p>\r\n<p>\r\n	Parse and summarize the MySQL slow query log. Options are\r\n</p>\r\n<p>\r\n	--verbose    verbose\r\n</p>\r\n<p>\r\n	--debug      debug\r\n</p>\r\n<p>\r\n	--help       write this text to standard output\r\n</p>\r\n<p>\r\n	-v           verbose\r\n</p>\r\n<p>\r\n	-d           debug          //查错\r\n</p>\r\n<p>\r\n	-s ORDER     what to sort by (t, at, l, al, r, ar etc), \'at\' is default     //排序方式query次数，时间，lock的时间和返回的记录数来排序\r\n</p>\r\n<p>\r\n	-r           reverse the sort order (largest last instead of first)       //倒排序\r\n</p>\r\n<p>\r\n	-t NUM       just show the top n queries                                       //显示前N多个\r\n</p>\r\n<p>\r\n	-a           don\'t abstract all numbers to N and strings to \'S\'\r\n</p>\r\n<p>\r\n	-n NUM       abstract numbers with at least n digits within names   //抽象的数字，至 少有n位内的名称\r\n</p>\r\n<p>\r\n	-g PATTERN   grep: only consider stmts that include this string      //配置模式\r\n</p>\r\n<p>\r\n	-h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),     //mysql所以机器名或者IP\r\n</p>\r\n<p>\r\n	default is \'*\', i.e. match all\r\n</p>\r\n<p>\r\n	-i NAME      name of server instance (if using mysql.server startup script)\r\n</p>\r\n<p>\r\n	-l           don\'t subtract lock time from total time           //总时间中不减去锁定时间\r\n</p>\r\n<p>\r\n	实例：[root@BlackGhost bin]# ./mysqldumpslow -s r -t 20 /var/lib/mysql/mysql-slow.log[root@BlackGhost bin]# ./mysqldumpslow -s r -t 20 -g \'count\' /var/lib/mysql/mysql-slow.log\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('585f5df1-88d8-407a-bbb5-e21d9018b16f','Mysql备份系列（4）--lvm-snapshot备份mysql数据(全量+增量）操作记录','Mysql备份系列（4）--lvm-snapshot备份mysql数据(全量+增量）操作记录','<p>\r\n	Mysql最常用的三种备份工具分别是mysqldump、Xtrabackup（innobackupex工具）、lvm-snapshot快照。前面分别介绍了：Mysql备份系列（1）--备份方案总结性梳理Mysql备份系列（2）--mysqldump备份（全量+增量）方案操作记录Mysql备份系列（3）--innobackupex备份mysql大数据(全量+增量）操作记录\r\n</p>\r\n<p>\r\n	lvm-snapshot：基于LVM快照的备份1.关于快照：1）事务日志跟数据文件必须在同一个卷上；2）刚刚创立的快照卷，里面没有任何数据，所有数据均来源于原卷3）一旦原卷数据发生修改，修改的数据将复制到快照卷中，此时访问数据一部分来自于快照卷，一部分来自于原卷4）当快照使用过程中，如果修改的数据量大于快照卷容量，则会导致快照卷崩溃。 5）快照卷本身不是备份，只是提供一个时间一致性的访问目录。\r\n</p>\r\n<p>\r\n	2.基于快照备份几乎为热备： 1）创建快照卷之前，要请求MySQL的全局锁；在快照创建完成之后释放锁；2）如果是Inoodb引擎， 当flush tables 后会有一部分保存在事务日志中，却不在文件中。 因此恢复时候，需要事务日志和数据文件但释放锁以后，事务日志的内容会同步数据文件中，因此备份内容并不绝对是锁释放时刻的内容，由于有些为完成的事务已经完成，但在备份数据中因为没完成而回滚。 因此需要借助二进制日志往后走一段\r\n</p>\r\n<p>\r\n	3.基于快照备份注意事项： 1）事务日志跟数据文件必须在同一个卷上；2）创建快照卷之前，要请求MySQL的全局锁；在快照创建完成之后释放锁；3）请求全局锁完成之后，做一次日志滚动；做二进制日志文件及位置标记(手动进行)；\r\n</p>\r\n<p>\r\n	4.为什么基于MySQL快照的备份很好？原因如下几点：1）几乎是热备 在大多数情况下，可以在应用程序仍在运行的时候执行备份。无需关机，只需设置为只读或者类似只读的限制。2）支持所有基于本地磁盘的存储引擎 它支持MyISAM, Innodb, BDB，还支持 Solid, PrimeXT 和 Falcon。3）快速备份 只需拷贝二进制格式的文件，在速度方面无以匹敌。4）低开销 只是文件拷贝，因此对服务器的开销很细微。5）容易保持完整性 想要压缩备份文件吗？把它们备份到磁带上，FTP或者网络备份软件 -- 十分简单，因为只需要拷贝文件即可。6）快速恢复 恢复的时间和标准的MySQL崩溃恢复或数据拷贝回去那么快，甚至可能更快，将来会更快。7）免费 无需额外的商业软件，只需Innodb热备工具来执行备份。\r\n</p>\r\n<p>\r\n	快照备份mysql的缺点：1）需要兼容快照 -- 这是明显的。2）需要超级用户(root) 在某些组织，DBA和系统管理员来自不同部门不同的人，因此权限各不一样。3）停工时间无法预计，这个方法通常指热备，但是谁也无法预料到底是不是热备 -- FLUSH TABLES WITH READ LOCK 可能会需要执行很长时间才能完成。4）多卷上的数据问题 如果你把日志放在独立的设备上或者你的数据库分布在多个卷上，这就比较麻烦了，因为无法得到全部数据库的一致性快照。不过有些系统可能能自动做到多卷快照。\r\n</p>\r\n<p>\r\n	下面即是使用lvm-snapshot快照方式备份mysql的操作记录，仅依据本人实验中使用而述.\r\n</p>\r\n<p>\r\n	操作记录：如下环境，本机是在openstack上开的云主机，在openstack上创建一个30G的云硬盘挂载到本机，然后制作lvm逻辑卷。\r\n</p>\r\n<p>\r\n	一、准备LVM卷，并将mysql数据恢复(或者说迁移）到LVM卷上：1）  创建一个分区或保存到另一块硬盘上面2）  创建PV、VG、LVM3）  格式化 LV04）  挂载LV到临时目录5）  确认服务处于stop状态6）  将数据迁移到LV07）  重新挂载LV0到mysql数据库的主目录/data/mysql/data8）  审核权限并启动服务[root@test-huanqiu ~]# fdisk -l.........Disk /dev/vdc: 32.2 GB, 32212254720 bytes16 heads, 63 sectors/track, 62415 cylindersUnits = cylinders of 1008 * 512 = 516096 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x00000000\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# fdisk /dev/vdc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//依次输入p-&gt;n-&gt;p-&gt;1-&gt;回车-&gt;回车-&gt;w.........Command (m for help): p\r\n</p>\r\n<p>\r\n	Disk /dev/vdc: 32.2 GB, 32212254720 bytes16 heads, 63 sectors/track, 62415 cylindersUnits = cylinders of 1008 * 512 = 516096 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x343250e4\r\n</p>\r\n<p>\r\n	Device Boot      Start         End      Blocks   Id  System\r\n</p>\r\n<p>\r\n	Command (m for help): nCommand action   e   extended   p   primary partition (1-4)pPartition number (1-4): 1First cylinder (1-62415, default 1): Using default value 1Last cylinder, +cylinders or +size{K,M,G} (1-62415, default 62415): Using default value 62415\r\n</p>\r\n<p>\r\n	Command (m for help): wThe partition table has been altered!\r\n</p>\r\n<p>\r\n	Calling ioctl() to re-read partition table.Syncing disks.\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# fdisk /dev/vdc\r\n</p>\r\n<p>\r\n	WARNING: DOS-compatible mode is deprecated. It\'s strongly recommended to         switch off the mode (command \'c\') and change display units to         sectors (command \'u\').\r\n</p>\r\n<p>\r\n	Command (m for help): p\r\n</p>\r\n<p>\r\n	Disk /dev/vdc: 32.2 GB, 32212254720 bytes16 heads, 63 sectors/track, 62415 cylindersUnits = cylinders of 1008 * 512 = 516096 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x343250e4\r\n</p>\r\n<p>\r\n	Device Boot      Start         End      Blocks   Id  System/dev/vdc1               1       62415    31457128+   5  Extended\r\n</p>\r\n<p>\r\n	Command (m for help):\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# pvcreate /dev/vdc1   Device /dev/vdc1 not found (or ignored by filtering).[root@test-huanqiu ~]# vgcreate vg0 /dev/vdc1  Volume group \"vg0\" successfully created[root@test-huanqiu ~]# lvcreate -L +3G -n lv0 vg0  Logical volume \"lv0\" created.[root@test-huanqiu ~]# mkfs.ext4 /dev/vg0/lv0 [root@test-huanqiu ~]# mkdir /var/lv0/[root@test-huanqiu ~]# mount /dev/vg0/lv0 /var/lv0/[root@test-huanqiu ~]# df -hFilesystem            Size  Used Avail Use% Mounted on/dev/mapper/VolGroup00-LogVol00                      8.1G  6.0G  1.7G  79% /tmpfs                 1.9G     0  1.9G   0% /dev/shm/dev/vda1             190M   37M  143M  21% /boot/dev/mapper/vg0-lv0   2.9G  4.5M  2.8G   1% /var/lv0\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# lvs  LV       VG         Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert  LogVol00 VolGroup00 -wi-ao---- 8.28g                                                      LogVol01 VolGroup00 -wi-ao---- 1.50g                                                      lv0      vg0        -wi-a----- 3.00g\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------如果要想删除这个lvs，操作如下：[root@test-huanqiu ~]# umount /data/mysql/data/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//先卸载掉这个lvs的挂载关系[root@test-huanqiu ~]# lvremove /dev/vg0/lv0 [root@test-huanqiu ~]# vgremove vg0[root@test-huanqiu ~]# pvremove /dev/vdc1[root@test-huanqiu ~]# lvs  LV       VG         Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert  LogVol00 VolGroup00 -wi-ao---- 8.28g                                                      LogVol01 VolGroup00 -wi-ao---- 1.50g   ----------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	mysql的数据目录是/data/mysql/data,密码是123456[root@test-huanqiu ~]# ps -ef|grep mysqlmysql     2066  1286  0 07:33 ?        00:00:06 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql/ --datadir=/data/mysql/data --plugin-dir=/usr/local/mysql//lib/plugin --user=mysql --log-error=/data/mysql/data/mysql-error.log --pid-file=/data/mysql/data/mysql.pid --socket=/usr/local/mysql/var/mysql.sock --port=3306root      2523  2471  0 07:55 pts/1    00:00:00 grep mysql[root@test-huanqiu ~]# /etc/init.d/mysql stopShutting down MySQL.... SUCCESS!\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cd /data/mysql/data/[root@test-huanqiu data]# tar -cf - . | tar xf - -C /var/lv0/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# umount /var/lv0/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# mount /dev/vg0/lv0 /data/mysql/data[root@test-huanqiu data]# df -hFilesystem            Size  Used Avail Use% Mounted on/dev/mapper/VolGroup00-LogVol00                      8.1G  6.0G  1.7G  79% /tmpfs                 1.9G     0  1.9G   0% /dev/shm/dev/vda1             190M   37M  143M  21% /boot/dev/mapper/vg0-lv0   2.9G  164M  2.6G   6% /data/mysql/data\r\n</p>\r\n<p>\r\n	删除挂载后产生的lost+found目录[root@test-huanqiu data]# rm -rf lost+found\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# ll -d /data/mysql/data[root@test-huanqiu data]# ll -Z /data/mysql/data[root@test-huanqiu data]# ll -Zd /data/mysql/data\r\n</p>\r\n<p>\r\n	需要注意的是:当SElinux功能开启情况下，mysql数据库重启会失败，所以必须执行下面命令，恢复SElinux安全上下文.[root@test-huanqiu data]# restorecon -R /data/mysql/data/[root@test-huanqiu data]# /etc/init.d/mysql startStarting MySQL... SUCCESS!\r\n</p>\r\n<p>\r\n	二、备份： (生产环境下一般都是整个数据库备份)1）锁表2）查看position号并记录，便于后期恢复3）创建snapshot快照4）解表5）挂载snapshot6）拷贝snapshot数据，进行备份。备份整个数据库之前，要关闭mysql服务（保护ibdata1文件）7）移除快照\r\n</p>\r\n<p>\r\n	设置此变量为1，让每个事件尽可能同步到二进制日志文件里，以消耗IO来尽可能确保数据一致性。 mysql&gt; SET GLOBAL sync_binlog=1;\r\n</p>\r\n<p>\r\n	查看二进制日志和position，以备后续进行binlog日志恢复增量数据（记住这个position节点记录，对后面的增量数据备份很重要）&nbsp;mysql&gt; SHOW MASTER STATUS; +------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000004&nbsp;| 1434&nbsp;| | | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	创建存放binlog日志的position节点记录的目录所有的position节点记录都放在这同一个binlog.pos文件下（后面就使用&gt;&gt;符号追加到这个文件下）[root@test-huanqiu ~]# mkdir /backup/mysql/binlog[root@test-huanqiu ~]# mysql -p123456 -e \"SHOW MASTER STATUS;\" &gt; /backup/mysql/binlog/binlog.pos [root@test-huanqiu snap1]# cat /backup/mysql/binlog/binlog.posFile  Position  Binlog_Do_DB  Binlog_Ignore_DB  Executed_Gtid_Setmysql-bin.000004  1434\r\n</p>\r\n<p>\r\n	刷新日志，产生新的binlog日志，保证日志信息不会再写入到上面的mysql-bin.000004日志内。mysql&gt; FLUSH LOGS;\r\n</p>\r\n<p>\r\n	全局读锁，读锁请求到后不要关闭此mysql交互界面mysql&gt; FLUSH TABLES WITH READ LOCK;\r\n</p>\r\n<p>\r\n	在innodb表中，即使是请求到了读锁，但InnoDB在后台依然可能会有事务在进行读写操作，可用\"mysql&gt; SHOW ENGINE INNODB STATUS;\"查看后台进程的状态，等没有写请求后再做备份。\r\n</p>\r\n<p>\r\n	创建快照，以只读的方式（--permission r）创建一个3GB大小的快照卷snap1-s：相当于--snapshot[root@test-huanqiu ~]# mkdir /var/snap1[root@test-huanqiu ~]# lvcreate -s -L 2G -n snap1 /dev/vg0/lv0 --permission rLogical volume \"snap1\" created.\r\n</p>\r\n<p>\r\n	查看快照卷的详情（快照卷也是LV）：[root@test-huanqiu ~]# lvdisplay\r\n</p>\r\n<p>\r\n	解除锁定回到锁定表的mysql交互式界面，解锁：mysql&gt; UNLOCK TABLES;\r\n</p>\r\n<p>\r\n	此参数可以根据服务器磁盘IO的负载来调整mysql&gt; SET GLOBAL sync_binlog=0;\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# mount /dev/vg0/snap1 /var/snap1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//挂载快照卷[root@test-huanqiu snap1]# df -hFilesystem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size &nbsp; Used &nbsp;Avail &nbsp;Use% &nbsp;Mounted on/dev/mapper/VolGroup00-LogVol00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8.1G &nbsp;5.8G &nbsp;1.9G &nbsp;76% &nbsp; &nbsp;/tmpfs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.9G &nbsp;0 &nbsp; &nbsp; &nbsp; 1.9G &nbsp;0% &nbsp; &nbsp; &nbsp;/dev/shm/dev/vda1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;190M 37M &nbsp; 143M  21% &nbsp; &nbsp;/boot/dev/mapper/vg0-lv0   2.9G  115M  2.7G   5% /data/mysql/data/dev/mapper/vg0-snap1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.9G  115M  2.7G   5% /var/snap1\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cd /var/snap1/ &amp;&amp; ll /var/snap1[root@test-huanqiu snap1]# mkdir -p /backup/mysql/data/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //创建备份目录total 0\r\n</p>\r\n<p>\r\n	对本机的数据库进行备份，备份整个数据库。\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; create database beijing;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use beijing;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table people(id int(5),name varchar(20));\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.03 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into people values(\"1\",\"wangshibo\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into people values(\"2\",\"guohuihui\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into people values(\"3\",\"wuxiang\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from people;\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	| id   | name      |\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	|    1 | wangshibo |\r\n</p>\r\n<p>\r\n	|    2 | guohuihui |\r\n</p>\r\n<p>\r\n	|    3 | wuxiang   |\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| beijing            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------需要注意的是：innodb表，一般会打开独立表空间模式(innodb_file_per_table)。由于InnoDB默认会将所有的数据库InnoDB引擎的表数据存储在一个共享空间中：ibdata1文件。增删数据库的时候，ibdata1文件不会自动收缩，这对单个或部分数据库的备份也将成为问题（如果不是整个数据库备份的情况下，ibdata1文件就不能备份，否则会影响全部数据库的数据）。所以若是对单个数据库或部分数据库进行快照备份：1）若是直接误删除mysql数据目录下备份库目录，可以直接将快照备份数据解压就能恢复2）若是使用drop或delete误删除的数据，那么在使用快照备份数据恢复时，就会出问题！因为单库备份时ibdata1文件不能单独备份，恢复时会导致这个文件损坏！\r\n</p>\r\n<p>\r\n	所以正确的做法是：要对整个数据库进行备份，并且一定要在mysql服务关闭的情况下（这样是为了保护ibdata1文件）。因为mysql是采用缓冲方式来将数据写入到ibdata1文件中的，这正是fflush()函数存在的理由。当mysql在运行时，对ibdata1进行拷贝肯定会导致ibdata1文件中的数据出错，这样在数据恢复时，也就肯定会出现“ERROR 1146 (42S02): Table \'****\' doesn\'t exist“的报错！\r\n</p>\r\n<p>\r\n	在对启用innodb引擎的mysql数据库进行迁移的时候也是同理：在对innodb数据库进行数据迁移的时候，即将msyql(innodb引擎)服务从一台服务器迁移到另一台服务器时，在对数据库目录进行整体拷贝的时候（当然就包括了对ibdata1文件拷贝），一定要在关闭对方mysql服务的情况下进行拷贝！\r\n</p>\r\n<p>\r\n	ibdata1用来储存文件的数据，而库名的文件夹里面的那些表文件只是结构而已，由于新版的mysql默认试innodb，所以ibdata1文件默认就存在了，少了这个文件有的数据表就会出错。要知道：数据库目录下的.frm文件是数据库中很多的表的结构描述文件；而ibdata1文件才是数据库的真实数据存放文件。\r\n</p>\r\n<p>\r\n	-------------------------------------------innodb_file_per_table参数说明------------------------------------------线上环境的话，一般都建议打开这个独立表空间模式。因为ibdata1文件会不断的增大，不会减少，无法向OS回收空间，容易导致线上出现过大的共享表空间文件，致使当前空间爆满。并且ibdata1文件大到一定程序会影响insert、update的速度；并且另外如果删表频繁的话，共享表空间产生的碎片会比较多。打开独立表空间，方便进行innodb表的碎片整理\r\n</p>\r\n<p>\r\n	使用MyISAM表引擎的数据库会分别创建三个文件：表结构、表索引、表数据空间。可以将某个数据库目录直接迁移到其他数据库也可以正常工作。\r\n</p>\r\n<p>\r\n	然而当使用InnoDB的时候，一切都变了。InnoDB默认会将所有的数据库InnoDB引擎的表数据存储在一个共享空间中：ibdata1文件。增删数据库的时候，ibdata1文件不会自动收缩，单个数据库的备份也将成为问题。通常只能将数据使用mysqldump 导出，然后再导入解决这个问题。\r\n</p>\r\n<p>\r\n	在MySQL的配置文件[mysqld]部分，增加innodb_file_per_table参数。可以修改InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间。\r\n</p>\r\n<p>\r\n	它的优点：1）每个表都有自已独立的表空间。2）每个表的数据和索引都会存在自已的表空间中。3）可以实现单表在不同的数据库中移动。4）空间可以回收（除drop table操作处，表空不能自已回收）\r\n</p>\r\n<p>\r\n	Drop table操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通过:alter table TableName engine=innodb;回缩不用的空间。对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。\r\n</p>\r\n<p>\r\n	它的缺点：单表增加过大，如超过100个G。\r\n</p>\r\n<p>\r\n	结论：共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整一下：innodb_open_files。InnoDB Hot Backup（冷备）的表空间cp不会面对很多无用的copy了。而且利用innodb hot backup及表空间的管理命令可以实。\r\n</p>\r\n<p>\r\n	1）innodb_file_per_table设置.设置为1，表示打开了独立的表空间模式。 如果设置为0，表示关闭独立表空间模式，开启方法如下：在my.cnf中[mysqld]下设置innodb_file_per_table=1\r\n</p>\r\n<p>\r\n	2）查看是否开启：mysql&gt; show variables like \"%per_table%\";+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| innodb_file_per_table | ON |+-----------------------+-------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）关闭独享表空间innodb_file_per_table=0关闭独立的表空间mysql&gt; show variables like ‘%per_table%’;-------------------------------------------innodb_file_per_table参数说明--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	备份前，一定要关闭mysql数据库！因为里面会涉及到ibdata1文件备份，不关闭mysql的话，ibdata1文件备份后会损坏，从而导致恢复数据失败！[root@test-huanqiu snap1]# /etc/init.d/mysql stopShutting down MySQL.... SUCCESS! [root@test-huanqiu data]# lsof -i:3306    [root@test-huanqiu data]#\r\n</p>\r\n<p>\r\n	现在备份整个数据库[root@test-huanqiu snap1]# tar -zvcf /backup/mysql/data/`date +%Y-%m-%d`dbbackup.tar.gz ./[root@test-huanqiu snap1]# ll /backup/mysql/data/total 384-rw-r--r--. 1 root root 392328 Dec  5 22:15 2016-12-05dbbackup.tar.gz\r\n</p>\r\n<p>\r\n	释放快照卷，每次备份之后，应该删除快照，减少IO操作先卸载，再删除[root@test-huanqiu ~]# umount /var/snap1/ [root@test-huanqiu ~]# df -h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//确认上面的挂载关系已经没了Filesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup00-LogVol008.1G 5.8G 1.9G 76% /tmpfs 1.9G 0 1.9G 0% /dev/shm/dev/vda1 190M 37M 143M 21% /boot/dev/mapper/vg0-lv0 2.9G 115M 2.7G 5% /data/mysql/data[root@test-huanqiu ~]# lvremove /dev/vg0/snap1Do you really want to remove active logical volume snap1? [y/n]: yLogical volume \"snap1\" successfully removed\r\n</p>\r\n<p>\r\n	数据被快照备份后，可以启动数据库[root@test-huanqiu ~]# /etc/init.d/mysql startStarting MySQL.. SUCCESS! [root@test-huanqiu ~]# lsof -i:3306COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEmysqld  15943 mysql   16u  IPv4  93348      0t0  TCP *:mysql (LISTEN)[root@test-huanqiu ~]#\r\n</p>\r\n<p>\r\n	现在再进行新的数据写入：\r\n</p>\r\n<p>\r\n	mysql&gt; use beijing;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; insert into people values(\"4\",\"liumengnan\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into people values(\"5\",\"zhangjuanjuan\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from people;\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	| id   | name          |\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	|    1 | wangshibo     |\r\n</p>\r\n<p>\r\n	|    2 | guohuihui     |\r\n</p>\r\n<p>\r\n	|    3 | wuxiang       |\r\n</p>\r\n<p>\r\n	|    4 | liumengnan    |\r\n</p>\r\n<p>\r\n	|    5 | zhangjuanjuan |\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; create table heihei(name varchar(20),age varchar(20));\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into heihei values(\"jiujiujiu\",\"nan\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from heihei;\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	| name      | age  |\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	| jiujiujiu | nan  |\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; create database shanghai;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| beijing            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| shanghai           |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	假设一不小心误操作删除beijing和shanghai库\r\n</p>\r\n<p>\r\n	mysql&gt; drop database beijing;\r\n</p>\r\n<p>\r\n	Query OK, 2 rows affected (0.03 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database shanghai;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	莫慌！接下来就说下数据恢复操作~~三、恢复流程如下：0）由于涉及到增量数据备份，所以提前将最近一次的binlog日志从mysql数据目录复制到别的路径下1）在mysql数据库中执行flush logs命令，产生新的binlog日志，让日志信息写入到新的这个binlog日志中1）关闭数据库，一定要关闭2）删除数据目录下的文件3）快照数据拷贝回来，position节点记录回放4）增量数据就利用mysqlbinlog命令将上面提前拷贝的binlog日志文件导出为sql文件，并剔除其中的drop语句，然后进行恢复。5）重启数据\r\n</p>\r\n<p>\r\n	先将最新一次的binlog日志备份到别处，用作增量数据备份。比如mysql-bin.000006是最新一次的binlog日志[root@test-huanqiu data]# cp mysql-bin.000006 /backup/mysql/data/\r\n</p>\r\n<p>\r\n	产生新的binlog日志，确保日志写入到这个新的binlog日志内，而不再写入到上面备份的binlog日志里。mysql&gt; flush logs;\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# ll mysql-bin.000007 -rw-rw----. 1 mysql mysql 120 Dec  5 23:19 mysql-bin.000007\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# /etc/init.d/mysql stopShutting down MySQL.... SUCCESS! [root@test-huanqiu data]# lsof -i:3306[root@test-huanqiu data]# pwd/data/mysql/data[root@test-huanqiu data]# rm -rf ./*[root@test-huanqiu data]# tar -zvxf /backup/mysql/data/2016-12-05dbbackup.tar.gz ./\r\n</p>\r\n<p>\r\n	[root@test-huanqiu data]# /etc/init.d/mysql startStarting MySQL SUCCESS! [root@test-huanqiu data]#  cat /backup/mysql/binlog/binlog.posFile  Position  Binlog_Do_DB  Binlog_Ignore_DB  Executed_Gtid_Setmysql-bin.000004  1434      [root@test-huanqiu data]# mysqlbinlog --start-position=1434 /data/mysql/data/mysql-bin.000004 | mysql -p123456\r\n</p>\r\n<p>\r\n	登陆数据库查看，发现这只是恢复到快照备份阶段的数据：\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| beijing            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from beijing.people;\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	| id   | name      |\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	|    1 | wangshibo |\r\n</p>\r\n<p>\r\n	|    2 | guohuihui |\r\n</p>\r\n<p>\r\n	|    3 | wuxiang   |\r\n</p>\r\n<p>\r\n	+------+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	快照备份之后写入的数据要利用mysqlbinlog命令将上面拷贝的mysql-bin000006文件导出为sql文件，并剔除其中的drop语句，然后进行恢复。[root@test-huanqiu ~]# cd /backup/mysql/data/[root@test-huanqiu data]# lltotal 388-rw-r--r--. 1 root root 392328 Dec  5 22:15 2016-12-05dbbackup.tar.gz-rw-r-----. 1 root root   1274 Dec  5 23:19 mysql-bin.000006[root@test-huanqiu data]#  mysqlbinlog mysql-bin.000006 &gt;000006bin.sql\r\n</p>\r\n<p>\r\n	剔除其中的drop语句[root@test-huanqiu data]# vim 000006bin.sql &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//手动删除sql语句中的drop语句\r\n</p>\r\n<p>\r\n	然后在mysql中使用source命令恢复数据mysql&gt; source /backup/mysql/data/000006bin.sql;\r\n</p>\r\n<p>\r\n	再次查看下，发现增量部分的数据也已经恢复回来了\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| beijing            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| shanghai           |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use beijing;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_beijing |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| heihei            |\r\n</p>\r\n<p>\r\n	| people            |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from people;\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	| id   | name          |\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	|    1 | wangshibo     |\r\n</p>\r\n<p>\r\n	|    2 | guohuihui     |\r\n</p>\r\n<p>\r\n	|    3 | wuxiang       |\r\n</p>\r\n<p>\r\n	|    4 | liumengnan    |\r\n</p>\r\n<p>\r\n	|    5 | zhangjuanjuan |\r\n</p>\r\n<p>\r\n	+------+---------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from heihei;\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	| name      | age  |\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	| jiujiujiu | nan  |\r\n</p>\r\n<p>\r\n	+-----------+------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------思路：1）全库的快照备份只需要在开始时备份一份即可，这相当于全量备份。2）后续只需要每天备份一次最新的binlog日志（备份后立即flush logs产生新的binlog日志），这相当于增量备份了。3）利用快照备份恢复全量数据，利用备份的binlog日志进行增量数据恢复4）crontab计划任务，每天定时备份最近一次的binlog日志即可。----------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('5a41abe2-f0d8-479d-a4be-fe1eff408633','ngx_pagespeed-nginx前端优化模块介绍','ngx_pagespeed-nginx前端优化模块介绍','<p>\r\n	ngx_pagespeed是Nginx的一个扩展模块，借助pagespeed,为Nginx网站服务器提速。主要的功能是针对前端页面而进行服务器端的优化，对前端设计人员来说，可以省去优化css、js以及图片的过程。ngx_pagespeed对nginx自身负载能力的提升基本是看不到的，甚至会因为进行服务器端的优化而使系统增加负载；但从减少客户请求数的角度去看，牺牲部分服务器性能还是值得的。\r\n</p>\r\n<p>\r\n	ngx_pagespeed模块的主要功能大致有：1）图像优化：剥离元数据、动态调整，重新压缩2）CSS和JavaScript压缩、合并、级联、内联3）小资源内联4）推迟图像和JavaScript加载5）对HTML重写、压缩空格、去除注释等6）提升缓存周期\r\n</p>\r\n<p>\r\n	作为Nginx组件，ngx_pagespeed将重写你的网页，让用户以更快的速度进行访问。重写的工作包括压缩图片、缩减CSS和JavaScript、扩展缓存时间，同样还包括其它一些最佳实践：1）优化缓存----整合应用程序的数据和逻辑2）最小化round-trip次数----削减连续的请求/响应周期数3）最小化请求开销----削减上传大小4）最小化负载大小----削减响应、下载及缓存页面大小5）优化浏览器渲染----改善浏览器页面布局6）移动方面的优化----优化站点移动网络和设备方面的相关特性\r\n</p>\r\n<p>\r\n	温馨小提示：ngx_pagespeed环境安装：模块是一个开源模块，功能上与mod_pagespeed（Apache前端加速模块）相比稍有欠缺。Github上针对ngx_pagespeed Bugs的反馈更新很频繁，基本上都能很快得到解决，要是部署在生产环境需要谨慎。另，系统内GCC版本必须大于4.2。ngx_pagespeed更新频率较高，建议及时更新到最新版本，而且最好先部署在本地环境中，经过一番测试稳定后再上线生产环境。\r\n</p>\r\n<p>\r\n	PageSpeed旨在缩短网页加载的时间，减少网站服务器的带宽使用量。PageSpeed模块可以使用数量众多的重写\"过滤器\"，每个过滤器都可以选择性地开启/关闭，从而自动进行各种优化（比如，减小文档大小、减少HTTP请求数据、减少HTTP往返次数以及缩短DNS解析时间）。下面是ngx_pagespeed支持的其中一些过滤器，想了解支持的全部过滤器，请参阅官方文档。\r\n</p>\r\n<p>\r\n	1）Collapse Whitespace（压缩空白）：通过把HTML网页中的多处连续空白换成一处空白，减少带宽使用量。\r\n</p>\r\n<p>\r\n	2）Canonicalize JavaScript Libraries（规范化转换JavaScript库）：通过自动把流行的JavaScript库换成免费托管的JavaScript库（比如由谷歌托管），减少带宽使用量。\r\n</p>\r\n<p>\r\n	3）Combine CSS（合并CSS）：通过把多个CSS文件合并成一个CSS文件，减少HTTP请求数量。\r\n</p>\r\n<p>\r\n	4）Combine JavaScript（合并JavaScript）：通过把多个JavaScript文件合并成一个JavaScript文件，减少HTTP请求数量。\r\n</p>\r\n<p>\r\n	5）Elide Attributes（省略属性）：通过删除由默认属性指定的标签，缩小文档大小。\r\n</p>\r\n<p>\r\n	6）Extend Cache（扩展缓存）：通过优化网页资源的可缓存性，减少带宽使用量。\r\n</p>\r\n<p>\r\n	7）Flatten CSS Imports（精简CSS导入）：通过删除CSS文件中的@import，减少HTTP请求往返次数。\r\n</p>\r\n<p>\r\n	8）Lazyload Images（延时加载图片）：延时加载在客户端浏览器上看不见的图片。\r\n</p>\r\n<p>\r\n	9）Minify JavaScript（缩小JavaScript）：通过缩小JavaScript，减少带宽使用量。\r\n</p>\r\n<p>\r\n	10）Optimize Images（优化图片）：通过引入更多的内嵌图片、压缩图片，或者将GIF图片转换成PNG图片，优化图片分发。\r\n</p>\r\n<p>\r\n	11）Pre-Resolve DNS（预解析DNS）：通过预解析DNS，缩短DNS解析时间。\r\n</p>\r\n<p>\r\n	12）Prioritize Critical CSS（优化加载关键CSS规则）：重写CSS文件，以便首先加载渲染页面的CSS规则。\r\n</p>\r\n<p>\r\n	与Apache网站服务器不一样，Nginx模块无法在运行时动态加载，而是必须在编译时加载。ngx_pagespeed模块并未内置在随主要Linux发行版（比如Fedora 19）发布的Nginx程序包中，所以说想使用Nginx中的PageSpeed，必须利用源代码来构建Nginx。\r\n</p>\r\n<p>\r\n	ngx_pagespeed环境安装：（提前yum install gcc-c++ pcre-devel zlib-devel make wget ）相关包下载地址：https://pan.baidu.com/s/1dFCCleL提取密码：h7ku\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# cd /usr/local/src/\r\n</p>\r\n<p>\r\n	[root@bastion-IDC src]# wget https://github.com/pagespeed/ngx_pagespeed/archive/release-1.6.29.5-beta.zip\r\n</p>\r\n<p>\r\n	[root@bastion-IDC src]# unzip release-1.6.29.5-beta.zip\r\n</p>\r\n<p>\r\n	[root@bastion-IDC src]# cd ngx_pagespeed-release-1.6.29.5-beta/\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ngx_pagespeed-release-1.6.29.5-beta]# wget https://dl.google.com/dl/page-speed/psol/1.6.29.5.tar.gz\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ngx_pagespeed-release-1.6.29.5-beta]# tar -zvxf 1.6.29.5.tar.gz\r\n</p>\r\n<p>\r\n	然后重新编译nginx，编译时跟上--add-module= /usr/local/src/ngx_pagespeed-release-1.6.29.5-beta模块参数\r\n</p>\r\n<p>\r\n	cd nginx-1.9.7\r\n</p>\r\n<p>\r\n	./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --add-module= /usr/local/src/ngx_pagespeed-release-1.6.29.5-beta\r\n</p>\r\n<p>\r\n	make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	使用ngx_pagespeed\r\n</p>\r\n<p>\r\n	# mkdir /var/ngx_pagespeed_cache\r\n</p>\r\n<p>\r\n	# chown www.www /var/ngx_pagespeed_cache                         //www是nginx服务启动用户\r\n</p>\r\n<p>\r\n	# cp /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf.bak\r\n</p>\r\n<p>\r\n	# vim  /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	# 启用ngx_pagespeed\r\n</p>\r\n<p>\r\n	pagespeed on;\r\n</p>\r\n<p>\r\n	pagespeed FileCachePath /var/ngx_pagespeed_cache;\r\n</p>\r\n<p>\r\n	# 启用CoreFilters\r\n</p>\r\n<p>\r\n	pagespeed RewriteLevel CoreFilters;\r\n</p>\r\n<p>\r\n	# 禁用CoreFilters中的某些过滤器\r\n</p>\r\n<p>\r\n	pagespeed DisableFilters rewrite_images;\r\n</p>\r\n<p>\r\n	# 选择性地启用额外的过滤器\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters local_storage_cache;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters collapse_whitespace,remove_comments;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters outline_css;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters flatten_css_imports;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters move_css_above_scripts;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters move_css_to_head;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters outline_javascript;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters combine_javascript;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters combine_css;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters rewrite_javascript;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters rewrite_css,sprite_images;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters rewrite_style_attributes;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters recompress_images;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters resize_images;\r\n</p>\r\n<p>\r\n	pagespeed EnableFilters convert_meta_tags;\r\n</p>\r\n<p>\r\n	location ~ \"\\.pagespeed\\.([a-z]\\.)?[a-z]{2}\\.[^.]{10}\\.[^.]+\" { add_header \"\" \"\"; }\r\n</p>\r\n<p>\r\n	location ~ \"^/ngx_pagespeed_static/\" { }\r\n</p>\r\n<p>\r\n	location ~ \"^/ngx_pagespeed_beacon$\" { }\r\n</p>\r\n<p>\r\n	location /ngx_pagespeed_statistics { allow 127.0.0.1; deny all; }\r\n</p>\r\n<p>\r\n	location /ngx_pagespeed_message { allow 127.0.0.1; deny all; }\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# /usr/local/nginx/sbin/nginx -t\r\n</p>\r\n<p>\r\n	# /usr/local/nginx/sbin/nginx\r\n</p>\r\n<p>\r\n	可以参阅官方文档CoreFilters中的过滤器。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('5d253e75-45ab-4755-8832-2fd602381dfd','MySQL高可用架构-MMM环境部署记录','MySQL高可用架构-MMM环境部署记录','<p>\r\n	MMM介绍MMM（Master-Master replication manager for MySQL）是一套支持双主故障切换和双主日常管理的脚本程序。MMM使用Perl语言开发，主要用来监控和管理MySQL Master-Master（双主）复制，可以说是mysql主主复制管理器。虽然叫做双主复制，但是业务上同一时刻只允许对一个主进行写入，另一台备选主上提供部分读服务，以加速在主主切换时刻备选主的预热，可以说MMM这套脚本程序一方面实现了故障切换的功能，另一方面其内部附加的工具脚本也可以实现多个slave的read负载均衡。关于mysql主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件（在任何时候只有一个节点可以被写入），这个套件也能对居于标准的主从配置的任意数量的从服务器进行读负载均衡，所以你可以用它来在一组居于复制的服务器启动虚拟ip，除此之外，它还有实现数据备份、节点之间重新同步功能的脚本。\r\n</p>\r\n<p>\r\n	MMM提供了自动和手动两种方式移除一组服务器中复制延迟较高的服务器的虚拟ip，同时它还可以备份数据，实现两节点之间的数据同步等。由于MMM无法完全的保证数据一致性，所以MMM适用于对数据的一致性要求不是很高，但是又想最大程度的保证业务可用性的场景。MySQL本身没有提供replication failover的解决方案，通过MMM方案能实现服务器的故障转移，从而实现mysql的高可用。对于那些对数据的一致性要求很高的业务，非常不建议采用MMM这种高可用架构。\r\n</p>\r\n<p>\r\n	从网上分享一个Mysql-MMM的内部架构图：\r\n</p>\r\n<p>\r\n	MySQL-MMM优缺点\r\n</p>\r\n<p>\r\n	优点：高可用性，扩展性好，出现故障自动切换，对于主主同步，在同一时间只提供一台数据库写操作，保证的数据的一致性。\r\n</p>\r\n<p>\r\n	缺点：Monitor节点是单点，可以结合Keepalived实现高可用。\r\n</p>\r\n<p>\r\n	MySQL-MMM工作原理\r\n</p>\r\n<p>\r\n	MMM(Master-Master replication managerfor Mysql，Mysql主主复制管理器)是一套灵活的脚本程序，基于perl实现，用来对mysql replication进行监控和故障迁移，\r\n</p>\r\n<p>\r\n	并能管理mysql Master-Master复制的配置(同一时间只有一个节点是可写的)。\r\n</p>\r\n<p>\r\n	mmm_mond：监控进程，负责所有的监控工作，决定和处理所有节点角色活动。此脚本需要在监管机上运行。\r\n</p>\r\n<p>\r\n	mmm_agentd：运行在每个mysql服务器上(Master和Slave)的代理进程，完成监控的探针工作和执行简单的远端服务设置。此脚本需要在被监管机上运行。\r\n</p>\r\n<p>\r\n	mmm_control：一个简单的脚本，提供管理mmm_mond进程的命令。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql-mmm的监管端会提供多个虚拟IP（VIP），包括一个可写VIP，多个可读VIP，通过监管的管理，这些IP会绑定在可用mysql之上，当某一台mysql宕机时，监管会将VIP迁移\r\n</p>\r\n<p>\r\n	至其他mysql。在整个监管过程中，需要在mysql中添加相关授权用户，以便让mysql可以支持监理机的维护。授权的用户包括一个mmm_monitor用户和一个mmm_agent用户，如果\r\n</p>\r\n<p>\r\n	想使用mmm的备份工具则还要添加一个mmm_tools用户。\r\n</p>\r\n<p>\r\n	MySQL-MMM高可用架构环境部署记录(自动切换读写分离)\r\n</p>\r\n<p>\r\n	0）机器配置信息\r\n</p>\r\n<p>\r\n	角色                  ip地址                 主机名字                  server-id\r\n</p>\r\n<p>\r\n	monitoring           182.48.115.233         mmm-monit                -\r\n</p>\r\n<p>\r\n	master1              182.48.115.236         db-master1               1\r\n</p>\r\n<p>\r\n	master2              182.48.115.237         db-master2               2\r\n</p>\r\n<p>\r\n	slave1               182.48.115.238         db-slave                 3\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	业务中的服务ip（vip）信息如下所示：\r\n</p>\r\n<p>\r\n	ip地址                     角色             描述\r\n</p>\r\n<p>\r\n	182.48.115.234            write           应用程序连接该ip对主库进行写请求\r\n</p>\r\n<p>\r\n	182.48.115.235            read            应用程序连接该ip进行读请求\r\n</p>\r\n<p>\r\n	182.48.115.239            read            应用程序连接该ip进行读请求\r\n</p>\r\n<p>\r\n	1）配置/etc/hosts（所有机器都要操作）\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/hosts\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	182.48.115.233   mmm-monit\r\n</p>\r\n<p>\r\n	182.48.115.236   db-master1\r\n</p>\r\n<p>\r\n	182.48.115.237   db-master2\r\n</p>\r\n<p>\r\n	182.48.115.238   db-slave\r\n</p>\r\n<p>\r\n	2）首先在3台主机上安装mysql，部署复制环境\r\n</p>\r\n<p>\r\n	其中：182.48.115.236和182.48.115.237互为主从，182.48.115.238为1182.48.115.236的从\r\n</p>\r\n<p>\r\n	........................................................................\r\n</p>\r\n<p>\r\n	mysql安装参考：http://www.cnblogs.com/kevingrace/p/6109679.html\r\n</p>\r\n<p>\r\n	mysql主从/主主配置参考：http://www.cnblogs.com/kevingrace/p/6256603.html\r\n</p>\r\n<p>\r\n	........................................................................\r\n</p>\r\n<p>\r\n	---------182.48.115.236的my.cnf添加配置---------\r\n</p>\r\n<p>\r\n	server-id = 1\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	log_slave_updates = 1\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 1\r\n</p>\r\n<p>\r\n	---------182.48.115.237的my.cnf添加配置---------\r\n</p>\r\n<p>\r\n	server-id = 2\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	log_slave_updates = 1\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 2\r\n</p>\r\n<p>\r\n	---------182.48.115.238的my.cnf添加配置---------\r\n</p>\r\n<p>\r\n	server-id = 3\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	log_slave_updates = 1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	上面的server-id不一定要按顺序来，只要没有重复即可。\r\n</p>\r\n<p>\r\n	然后182.48.115.236和182.48.115.237相互授权连接；182.48.115.236授权给182.48.115.238连接。\r\n</p>\r\n<p>\r\n	最后通过\"change master....\"做对应的主主和主从复制，具体操作步骤在此省略，可以参考上面给出的文档。\r\n</p>\r\n<p>\r\n	3）安装MMM（所有机器上都要执行）\r\n</p>\r\n<p>\r\n	.......先安装MMM所需要的Perl模块.......\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# vim install.sh        //在所有机器上执行下面的安装脚本\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	wget http://xrl.us/cpanm --no-check-certificate\r\n</p>\r\n<p>\r\n	mv cpanm /usr/bin\r\n</p>\r\n<p>\r\n	chmod 755 /usr/bin/cpanm\r\n</p>\r\n<p>\r\n	cat &gt; /root/list &lt;&lt; EOF\r\n</p>\r\n<p>\r\n	install Algorithm::Diff\r\n</p>\r\n<p>\r\n	install Class::Singleton\r\n</p>\r\n<p>\r\n	install DBI\r\n</p>\r\n<p>\r\n	install DBD::mysql\r\n</p>\r\n<p>\r\n	install File::Basename\r\n</p>\r\n<p>\r\n	install File::stat\r\n</p>\r\n<p>\r\n	install File::Temp\r\n</p>\r\n<p>\r\n	install Log::Dispatch\r\n</p>\r\n<p>\r\n	install Log::Log4perl\r\n</p>\r\n<p>\r\n	install Mail::Send\r\n</p>\r\n<p>\r\n	install Net::ARP\r\n</p>\r\n<p>\r\n	install Net::Ping\r\n</p>\r\n<p>\r\n	install Proc::Daemon\r\n</p>\r\n<p>\r\n	install Thread::Queue\r\n</p>\r\n<p>\r\n	install Time::HiRes\r\n</p>\r\n<p>\r\n	EOF\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for package in `cat /root/list`\r\n</p>\r\n<p>\r\n	do\r\n</p>\r\n<p>\r\n	cpanm $package\r\n</p>\r\n<p>\r\n	done\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# chmod 755 install.sh\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# ./install.sh\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	.........下载mysql-mmm软件，在所有服务器上安装............\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# wget http://mysql-mmm.org/_media/:mmm2:mysql-mmm-2.2.1.tar.gz\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# mv :mmm2:mysql-mmm-2.2.1.tar.gz mysql-mmm-2.2.1.tar.gz\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# tar -zvxf mysql-mmm-2.2.1.tar.gz\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# cd mysql-mmm-2.2.1\r\n</p>\r\n<p>\r\n	[root@db-master1 mysql-mmm-2.2.1]# make install\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql-mmm安装后的主要拓扑结构如下所示（注意：yum安装的和源码安装的路径有所区别）：\r\n</p>\r\n<p>\r\n	/usr/lib/perl5/vendor_perl/5.8.8/MMM                    MMM使用的主要perl模块\r\n</p>\r\n<p>\r\n	/usr/lib/mysql-mmm                                      MMM使用的主要脚本\r\n</p>\r\n<p>\r\n	/usr/sbin                                               MMM使用的主要命令的路径\r\n</p>\r\n<p>\r\n	/etc/init.d/                                            MMM的agent和monitor启动服务的目录\r\n</p>\r\n<p>\r\n	/etc/mysql-mmm                                          MMM配置文件的路径，默认所以的配置文件位于该目录下\r\n</p>\r\n<p>\r\n	/var/log/mysql-mmm                                      默认的MMM保存日志的位置\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	到这里已经完成了MMM的基本需求，接下来需要配置具体的配置文件，其中mmm_common.conf，mmm_agent.conf为agent端的配置文件，mmm_mon.conf为monitor端的配置文件。\r\n</p>\r\n<p>\r\n	4）配置agent端的配置文件，需要在db-master1 ，db-master2，db-slave上分别配置(配置内容一样)\r\n</p>\r\n<p>\r\n	先在db-master1主机上配置agent的mmm_common.conf文件（这个在所有机器上都要配置,包括monitor机器）\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# cd /etc/mysql-mmm/\r\n</p>\r\n<p>\r\n	[root@db-master1 mysql-mmm]# cp mmm_common.conf  mmm_common.conf.bak\r\n</p>\r\n<p>\r\n	[root@db-master1 mysql-mmm]# vim mmm_common.conf\r\n</p>\r\n<p>\r\n	active_master_role      writer\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	cluster_interface               eth0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	pid_path                                /var/run/mmm_agentd.pid\r\n</p>\r\n<p>\r\n	bin_path                                /usr/lib/mysql-mmm/\r\n</p>\r\n<p>\r\n	replication_user                        slave                       //注意这个账号和下面一行的密码是在前面部署主主/主从复制时创建的复制账号和密码\r\n</p>\r\n<p>\r\n	replication_password                    slave@123\r\n</p>\r\n<p>\r\n	agent_user                              mmm_agent\r\n</p>\r\n<p>\r\n	agent_password                          mmm_agent\r\n</p>\r\n<p>\r\n	ip                                              182.48.115.236\r\n</p>\r\n<p>\r\n	mode                                            master\r\n</p>\r\n<p>\r\n	peer                                            db-master2\r\n</p>\r\n<p>\r\n	ip                                              182.48.115.237\r\n</p>\r\n<p>\r\n	mode                                            master\r\n</p>\r\n<p>\r\n	peer                                            db-master1\r\n</p>\r\n<p>\r\n	ip                                              182.48.115.238\r\n</p>\r\n<p>\r\n	mode                                            slave\r\n</p>\r\n<p>\r\n	hosts                                           db-master1, db-master2\r\n</p>\r\n<p>\r\n	ips                                             182.48.115.234\r\n</p>\r\n<p>\r\n	mode                                            exclusive\r\n</p>\r\n<p>\r\n	hosts                                           db-master2, db-slave\r\n</p>\r\n<p>\r\n	ips                                             182.48.115.235, 182.48.115.239\r\n</p>\r\n<p>\r\n	mode                                            balanced\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	配置解释，其中：\r\n</p>\r\n<p>\r\n	replication_user  用于检查复制的用户\r\n</p>\r\n<p>\r\n	agent_user为agent的用户\r\n</p>\r\n<p>\r\n	mode标明是否为主或者备选主，或者从库。\r\n</p>\r\n<p>\r\n	mode exclusive主为独占模式，同一时刻只能有一个主\r\n</p>\r\n<p>\r\n	中hosts表示目前的主库和备选主的真实主机ip或者主机名，ips为对外提供的虚拟机ip地址\r\n</p>\r\n<p>\r\n	中hosts代表从库真实的ip和主机名，ips代表从库的虚拟ip地址。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	可以直接把mmm_common.conf从db-master1拷贝到db-master2、db-slave和mmm-monit三台主机的/etc/mysql-mmm下。\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# scp /etc/mysql-mmm/mmm_common.conf db-master2:/etc/mysql-mmm/\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# scp /etc/mysql-mmm/mmm_common.conf db-slave:/etc/mysql-mmm/\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# scp /etc/mysql-mmm/mmm_common.conf mmm-monit:/etc/mysql-mmm/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	分别在db-master1，db-master2，db-slave三台主机的/etc/mysql-mmm配置mmm_agent.conf文件，分别用不同的字符标识。注意这个文件的this db1这行内容要修改\r\n</p>\r\n<p>\r\n	为各自的主机名。比如本环境中，db-master1要配置this db-master1，db-master2要配置为this db-master2，而db-slave要配置为this db-slave。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在db-master1（182.48.115.236）上：\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# vim /etc/mysql-mmm/mmm_agent.conf\r\n</p>\r\n<p>\r\n	include mmm_common.conf\r\n</p>\r\n<p>\r\n	this db-master1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在db-master2（182.48.115.237）上：\r\n</p>\r\n<p>\r\n	[root@db-master2 ~]# vim /etc/mysql-mmm/mmm_agent.conf\r\n</p>\r\n<p>\r\n	include mmm_common.conf\r\n</p>\r\n<p>\r\n	this db-master2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在db-slave（182.48.115.238）上：\r\n</p>\r\n<p>\r\n	[root@db-slave ~]# vim /etc/mysql-mmm/mmm_agent.conf\r\n</p>\r\n<p>\r\n	include mmm_common.conf\r\n</p>\r\n<p>\r\n	this db-slave\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	接着在mmm-monit（182.48.115.233）配置monitor的配置文件：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cp /etc/mysql-mmm/mmm_mon.conf  /etc/mysql-mmm/mmm_mon.conf.bak\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# vim /etc/mysql-mmm/mmm_mon.conf\r\n</p>\r\n<p>\r\n	include mmm_common.conf\r\n</p>\r\n<p>\r\n	ip                  182.48.115.233\r\n</p>\r\n<p>\r\n	pid_path            /var/run/mysql-mmm/mmm_mond.pid\r\n</p>\r\n<p>\r\n	bin_path            /usr/libexec/mysql-mmm\r\n</p>\r\n<p>\r\n	status_path         /var/lib/mysql-mmm/mmm_mond.status\r\n</p>\r\n<p>\r\n	ping_ips            182.48.115.238,182.48.115.237,182.48.115.236\r\n</p>\r\n<p>\r\n	auto_set_online     10               //发现节点丢失，则过10秒进行切换\r\n</p>\r\n<p>\r\n	monitor_user        mmm_monitor\r\n</p>\r\n<p>\r\n	monitor_password    mmm_monitor\r\n</p>\r\n<p>\r\n	debug 0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这里只在原有配置文件中的ping_ips添加了整个架构被监控主机的ip地址，而在中配置了用于监控的用户。\r\n</p>\r\n<p>\r\n	5）创建监控用户，这里需要创建3个监控用户\r\n</p>\r\n<p>\r\n	具体描述：\r\n</p>\r\n<p>\r\n	用户名                 描述                                               权限\r\n</p>\r\n<p>\r\n	monitor user          MMM的monitor端监控所有的mysql数据库的状态用户           REPLICATION CLIENT\r\n</p>\r\n<p>\r\n	agent user            主要是MMM客户端用于改变的master的read_only状态用户      SUPER,REPLICATION CLIENT,PROCESS\r\n</p>\r\n<p>\r\n	repl                  用于复制的用户                                       REPLICATION SLAVE\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在3台服务器(db-master1,db-master2,db-slave）进行授权，因为之前部署的主主复制，以及主从复制已经是ok的，所以这里在其中一台服务器执行就ok了,执行后\r\n</p>\r\n<p>\r\n	权限会自动同步到其它两台机器上。用于复制的账号之前已经有了，所以这里就授权两个账号。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在db-master1上进行授权操作：\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT SUPER, REPLICATION CLIENT, PROCESS ON *.* TO \'mmm_agent\'@\'182.48.115.%\'   IDENTIFIED BY \'mmm_agent\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT REPLICATION CLIENT ON *.* TO \'mmm_monitor\'@\'182.48.115.%\' IDENTIFIED BY \'mmm_monitor\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后在db-master2和db-slave两台机器上查看，发现上面在db-master1机器上授权的账号已经同步过来了！\r\n</p>\r\n<p>\r\n	6）启动agent和monitor服务\r\n</p>\r\n<p>\r\n	最后分别在db-master1，db-master2，db-slave上启动agent\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# /etc/init.d/mysql-mmm-agent start     //将start替换成status，则查看agent进程起来了没？\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_agentd\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_agentd.pid\'\r\n</p>\r\n<p>\r\n	Starting MMM Agent daemon... Ok\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@db-master2 ~]# /etc/init.d/mysql-mmm-agent start\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_agentd\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_agentd.pid\'\r\n</p>\r\n<p>\r\n	Starting MMM Agent daemon... Ok\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@db-slave ~]# /etc/init.d/mysql-mmm-agent start\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_agentd\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_agentd.pid\'\r\n</p>\r\n<p>\r\n	Starting MMM Agent daemon... Ok\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	接着在mmm-monit上启动monitor程序\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mkdir /var/run/mysql-mmm\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# /etc/init.d/mysql-mmm-monitor start\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_mond\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_mond.pid\'\r\n</p>\r\n<p>\r\n	Starting MMM Monitor daemon: Ok\r\n</p>\r\n<p>\r\n	........................................................................................................\r\n</p>\r\n<p>\r\n	如果monitor程序启动出现如下报错：\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_mond\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_mond.pid\'\r\n</p>\r\n<p>\r\n	Starting MMM Monitor daemon: Base class package \"Class::Singleton\" is empty.\r\n</p>\r\n<p>\r\n	(Perhaps you need to \'use\' the module which defines that package first,\r\n</p>\r\n<p>\r\n	or make that module available in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .).\r\n</p>\r\n<p>\r\n	at /usr/share/perl5/vendor_perl/MMM/Monitor/Agents.pm line 2\r\n</p>\r\n<p>\r\n	BEGIN failed--compilation aborted at /usr/share/perl5/vendor_perl/MMM/Monitor/Agents.pm line 2.\r\n</p>\r\n<p>\r\n	Compilation failed in require at /usr/share/perl5/vendor_perl/MMM/Monitor/Monitor.pm line 15.\r\n</p>\r\n<p>\r\n	BEGIN failed--compilation aborted at /usr/share/perl5/vendor_perl/MMM/Monitor/Monitor.pm line 15.\r\n</p>\r\n<p>\r\n	Compilation failed in require at /usr/sbin/mmm_mond line 28.\r\n</p>\r\n<p>\r\n	BEGIN failed--compilation aborted at /usr/sbin/mmm_mond line 28.\r\n</p>\r\n<p>\r\n	failed\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e shell\r\n</p>\r\n<p>\r\n	...............................................\r\n</p>\r\n<p>\r\n	如是执行这个命令后，有如下报错：\r\n</p>\r\n<p>\r\n	Can\'t locate CPAN.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .).\r\n</p>\r\n<p>\r\n	BEGIN failed--compilation aborted.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解决：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# rpm -q perl-CPAN\r\n</p>\r\n<p>\r\n	package perl-CPAN is not installed\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# yum install perl-CPAN\r\n</p>\r\n<p>\r\n	...............................................\r\n</p>\r\n<p>\r\n	执行上面的\"perl -MCPAN -e shell\"命令后，出现下面的安装命令\r\n</p>\r\n<p>\r\n	......\r\n</p>\r\n<p>\r\n	cpan[1]&gt; install MIME::Entity          //依次输入这些安装命令\r\n</p>\r\n<p>\r\n	cpan[2]&gt; install MIME::Parser\r\n</p>\r\n<p>\r\n	cpan[3]&gt; install Crypt::PasswdMD5\r\n</p>\r\n<p>\r\n	cpan[4]&gt; install Term::ReadPassword\r\n</p>\r\n<p>\r\n	cpan[5]&gt; install Crypt::CBC\r\n</p>\r\n<p>\r\n	cpan[6]&gt; install Crypt::Blowfish\r\n</p>\r\n<p>\r\n	cpan[7]&gt; install Daemon::Generic\r\n</p>\r\n<p>\r\n	cpan[8]&gt; install DateTime\r\n</p>\r\n<p>\r\n	cpan[9]&gt; install SOAP::Lite\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	或者直接执行下面的安装命令的命令也行：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install HTML::Template\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install MIME::Entity\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install Crypt::PasswdMD5\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install Term::ReadPassword\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install Crypt::CBC\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install Crypt::Blowfish\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install Daemon::Generic\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install DateTime\'\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# perl -MCPAN -e \'install SOAP::Lite\'\r\n</p>\r\n<p>\r\n	............................................................................................................\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	monitor进程启动后，如下查看，发现进程并没有起来！\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# /etc/init.d/mysql-mmm-monitor status\r\n</p>\r\n<p>\r\n	Daemon bin: \'/usr/sbin/mmm_mond\'\r\n</p>\r\n<p>\r\n	Daemon pid: \'/var/run/mmm_mond.pid\'\r\n</p>\r\n<p>\r\n	Checking MMM Monitor process: not running.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	将mmm_mon.conf的debug模式开启设为1，即打开debug模式，然后执行:\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# /etc/init.d/mysql-mmm-monitor start\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	open2: exec of /usr/libexec/mysql-mmm/monitor/checker  ping_ip failed at /usr/share/perl5/vendor_perl/MMM/Monitor/Checker.pm line 143.\r\n</p>\r\n<p>\r\n	2017/06/01 20:16:02  WARN Checker \'ping_ip\' is dead!\r\n</p>\r\n<p>\r\n	2017/06/01 20:16:02  INFO Spawning checker \'ping_ip\'...\r\n</p>\r\n<p>\r\n	2017/06/01 20:16:02 DEBUG Core: reaped child 17439 with exit 65280\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	原因是mmm_mon.conf文件里check的bin_path路径写错了\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/mysql-mmm/mmm_mon.conf|grep bin_path\r\n</p>\r\n<p>\r\n	bin_path            /usr/libexec/mysql-mmm\r\n</p>\r\n<p>\r\n	将上面的bin_path改为/usr/lib/mysql-mmm 即可解决！即：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/mysql-mmm/mmm_mon.conf|grep bin_path\r\n</p>\r\n<p>\r\n	bin_path            /usr/lib/mysql-mmm\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	接着再次启动monitor进程\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# /etc/init.d/mysql-mmm-monitor start\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	FATAL Couldn\'t open status file \'/var/lib/mysql-mmm/mmm_mond.status\': Starting up without status inf\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	Error in tempfile() using template /var/lib/mysql-mmm/mmm_mond.statusXXXXXXXXXX: Parent directory (/var/lib/mysql-mmm/) does not exist at /usr/share/perl5/vendor_perl/MMM/Monitor/Agents.pm line 158.\r\n</p>\r\n<p>\r\n	Perl exited with active threads:\r\n</p>\r\n<p>\r\n	6 running and unjoined\r\n</p>\r\n<p>\r\n	0 finished and unjoined\r\n</p>\r\n<p>\r\n	0 running and detached\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	原因是mmm_mon.conf文件里check的status_path路径写错了\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/mysql-mmm/mmm_mon.conf |grep status_path\r\n</p>\r\n<p>\r\n	status_path         /var/lib/mysql-mmm/mmm_mond.status\r\n</p>\r\n<p>\r\n	将上面的status_path改为/var/lib/misc//mmm_mond.status 即可解决！即：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/mysql-mmm/mmm_mon.conf|grep status_path\r\n</p>\r\n<p>\r\n	status_path         /var/lib/misc/mmm_mond.status\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后再次启动monitor进程\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# /etc/init.d/mysql-mmm-monitor restart\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Sending command \'SET_STATUS(ONLINE, reader(182.48.115.235), db-master1)\' to db-master2 (182.48.115.237:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Received Answer: OK: Status applied successfully!|UP:885492.82\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Sending command \'SET_STATUS(ONLINE, writer(182.48.115.234), db-master1)\' to db-master1 (182.48.115.236:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Received Answer: OK: Status applied successfully!|UP:65356.14\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Sending command \'SET_STATUS(ONLINE, reader(182.48.115.239), db-master1)\' to db-slave (182.48.115.238:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:14 DEBUG Received Answer: OK: Status applied successfully!|UP:945625.05\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:15 DEBUG Listener: Waiting for connection...\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Sending command \'SET_STATUS(ONLINE, reader(182.48.115.235), db-master1)\' to db-master2 (182.48.115.237:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Received Answer: OK: Status applied successfully!|UP:885495.95\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Sending command \'SET_STATUS(ONLINE, writer(182.48.115.234), db-master1)\' to db-master1 (182.48.115.236:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Received Answer: OK: Status applied successfully!|UP:65359.27\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Sending command \'SET_STATUS(ONLINE, reader(182.48.115.239), db-master1)\' to db-slave (182.48.115.238:9989)\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:17 DEBUG Received Answer: OK: Status applied successfully!|UP:945628.17\r\n</p>\r\n<p>\r\n	2017/06/01 20:57:18 DEBUG Listener: Waiting for connection...\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	只要上面在启动过程中的check检查中没有报错信息，并且有successfully信息，则表示monitor进程正常了。\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# ps -ef|grep monitor\r\n</p>\r\n<p>\r\n	root     30651 30540  0 20:59 ?        00:00:00 perl /usr/lib/mysql-mmm/monitor/checker ping_ip\r\n</p>\r\n<p>\r\n	root     30654 30540  0 20:59 ?        00:00:00 perl /usr/lib/mysql-mmm/monitor/checker mysql\r\n</p>\r\n<p>\r\n	root     30656 30540  0 20:59 ?        00:00:00 perl /usr/lib/mysql-mmm/monitor/checker ping\r\n</p>\r\n<p>\r\n	root     30658 30540  0 20:59 ?        00:00:00 perl /usr/lib/mysql-mmm/monitor/checker rep_backlog\r\n</p>\r\n<p>\r\n	root     30660 30540  0 20:59 ?        00:00:00 perl /usr/lib/mysql-mmm/monitor/checker rep_threads\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	那么，最终mmm_mon.cnf文件的配置如下：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# cat /etc/mysql-mmm/mmm_mon.conf\r\n</p>\r\n<p>\r\n	include mmm_common.conf\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ip                  182.48.115.233\r\n</p>\r\n<p>\r\n	pid_path            /var/run/mysql-mmm/mmm_mond.pid\r\n</p>\r\n<p>\r\n	bin_path            /usr/lib/mysql-mmm\r\n</p>\r\n<p>\r\n	status_path         /var/lib/misc/mmm_mond.status\r\n</p>\r\n<p>\r\n	ping_ips            182.48.115.238,182.48.115.237,182.48.115.236\r\n</p>\r\n<p>\r\n	auto_set_online     10\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	monitor_user        mmm_monitor\r\n</p>\r\n<p>\r\n	monitor_password    mmm_monitor\r\n</p>\r\n<p>\r\n	debug 1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# ll /var/lib/misc/mmm_mond.status\r\n</p>\r\n<p>\r\n	-rw-------. 1 root root 121 6月   1 21:06 /var/lib/misc/mmm_mond.status\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# ll /var/run/mysql-mmm/mmm_mond.pid\r\n</p>\r\n<p>\r\n	-rw-r--r--. 1 root root 5 6月   1 20:59 /var/run/mysql-mmm/mmm_mond.pid\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\r\n</p>\r\n<p>\r\n	其中agent的日志存放在/var/log/mysql-mmm/mmm_agentd.log，monitor日志放在/var/log/mysql-mmm/mmm_mond.log，\r\n</p>\r\n<p>\r\n	启动过程中有什么问题，通常日志都会有详细的记录。\r\n</p>\r\n<p>\r\n	7）在monitor主机上检查集群主机的状态\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control checks all\r\n</p>\r\n<p>\r\n	db-master2  ping         [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master2  mysql        [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master2  rep_threads  [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master2  rep_backlog  [last change: 2017/06/01 20:59:39]  OK: Backlog is null\r\n</p>\r\n<p>\r\n	db-master1  ping         [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master1  mysql        [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master1  rep_threads  [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-master1  rep_backlog  [last change: 2017/06/01 20:59:39]  OK: Backlog is null\r\n</p>\r\n<p>\r\n	db-slave    ping         [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-slave    mysql        [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-slave    rep_threads  [last change: 2017/06/01 20:59:39]  OK\r\n</p>\r\n<p>\r\n	db-slave    rep_backlog  [last change: 2017/06/01 20:59:39]  OK: Backlog is null\r\n</p>\r\n<p>\r\n	8）在monitor主机上检查集群环境在线状况\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles: writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后到mmm agent机器上查看，就会发现vip已经绑定了\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:5f:58:dc brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.236/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.234/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe5f:58dc/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@db-master2 mysql-mmm]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:1b:6e:53 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.237/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.235/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe1b:6e53/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@db-slave ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:ca:d5:f8 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.238/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.239/27 brd 182.48.115.255 scope global secondary eth0:1\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:feca:d5f8/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	从上面输出信息中可以看出，虚拟ip已经绑定到各agent上了。其中：\r\n</p>\r\n<p>\r\n	182.48.115.234顺利添加到182.48.115.236上作为主对外提供写服务\r\n</p>\r\n<p>\r\n	182.48.115.235顺利添加到182.48.115.237上作为主对外提供读服务\r\n</p>\r\n<p>\r\n	182.48.115.239顺利添加到182.48.115.238上作为主对外提供读服务\r\n</p>\r\n<p>\r\n	9）online（上线）所有主机\r\n</p>\r\n<p>\r\n	这里主机已经在线了，如果没有在线，可以使用下面的命令将相关主机online\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control set_online db-master1\r\n</p>\r\n<p>\r\n	OK: This host is already ONLINE. Skipping command.\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control set_online db-master2\r\n</p>\r\n<p>\r\n	OK: This host is already ONLINE. Skipping command.\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control set_online db-slave\r\n</p>\r\n<p>\r\n	OK: This host is already ONLINE. Skipping command.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	提示主机已经在线，已经跳过命令执行了。到这里整个集群就配置完成了。\r\n</p>\r\n<p>\r\n	--------------------------------------------------MMM高可用测试-------------------------------------------------------已经完成高可用环境的搭建了，下面我们就可以做MMM的HA测试咯。\r\n</p>\r\n<p>\r\n	首先查看整个集群的状态，可以看到整个集群状态正常。\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles: writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	1）模拟db-master2（182.48.115.237）宕机，手动停止mysql服务.\r\n</p>\r\n<p>\r\n	[root@db-master2 ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL.... SUCCESS!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在mmm-monit机器上观察monitor日志\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# tail -f /var/log/mysql-mmm/mmm_mond.log\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	2017/06/01 21:28:17 FATAL State of host \'db-master2\' changed from ONLINE to HARD_OFFLINE (ping: OK, mysql: not OK)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	重新查看mmm集群的最新状态：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles: writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/HARD_OFFLINE. Roles:\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.235), reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现之前添加到db-master2对外提供读服务器的虚拟ip，即182.48.115.235已经漂移到db-slave机器上了.\r\n</p>\r\n<p>\r\n	[root@db-slave ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:ca:d5:f8 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.238/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.235/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.239/27 brd 182.48.115.255 scope global secondary eth0:1\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:feca:d5f8/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	测试mysql数据同步：\r\n</p>\r\n<p>\r\n	虽然db-master2机器的mysql服务关闭，但是由于它的vip漂移到db-slave机器上了，所以此时db-master1和db-slave这个时候是主从复制关系。\r\n</p>\r\n<p>\r\n	在db-master1数据库里更新数据，会自动更新到db-slave数据库里。\r\n</p>\r\n<p>\r\n	------------------\r\n</p>\r\n<p>\r\n	接着重启db-master2的mysql服务，可以看到db-master2由HARD_OFFLINE转到AWAITING_RECOVERY。这时候db-master2再次接管读请求。\r\n</p>\r\n<p>\r\n	[root@db-master2 ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在mmm-monit机器上观察monitor日志\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# tail -f /var/log/mysql-mmm/mmm_mond.log\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	2017/06/01 21:36:00 FATAL State of host \'db-master2\' changed from HARD_OFFLINE to AWAITING_RECOVERY\r\n</p>\r\n<p>\r\n	2017/06/01 21:36:12 FATAL State of host \'db-master2\' changed from AWAITING_RECOVERY to ONLINE because of auto_set_online(10 seconds). It was in state AWAITING_RECOVERY for 12 seconds\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles: writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@db-master2 mysql-mmm]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:1b:6e:53 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.237/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.235/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe1b:6e53/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现之前的vip资源又回到了db-master2机器上，db-master2重新接管了服务。并且db-master2恢复后，在故障期间更新的数据也会自动和其它两台机器同步！\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）模拟db-master1主库宕机,手动关闭mysql服务\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL.... SUCCESS!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在mmm-monit机器上观察monitor日志\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# tail -f /var/log/mysql-mmm/mmm_mond.log\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	2017/06/01 21:43:36 FATAL State of host \'db-master1\' changed from ONLINE to HARD_OFFLINE (ping: OK, mysql: not OK)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看mmm集群状态：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/HARD_OFFLINE. Roles:\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235), writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	从上面可以发现，db-master1由以前的ONLINE转化为HARD_OFFLINE，移除了写角色，因为db-master2是备选主，所以接管了写角色，db-slave指向新的主库db-master2，\r\n</p>\r\n<p>\r\n	应该说db-slave实际上找到了db-master2的sql现在的位置，即db-master2的show master返回的值，然后直接在db-slave上change master to到db-master2。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	db-master2机器上可以发现，db-master1对外提供写服务的vip漂移过来了\r\n</p>\r\n<p>\r\n	[root@db-master2 mysql-mmm]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:1b:6e:53 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.237/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.235/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.234/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe1b:6e53/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这个时候，在db-master2数据库里更新数据，db-slave数据库会自动同步过去。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	------------------------\r\n</p>\r\n<p>\r\n	接着重启db-master1的mysql\r\n</p>\r\n<p>\r\n	[root@db-master1 ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在mmm-monit机器上观察monitor日志\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# tail -f /var/log/mysql-mmm/mmm_mond.log\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	2017/06/01 21:52:14 FATAL State of host \'db-master1\' changed from HARD_OFFLINE to AWAITING_RECOVERY\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	再次查看mmm集群状态（发现写服务的vip转移到db-master2上了）：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles:\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235), writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/ONLINE. Roles: reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现db-master1虽然恢复了，并已经上线在集群中，但是其之前绑定的写服务的vip并没有从db-master2上转移回来，即db-master1恢复后没有重新接管服务。\r\n</p>\r\n<p>\r\n	只有等到db-master2发生故障时，才会把182.48.115.234的写服务的vip转移到db-master1上，同时把182.48.115.235的读服务的vip转移到db-slave\r\n</p>\r\n<p>\r\n	机器上（然后db-master2恢复后，就会把转移到db-slave上的182.48.115.235的读服务的vip再次转移回来）。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	再接着模拟db-slave从库宕机，手动关闭mysql服务\r\n</p>\r\n<p>\r\n	[root@db-slave ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL..                                      [确定]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在mmm-monit机器上观察monitor日志\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# tail -f /var/log/mysql-mmm/mmm_mond.log\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	2017/06/01 22:42:24 FATAL State of host \'db-slave\' changed from ONLINE to HARD_OFFLINE (ping: OK, mysql: not OK)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看mmm集群的最新状态：\r\n</p>\r\n<p>\r\n	[root@mmm-monit ~]# mmm_control show\r\n</p>\r\n<p>\r\n	db-master1(182.48.115.236) master/ONLINE. Roles: writer(182.48.115.234)\r\n</p>\r\n<p>\r\n	db-master2(182.48.115.237) master/ONLINE. Roles: reader(182.48.115.235), reader(182.48.115.239)\r\n</p>\r\n<p>\r\n	db-slave(182.48.115.238) slave/HARD_OFFLINE. Roles:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	发现db-slave发生故障后，其读服务的182.48.115.239的vip转移到db-master2上了。\r\n</p>\r\n<p>\r\n	[root@db-master2 mysql-mmm]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:1b:6e:53 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.48.115.237/27 brd 182.48.115.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.235/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.48.115.239/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe1b:6e53/64 scope link\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	当db-slave恢复后，读服务的vip还是再次转移回来，即重新接管服务。并且故障期间更新的数据会自动同步回来。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	需要注意：\r\n</p>\r\n<p>\r\n	db-master1，db-master2，db-slave之间为一主两从的复制关系，一旦发生db-master2，db-slave延时于db-master1时，这个时刻db-master1 mysql宕机，\r\n</p>\r\n<p>\r\n	db-slave将会等待数据追上db-master1后，再重新指向新的主db-master2，进行change master to db-master2操作，在db-master1宕机的过程中，一旦db-master2\r\n</p>\r\n<p>\r\n	落后于db-master1，这时发生切换，db-master2变成了可写状态，数据的一致性将会无法保证。\r\n</p>\r\n<p>\r\n	总结：MMM不适用于对数据一致性要求很高的环境。但是高可用完全做到了。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('5e96b3f9-4cc5-4eca-b370-9203de3e5afe','Tornado ui_modules ui_methods用法','Tornado ui_modules ui_methods用法','Tornado ui_modules ui_methods用法<br />\r\nsettings设置&nbsp;<br />\r\n这导入的是两个模块名也就是文件<br />\r\nimport mymodules<br />\r\nimport mymethods<br />\r\nsettings=dict(<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ui_modules= mymodules,<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ui_methods=mymethods,&nbsp;<br />\r\n）<br />\r\n#mymethods<br />\r\n#-*-coding:utf-8-*-<br />\r\ndef test1(self,*args,**kwargs):<br />\r\n&nbsp; &nbsp; &nbsp; return args<br />\r\n#mymethods<br />\r\n#-*-coding:utf-8-*-<br />\r\nimport tornado.web<br />\r\nclass &nbsp;test2(tornado.web.UIModule):<br />\r\n&nbsp; &nbsp; &nbsp; def render(self,*args,**kwargs):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return args<br />\r\nui_methods前端调用{{test1()}}{{mymethos里的方法名}}<br />\r\nui_modules前端调用{% modules test2()%}{{mymethos里的方法名}}<br />\r\nui_modules也可定义为字典形式<br />\r\nfrom &nbsp;mymodules &nbsp;classname,classnames &nbsp;<br />\r\nsettings=dict(<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ui_modules={\'module1\':classname,\'module1\':classname2}<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ui_methods=mymethods,&nbsp;<br />\r\n）<br />\r\n&nbsp;前端调用用key就{%module module1(*args)%}<br />','2017-08-01 10:55:29',2,5,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('5f969033-b9c1-4e5a-9d08-c5ca4556c164','mysql密码遗忘和登陆报错问题','mysql密码遗忘和登陆报错问题','<p>\r\n	mysql登录密码忘记，其实解决办法很简单，只需要在mysql的主配置文件my.cnf里添加一行“跳过授权表”的参数选择即可！\r\n</p>\r\n<p>\r\n	在my.cnf中添加下面一行：[root@test-huanqiu ~]# vim /etc/my.cnf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//在[mysqld]区域里添加........skip-grant-tables&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //跳过授权表\r\n</p>\r\n<p>\r\n	然后重启mysql服务，即可无密码登录[root@test-huanqiu ~]# /etc/init.d/mysqld restart\r\n</p>\r\n<p>\r\n	登录后重置密码\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# mysql mysql&gt; select host,user,password from mysql.user;+--------------------+------+-------------------------------------------+| host               | user | password                                  |+--------------------+------+-------------------------------------------+| localhost          | root | *481ACA1BD6D1E86221244904E9C0FABA33B40B84 || host-192-168-1-117 | root |                                           || 127.0.0.1          | root |                                           || ::1                | root |                                           || localhost          |      |                                           || host-192-168-1-117 |      |                                           |+--------------------+------+-------------------------------------------+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; update mysql.user set password=password(\"123456\") where host=\"localhost\" and user=\"root\";Query OK, 1 row affected (0.02 sec)Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select host,user,password from mysql.user;+--------------------+------+-------------------------------------------+| host               | user | password                                  |+--------------------+------+-------------------------------------------+| localhost          | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || host-192-168-1-117 | root |                                           || 127.0.0.1          | root |                                           || ::1                | root |                                           || localhost          |      |                                           || host-192-168-1-117 |      |                                           |+--------------------+------+-------------------------------------------+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	再次将my.cnf里添加的那一行注释，然后重启mysql[root@test-huanqiu ~]# vim /etc/my.cnf........#skip-grant-tables\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# /etc/init.d/mysqld restart\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# mysql -p123456mysql&gt;\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------发现的一个坑：mysql之前进行了全量备份，在恢复后，发现用之前的密码登陆不进去了！使用上面的方法，无密码登陆后再重置密码，但是重置密码后发现仍然登陆不进去。\r\n</p>\r\n<p>\r\n	最后发现是因为mysql.user表内容被清空了！mysql&gt; select host,user,password from user;Empty set (0.00 sec)\r\n</p>\r\n<p>\r\n	解决：插入数据，再重置密码mysql&gt; insert into user(host,user,password) values(\"localhost\",\"root\",\"123456\");Query OK, 1 row affected, 3 warnings (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select host,user,password from user;+-----------+------+----------+| host      | user | password |+-----------+------+----------+| localhost | root | 123456   |+-----------+------+----------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; update mysql.user set password=password(\"123456\") where host=\"localhost\" and user=\"root\";Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select host,user,password from user;+-----------+------+-------------------------------------------+| host      | user | password                                  |+-----------+------+-------------------------------------------+| localhost | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert into user(host,user,password) values(\"127.0.0.1\",\"root\",\"123456\");Query OK, 1 row affected, 3 warnings (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select host,user,password from user;+-----------+------+-------------------------------------------+| host      | user | password                                  |+-----------+------+-------------------------------------------+| localhost | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || 127.0.0.1 | root | 123456                                    |+-----------+------+-------------------------------------------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; update mysql.user set password=password(\"123456\") where  user=\"root\";Query OK, 1 row affected (0.00 sec)Rows matched: 2  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select host,user,password from user;+-----------+------+-------------------------------------------+| host      | user | password                                  |+-----------+------+-------------------------------------------+| localhost | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || 127.0.0.1 | root | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+-----------+------+-------------------------------------------+\r\n</p>\r\n<p>\r\n	然后使用重置后的密码就能正常登陆了！\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------------------mysql登录报错1：[root@test-huanqiu ~]# mysql -p123456ERROR 2002 (HY000): Can\'t connect to local MySQL server through socket \'/var/lib/mysql/mysql.sock\' (111)\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# ps -ef|grep mysqlroot     28279     1  0 12:55 ?        00:00:00 /bin/sh /usr/local/mysql//bin/mysqld_safe --datadir=/data/mysql/data --pid-file=/data/mysql/data/mysql.pidmysql    29059 28279  0 12:55 ?        00:00:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql/ --datadir=/data/mysql/data --plugin-dir=/usr/local/mysql//lib/plugin --user=mysql --log-error=/data/mysql/data/mysql-error.log --pid-file=/data/mysql/data/mysql.pid --socket=/usr/local/mysql/var/mysql.sock --port=3306root     30726 11268  0 12:58 pts/2    00:00:00 grep mysql\r\n</p>\r\n<p>\r\n	可知，当前mysql.sock文件路径是/usr/local/mysql/var/mysql.sock，\r\n</p>\r\n<p>\r\n	解决办法：做软链接[root@test-huanqiu ~]# ll /usr/local/mysql/var/mysql.sockrwxrwxrwx. 1 mysql mysql 0 Nov 29 12:55 /usr/local/mysql/var/mysql.sock[root@test-huanqiu ~]# rm -f  /var/lib/mysql/mysql.sock[root@test-huanqiu ~]# ln -s /usr/local/mysql/var/mysql.sock /var/lib/mysql/mysql.sock\r\n</p>\r\n<p>\r\n	这样就没问题了[root@test-huanqiu ~]# mysql -p123456mysql&gt;\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------启动mysql的时候报错：Starting MySQL.... ERROR! The server quit without updating PID file (/data/mysql/data/mysql.pid).\r\n</p>\r\n<p>\r\n	尝试的解决办法：（1）权限问题可能是mysql.pid文件没有写的权限，将mysql的安装目录和数据目录的权限都设置成mysql启动用户权限。比如都修改为mysql:mysql权限（2）可能进程里已经存在mysql进程ps -ef|grep mysql  查出要是有mysql进程存在，就kill掉，再尝试重启mysql（3）可能是多次在机器上安装mysql，有残余数据影响了服务的启动。去mysql的数据目录看看，如果存在mysql-bin.index，就立刻删掉它，它就是罪魁祸首了！（4）mysql在启动时没有指定配置文件时会使用/etc/my.cnf配置文件，请打开这个文件查看在[mysqld]节下有没有指定数据目录。在[mysqld]下添加设置，如datadir = /data/mysql/data（5）skip-federated字段问题检查一下my.cnf文件中有没有没被注释掉的skip-federated字段，如果有就立即注释掉。（6）错误日志目录不存在去my.cnf文件下是否有log日志配置路径，如果有，查看下日志目录是否存在，日志目录权限要确保是mysql启动用户权限。（7）selinux惹的祸，如果是centos系统，默认会开启selinux闭它，打开/etc/selinux/config，把SELINUX=enforcing改为SELINUX=disabled后存盘退出重启机器试试。（8）重新初始化mysql数据试试切换到mysql的安装目录下./scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/data/mysql/data --user=mysql\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－使用mysql服务端授权的信息登录mysql，报错如下：ERROR 2003 (HY000): Can\'t connect to MySQL server on \'192.168.1.14\' (111)\r\n</p>\r\n<p>\r\n	可能的原因有：1）可能网络连接问题，远程ping 192.168.1.14 ，能ping通，排除此情况；2）mysql服务端192.168.1.14的iptables里做了3306端口连接的白名单限制；3）mysql服务端192.168.1.14的my.cnf文件里配置了bind_address地址绑定，不允许本机连接；4）mysql服务端192.168.1.14的my.cnf文件里配置了skip_networking,这使用MySQL只能通过本机Socket连接(socket连接也是本地连接的默认方式），放弃对TCP/IP的监听；5）排查DNS解析问题,检查mysql服务端192.168.1.14的my.cnf文件里是否设置了skip_name_resolve。这个参数加上后，不支持主机名的连接方式。6）排查--port问题，有可能mysql服务端192.168.1.14的MySQL port不是默认3306，比如是3307端口，这样，远程连接的时候要加上--port=33077）排查用户和密码问题， 其实用户和密码的错误，不会出现111的，所以排除用户密码问题ERROR 1045 (28000): Access denied for user \'root\'@\'XXXX\' (using password: YES)\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('653207d6-af61-4cfc-af74-0ec0d3aec8b8','mysql操作命令梳理（3）-pager','mysql操作命令梳理（3）-pager','<p>\r\n	在mysql日常操作中，妙用pager设置显示方式，可以大大提高工作效率。比如select出来的结果集超过几个屏幕，那么前面的结果一晃而过无法看到，这时候使用pager可以设置调用os的more或者less等显示查询结果，和在os中使用more或者less查看大文件的效果一样。\r\n</p>\r\n<p>\r\n	pager用法：实际上等于将它设置以后的所有mysql操作命令的输出通过pager设置命令执行，类似于管道符的作用\r\n</p>\r\n<p>\r\n	nopager命令：取消pager设置，恢复之前的输出状态。（如果不设置nopager，那么只能通过重启mysql服务才能恢复了）\r\n</p>\r\n<p>\r\n	举些例子来说明吧：1）当处理大量数据时，不想显示查询的结果，而只需知道查询花费的时间。\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| id | name       |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo  |\r\n</p>\r\n<p>\r\n	|  2 | wangshikui |\r\n</p>\r\n<p>\r\n	|  3 | wangjuan   |\r\n</p>\r\n<p>\r\n	|  4 | wangman    |\r\n</p>\r\n<p>\r\n	| 11 | wangshikui |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; pager cat /dev/null;        //实际上等于后面执行的命令|cat /dev/null，这样显示结果就只是执行时间了\r\n</p>\r\n<p>\r\n	PAGER set to \'cat /dev/null\'\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; nopager;                   //恢复之前的输出状态\r\n</p>\r\n<p>\r\n	PAGER set to stdout\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	| id | name       |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo  |\r\n</p>\r\n<p>\r\n	|  2 | wangshikui |\r\n</p>\r\n<p>\r\n	|  3 | wangjuan   |\r\n</p>\r\n<p>\r\n	|  4 | wangman    |\r\n</p>\r\n<p>\r\n	| 11 | wangshikui |\r\n</p>\r\n<p>\r\n	+----+------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）如果有大量连接，用show processlist看不方便，想看有多少Sleep状态，则可以用pager。\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	| Id   | User  | Host                | db     | Command     | Time | State                                                                 | Info             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	|    5 | root  | localhost           | huanpc | Query       |    0 | init                                                                  | show processlist |\r\n</p>\r\n<p>\r\n	| 1801 | slave | 192.168.1.102:37125 | NULL   | Binlog Dump | 9904 | Master has sent all binlog to slave; waiting for binlog to be updated | NULL             |\r\n</p>\r\n<p>\r\n	+------+-------+---------------------+--------+-------------+------+-----------------------------------------------------------------------+------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; pager grep Sleep |wc -l;\r\n</p>\r\n<p>\r\n	PAGER set to \'grep Sleep |wc -l\'\r\n</p>\r\n<p>\r\n	mysql&gt; show processlist;           //类似于show processlist结果再通过grep Sleep |wc -l显示；下面表示一共有2个连接，其中0个Sleep状态的连接。\r\n</p>\r\n<p>\r\n	0\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; nopager;                    //恢复之前的输出状态\r\n</p>\r\n<p>\r\n	3）设置pager，只查看slave状态的几个status值。\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;              //其中的\\G表示显示要换行显示\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 192.168.1.101\r\n</p>\r\n<p>\r\n	Master_User: slave\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 5370489\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000005\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 2476520\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	Replicate_Do_DB: huanqiu,huanpc\r\n</p>\r\n<p>\r\n	Replicate_Ignore_DB: mysql\r\n</p>\r\n<p>\r\n	Replicate_Do_Table:\r\n</p>\r\n<p>\r\n	Replicate_Ignore_Table:\r\n</p>\r\n<p>\r\n	Replicate_Wild_Do_Table:\r\n</p>\r\n<p>\r\n	Replicate_Wild_Ignore_Table:\r\n</p>\r\n<p>\r\n	Last_Errno: 0\r\n</p>\r\n<p>\r\n	Last_Error:\r\n</p>\r\n<p>\r\n	Skip_Counter: 0\r\n</p>\r\n<p>\r\n	Exec_Master_Log_Pos: 5370489\r\n</p>\r\n<p>\r\n	Relay_Log_Space: 2476693\r\n</p>\r\n<p>\r\n	Until_Condition: None\r\n</p>\r\n<p>\r\n	Until_Log_File:\r\n</p>\r\n<p>\r\n	Until_Log_Pos: 0\r\n</p>\r\n<p>\r\n	Master_SSL_Allowed: No\r\n</p>\r\n<p>\r\n	Master_SSL_CA_File:\r\n</p>\r\n<p>\r\n	Master_SSL_CA_Path:\r\n</p>\r\n<p>\r\n	Master_SSL_Cert:\r\n</p>\r\n<p>\r\n	Master_SSL_Cipher:\r\n</p>\r\n<p>\r\n	Master_SSL_Key:\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	Master_SSL_Verify_Server_Cert: No\r\n</p>\r\n<p>\r\n	Last_IO_Errno: 0\r\n</p>\r\n<p>\r\n	Last_IO_Error:\r\n</p>\r\n<p>\r\n	Last_SQL_Errno: 0\r\n</p>\r\n<p>\r\n	Last_SQL_Error:\r\n</p>\r\n<p>\r\n	Replicate_Ignore_Server_Ids:\r\n</p>\r\n<p>\r\n	Master_Server_Id: 101\r\n</p>\r\n<p>\r\n	Master_UUID: b667a58f-d6e0-11e6-8c0a-fa163e2d66ac\r\n</p>\r\n<p>\r\n	Master_Info_File: /data/mysql/data/master.info\r\n</p>\r\n<p>\r\n	SQL_Delay: 0\r\n</p>\r\n<p>\r\n	SQL_Remaining_Delay: NULL\r\n</p>\r\n<p>\r\n	Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\r\n</p>\r\n<p>\r\n	Master_Retry_Count: 86400\r\n</p>\r\n<p>\r\n	Master_Bind:\r\n</p>\r\n<p>\r\n	Last_IO_Error_Timestamp:\r\n</p>\r\n<p>\r\n	Last_SQL_Error_Timestamp:\r\n</p>\r\n<p>\r\n	Master_SSL_Crl:\r\n</p>\r\n<p>\r\n	Master_SSL_Crlpath:\r\n</p>\r\n<p>\r\n	Retrieved_Gtid_Set:\r\n</p>\r\n<p>\r\n	Executed_Gtid_Set:\r\n</p>\r\n<p>\r\n	Auto_Position: 0\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	ERROR:\r\n</p>\r\n<p>\r\n	No query specified\r\n</p>\r\n<p>\r\n	mysql&gt; pager cat | egrep -i \'system user|Exec_Master_Log_Pos|Seconds_Behind_Master|Read_Master_Log_Pos\';\r\n</p>\r\n<p>\r\n	PAGER set to \'cat | egrep -i \'system user|Exec_Master_Log_Pos|Seconds_Behind_Master|Read_Master_Log_Pos\'\'\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 5370489\r\n</p>\r\n<p>\r\n	Exec_Master_Log_Pos: 5370489\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	ERROR:\r\n</p>\r\n<p>\r\n	No query specified\r\n</p>\r\n<p>\r\n	mysql&gt; nopager;                 //恢复之前的显示状态\r\n</p>\r\n<p>\r\n	PAGER set to stdout\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('661d7925-ab55-4631-b67a-29fd5cf11072','分享一个nginx的虚拟主机配置','分享一个nginx的虚拟主机配置','<p>\r\n	分享一个线上nginx的配置记录，涉及到nginx的rewrite重写、ip限制、访问内容限制等规则：\r\n</p>\r\n<p>\r\n	[root@localhost vhosts]# pwd/usr/local/nginx/conf/vhost\r\n</p>\r\n<p>\r\n	[root@localhost vhosts]# cat 80.www.fashhq.com.confserver {        listen       80;        server_name  www.fashhq.com fashhq.com *.fashhq.com;        root           /var/www/vhosts/www.fashhq.com/httpdocs/main;     #charset koi8-r;     ## maintenceif ($http_x_forwarded_for !~ ^(61.148.60.42|124.65.197.154|223.72.79.90|103.10.86.8|114.111.166.206)) {   rewrite ^.*$  /maintence.php last;}\r\n</p>\r\n<p>\r\n	if ($host ~* \"^fashhq.com$\") {    rewrite ^/(.*)$ https://www.fashhq.com/ permanent;}\r\n</p>\r\n<p>\r\n	set $httpsflag 0;if ($args ~* ^(.*)r=yeepaybilling(.*)$) {    set $httpsflag 1;}if ($uri ~* \"(/fanfu/appointment.html|/appointment/collect.html|/appointment/listCompany.html|/fanfu/listCompany.html|/fanfu/listBroker.html|/fanfu/addAppointments.html|/appointment/ListBroker.html)\") {    set $httpsflag 1;}if ($httpsflag = 1) {    rewrite ^/(.*) http://$host/$1 permanent;}\r\n</p>\r\n<p>\r\n	if ($request_uri  ~* \"/(jkhwpc|jkhw|jkhwadmin).php\") {    rewrite ^/(.*)$ http://www.jikehawa.com/$1 last;}if ($request_uri  ~* \"/(qjspc|qjsmob|qjsadmin).php\") {    rewrite ^/(.*)$ http://www.qiajiangs.com/$1 last;}\r\n</p>\r\n<p>\r\n	set $adminFlag \'0\';if ($request_uri  ~* \"/(fashhqadmin|ucenteradmin|fanghuaadmin).php\") {    set $adminFlag \"${adminFlag}1\";}if ($host !~* \"admin.fashhq.com\") {   set $adminFlag \"${adminFlag}2\";}if ($adminFlag = \'012\') {   rewrite ^/(.*)$ https://www.fashhq.com/ permanent;}\r\n</p>\r\n<p>\r\n	set $subdomain \' \';if ($host ~* ^(.*)\\.fashhq.com$) {    set $subdomain $1;}set $indexscript \'fashhqpc.php\';if ($subdomain = \'www\') {    set $indexscript \'fashhqpc.php\';}if ($subdomain = \'m\') {    set $indexscript \'fashhq.php\';}if ($subdomain = \'fq\') {    set $indexscript \'fashhqfqpc.php\';}if ($subdomain = \'mfq\') {    set $indexscript \'fashhqfq.php\';}if ($subdomain = \'zc\') {    set $indexscript \'fashhqzcpc.php\';}if ($subdomain = \'mzc\') {    set $indexscript \'fashhqzc.php\';}if ($subdomain = \'uc\') {    set $indexscript \'ucenterpc.php\';}if ($subdomain = \'muc\') {    set $indexscript \'ucenter.php\';}if ($subdomain = \'fanghua\') {    set $indexscript \'fanghua.php\';}\r\n</p>\r\n<p>\r\n	location / {        try_files $uri $uri/ @router;            index  $indexscript;        }\r\n</p>\r\n<p>\r\n	#error_page  404 = https://www.fashhq.com/site/error.html;        #error_page  500 = https://www.fashhq.com/site/error.html;\r\n</p>\r\n<p>\r\n	# redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }     location @router {        rewrite ^.*$ /$indexscript last;    }\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {            fastcgi_pass   127.0.0.1:9000;            fastcgi_read_timeout 10;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;            #include        fastcgi_params;            include        fastcgi.conf;        fastcgi_param  HTTPS on;    }     location ~* .*\\.(js|css|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|apk|ipa)$ {        expires 1h;    }\r\n</p>\r\n<p>\r\n	## logs        access_log  /Data/logs/nginx/www.fashhq.com/80.access.log  main;        error_log  /Data/logs/nginx/www.fashhq.com/80.error.log;\r\n</p>\r\n<p>\r\n	} ## end server\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('684c2e8e-bc90-4c73-853a-f3c7c948582c','Mysql优化系列（1）--Innodb引擎下mysql自身配置优化','Mysql优化系列（1）--Innodb引擎下mysql自身配置优化','<p>\r\n	1.简单介绍InnoDB给MySQL提供了具有提交，回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句提供一个Oracle风格一致的非锁定读。这些特色增加了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中行级锁定适合非常小的空间。InnoDB也支持FOREIGN KEY强制。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。\r\n</p>\r\n<p>\r\n	2.之所以选用innodb作为存储引擎的考虑目前来说，InnoDB是为Mysql处理巨大数据量时的最大性能设计。它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。在数据量大的网站或是应用中Innodb是倍受青睐的。另一方面，在数据库的复制操作中Innodb也是能保证master和slave数据一致有一定的作用。\r\n</p>\r\n<p>\r\n	3.下面是对线上mysql5.6版本的数据库的配置进行的优化分析记录：1）内存利用方面：innodb_buffer_pool_size 这个是Innodb最重要的参数，和MyISAM的key_buffer_size有相似之处，但也是有差别的。  这个参数主要缓存innodb表的索引，数据，插入数据时的缓冲。该参数分配内存的原则：这个参数默认分配只有8M，可以说是非常小的一个值。如果是一个专用DB服务器，那么他可以占到内存的70%-80%。这个参数不能动态更改，所以分配需多考虑。分配过大，会使Swap占用过多，致使Mysql的查询特慢。如果你的数据比较小，那么可分配是你的数据大小+10%左右做为这个参数的值。例如：数据大小为50M,那么给这个值分配innodb_buffer_pool_size＝64M设置方法，在my.cnf文件里：innodb_buffer_pool_size=4G----------------------------------------------------------------------------------------------------------注意：在Mysql5.7版本之前，调整innodb_buffer_pool_size大小必须在my.cnf配置里修改，然后重启mysql进程才可以生效。如今到了Mysql5.7版本，就可以直接动态调整这个参数，方便了很多。\r\n</p>\r\n<p>\r\n	尤其是在服务器内存增加之后，运维人员不能粗心大意，要记得调大Innodb_Buffer_Pool_size这个参数。数据库配置后，要注意检查Innodb_Buffer_Pool_size这个参数的设置是否合理\r\n</p>\r\n<p>\r\n	需要注意的地方：在调整innodb_buffer_pool_size 期间，用户的请求将会阻塞，直到调整完毕，所以请勿在白天调整，在凌晨3-4点低峰期调整。调整时，内部把数据页移动到一个新的位置，单位是块。如果想增加移动的速度，需要调整innodb_buffer_pool_chunk_size参数的大小，默认是128M。\r\n</p>\r\n<p>\r\n	Mysql5.7中动态调整这个参数的操作记录（例如由128M增大为384M）：134217728/1024*1024=128Mmysql&gt; SELECT @@innodb_buffer_pool_size;\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_size |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	|                134217728 |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_chunk_size |\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	|                      134217728 |\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; SET GLOBAL innodb_buffer_pool_size=402653184;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT @@innodb_buffer_pool_size;\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_size |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	|                402653184 |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	innodb_buffer_pool_chunk_size的大小，计算公式是innodb_buffer_pool_size/innodb_buffer_pool_instances\r\n</p>\r\n<p>\r\n	比如现在初始化innodb_buffer_pool_size为2G，innodb_buffer_pool_instances实例为4，innodb_buffer_pool_chunk_size设置为1G，那么会自动把innodb_buffer_pool_chunk_size 1G调整为512M.例：./mysqld --innodb_buffer_pool_size=2147483648 --innodb_buffer_pool_instances=4 --innodb_buffer_pool_chunk_size=1073741824;\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT @@innodb_buffer_pool_size;\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_size |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	|                2147483648 |\r\n</p>\r\n<p>\r\n	+---------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT @@innodb_buffer_pool_instances;\r\n</p>\r\n<p>\r\n	+--------------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_instances |\r\n</p>\r\n<p>\r\n	+--------------------------------+\r\n</p>\r\n<p>\r\n	|                              4 |\r\n</p>\r\n<p>\r\n	+--------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	# Chunk size was set to 1GB (1073741824 bytes) on startup but was\r\n</p>\r\n<p>\r\n	# truncated to innodb_buffer_pool_size / innodb_buffer_pool_instances\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	| @@innodb_buffer_pool_chunk_size |\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	|                      536870912 |\r\n</p>\r\n<p>\r\n	+---------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	监控Buffer Pool调整进程\r\n</p>\r\n<p>\r\n	mysql&gt; SHOW STATUS WHERE Variable_name=\'InnoDB_buffer_pool_resize_status\';\r\n</p>\r\n<p>\r\n	+----------------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name                    | Value                            |\r\n</p>\r\n<p>\r\n	+----------------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	| Innodb_buffer_pool_resize_status | Resizing also other hash tables. |\r\n</p>\r\n<p>\r\n	+----------------------------------+----------------------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	查看错误日志：（增大）\r\n</p>\r\n<p>\r\n	[Note] InnoDB: Resizing buffer pool from 134217728 to 4294967296. (unit=134217728)\r\n</p>\r\n<p>\r\n	[Note] InnoDB: disabled adaptive hash index.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was added.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : hash tables were resized.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: completed to resize buffer pool from 134217728 to 4294967296.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: re-enabled adaptive hash index.\r\n</p>\r\n<p>\r\n	（减少）\r\n</p>\r\n<p>\r\n	[Note] InnoDB: Resizing buffer pool from 4294967296 to 134217728. (unit=134217728)\r\n</p>\r\n<p>\r\n	[Note] InnoDB: disabled adaptive hash index.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : start to withdraw the last 253952 blocks.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : withdrew 253952 blocks from free list. tried to relocate 0 pages. (253952/253952)\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : withdrawn target 253952 blocks.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was freed.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: buffer pool 0 : hash tables were resized.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: Resized hash tables at lock_sys, adaptive hash index, dictionary.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: completed to resize buffer pool from 4294967296 to 134217728.\r\n</p>\r\n<p>\r\n	[Note] InnoDB: re-enabled adaptive hash index.\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	innodb_additional_mem_pool_size 用来存放Innodb的内部目录，这个值不用分配太大，系统可以自动调。通常设置16Ｍ够用了，如果表比较多，可以适当的增大。设置方法，在my.cnf文件里：innodb_additional_mem_pool_size = 16M\r\n</p>\r\n<p>\r\n	2）关于日志方面：innodb_log_file_size作用：指定在一个日志组中，每个log的大小。结合innodb_buffer_pool_size设置其大小，25%-100%。避免不需要的刷新。注意：这个值分配的大小和数据库的写入速度，事务大小，异常重启后的恢复有很大的关系。一般取256M可以兼顾性能和recovery的速度。分配原则：几个日值成员大小加起来差不多和你的innodb_buffer_pool_size相等。上限为每个日值上限大小为4G.一般控制在几个Log文件相加大小在2G以内为佳。具体情况还需要看你的事务大小，数据大小为依据。说明：这个值分配的大小和数据库的写入速度，事务大小，异常重启后的恢复有很大的关系。设置方法：在my.cnf文件里：innodb_log_file_size = 256M\r\n</p>\r\n<p>\r\n	innodb_log_files_in_group 作用：指定你有几个日值组。分配原则：　一般我们可以用2-3个日值组。默认为两个。设置方法：在my.cnf文件里：innodb_log_files_in_group=3\r\n</p>\r\n<p>\r\n	innodb_log_buffer_size：作用：事务在内存中的缓冲，也就是日志缓冲区的大小， 默认设置即可，具有大量事务的可以考虑设置为16M。如果这个值增长过快，可以适当的增加innodb_log_buffer_size另外如果你需要处理大理的TEXT，或是BLOB字段，可以考虑增加这个参数的值。设置方法：在my.cnf文件里：innodb_log_buffer_size=3M\r\n</p>\r\n<p>\r\n	innodb_flush_logs_at_trx_commit作用：控制事务的提交方式,也就是控制log的刷新到磁盘的方式。分配原则：这个参数只有3个值（0，1，2）.默认为1，性能更高的可以设置为0或是2，这样可以适当的减少磁盘IO（但会丢失一秒钟的事务。），游戏库的MySQL建议设置为0。主库请不要更改了。其中：0：log buffer中的数据将以每秒一次的频率写入到log file中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的commit并不会触发任何log buffer 到log file的刷新或者文件系统到磁盘的刷新操作；1：（默认为1）在每次事务提交的时候将logbuffer 中的数据都会写入到log file，同时也会触发文件系统到磁盘的同步；2：事务提交会触发log buffer 到log file的刷新，但并不会触发磁盘文件系统到磁盘的同步。此外，每秒会有一次文件系统到磁盘同步操作。说明：这个参数的设置对Ｉｎｎｏｄｂ的性能有很大的影响，所以在这里给多说明一下。当这个值为1时：innodb 的事务LOG在每次提交后写入日值文件，并对日值做刷新到磁盘。这个可以做到不丢任何一个事务。当这个值为2时：在每个提交，日志缓冲被写到文件，但不对日志文件做到磁盘操作的刷新,在对日志文件的刷新在值为2的情况也每秒发生一次。但需要注意的是，由于进程调用方面的问题，并不能保证每秒１００％的发生。从而在性能上是最快的。但操作系统崩溃或掉电才会删除最后一秒的事务。当这个值为0时：日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新，但是在一个事务提交不做任何操作。mysqld进程的崩溃会删除崩溃前最后一秒的事务。 从以上分析，当这个值不为１时，可以取得较好的性能，但遇到异常会有损失，所以需要根据自已的情况去衡量。 设置方法：在my.cnf文件里：innodb_flush_logs_at_trx_commit=1\r\n</p>\r\n<p>\r\n	3）文件IO分配，空间占用方面innodb_file_per_table作用：使每个Innodb的表，有自已独立的表空间。如删除文件后可以回收那部分空间。默认是关闭的，建议打开（innodb_file_per_table=1）分配原则：只有使用不使用。但DB还需要有一个公共的表空间。设置方法：在my.cnf文件里：innodb_file_per_table=1\r\n</p>\r\n<p>\r\n	innodb_file_io_threads作用：文件读写IO数，这个参数只在Windows上起作用。在Linux上只会等于4，默认即可！设置方法：在my.cnf文件里：innodb_file_io_threads=4\r\n</p>\r\n<p>\r\n	innodb_open_files作用：限制Innodb能打开的表的数据。分配原则：这个值默认是300。如果库里的表特别多的情况，可以适当增大为1000。innodb_open_files的大小对InnoDB效率的影响比较小。但是在InnoDBcrash的情况下，innodb_open_files设置过小会影响recovery的效率。所以用InnoDB的时候还是把innodb_open_files放大一些比较合适。设置方法：在my.cnf文件里：innodb_open_files=800\r\n</p>\r\n<p>\r\n	innodb_data_file_path 指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也只有最后一个文件允许自动扩充。这样，当空间用完后，自动扩充数据文件就会自动增长（以8MB为单位）以容纳额外的数据。例如： innodb_data_file_path=/disk1/ibdata1:900M;/disk2/ibdata2:50M:autoextend 两个数据文件放在不同的磁盘上。数据首先放在ibdata1 中，当达到900M以后，数据就放在ibdata2中。设置方法，在my.cnf文件里：innodb_data_file_path =ibdata1:1G;ibdata2:1G;ibdata3:1G;ibdata4:1G;ibdata5:1G;ibdata6:1G:autoextend\r\n</p>\r\n<p>\r\n	innodb_data_home_dir 放置表空间数据的目录，默认在mysql的数据目录，设置到和MySQL安装文件不同的分区可以提高性能。设置方法，在my.cnf文件里：（比如mysql的数据目录是/data/mysql/data，这里可以设置到不通的分区/home/mysql下）innodb_data_home_dir = /home/mysql\r\n</p>\r\n<p>\r\n	4）其它相关参数（适当的增加table_cache） 这里说明一个比较重要的参数：innodb_flush_method作用：Innodb和系统打交道的一个IO模型分配原则：Windows不用设置。linux可以选择：O_DIRECT 直接写入磁盘，禁止系统Cache了设置方法：在my.cnf文件里：innodb_flush_method=O_DIRECT\r\n</p>\r\n<p>\r\n	innodb_max_dirty_pages_pct 作用：在buffer pool缓冲中，允许Innodb的脏页的百分比，值在范围1-100,默认为90，建议保持默认。这个参数的另一个用处：当Innodb的内存分配过大，致使Swap占用严重时，可以适当的减小调整这个值，使达到Swap空间释放出来。建义：这个值最大在90%，最小在15%。太大，缓存中每次更新需要致换数据页太多，太小，放的数据页太小，更新操作太慢。设置方法：在my.cnf文件里：innodb_max_dirty_pages_pct＝90动态更改需要有管理员权限：set global innodb_max_dirty_pages_pct=50;\r\n</p>\r\n<p>\r\n	innodb_thread_concurrency同时在Innodb内核中处理的线程数量。建议默认值。设置方法，在my.cnf文件里：innodb_thread_concurrency = 16\r\n</p>\r\n<p>\r\n	5）公共参数调优skip-external-lockingMyISAM存储引擎也同样会使用这个参数，MySQL4.0之后，这个值默认是开启的。作用是避免MySQL的外部锁定(老版本的MySQL此参数叫做skip-locking)，减少出错几率增强稳定性。建议默认值。设置方法，在my.cnf文件里：skip-external-locking\r\n</p>\r\n<p>\r\n	skip-name-resolve 禁止MySQL对外部连接进行DNS解析（默认是关闭此项设置的，即默认解析DNS），使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！如果需要，可以设置此项。设置方法，在my.cnf文件里：（我这线上mysql数据库中打开了这一设置）skip-name-resolve\r\n</p>\r\n<p>\r\n	max_connections 设置最大连接（用户）数，每个连接MySQL的用户均算作一个连接，max_connections的默认值为100。此值需要根据具体的连接数峰值设定。设置方法，在my.cnf文件里：max_connections = 3000\r\n</p>\r\n<p>\r\n	query_cache_size 查询缓存大小，如果表的改动非常频繁，或者每次查询都不同，查询缓存的结果会减慢系统性能。可以设置为0。设置方法，在my.cnf文件里：query_cache_size = 512M\r\n</p>\r\n<p>\r\n	sort_buffer_size connection级的参数，排序缓存大小。一般设置为2-4MB即可。设置方法，在my.cnf文件里：sort_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	read_buffer_size connection级的参数。一般设置为2-4MB即可。设置方法，在my.cnf文件里：read_buffer_size = 1024M\r\n</p>\r\n<p>\r\n	max_allowed_packet网络包的大小，为避免出现较大的网络包错误，建议设置为16M设置方法，在my.cnf文件里：max_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	table_open_cache当某一连接访问一个表时，MySQL会检查当前已缓存表的数量。如果该表已经在缓存中打开，则会直接访问缓存中的表，以加快查询速度；如果该表未被缓存，则会将当前的表添加进缓存并进行查询。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_open_cache的值。如果发现open_tables等于table_open_cache，并且opened_tables在不断增长，那么就需要增加table_open_cache的值;设置为512即可满足需求。设置方法，在my.cnf文件里：table_open_cache = 512\r\n</p>\r\n<p>\r\n	myisam_sort_buffer_size实际上这个myisam_sort_buffer_size参数意义不大，这是个字面上蒙人的参数，它用于ALTER TABLE, OPTIMIZE TABLE, REPAIR TABLE 等命令时需要的内存。默认值即可。设置方法，在my.cnf文件里：myisam_sort_buffer_size = 8M\r\n</p>\r\n<p>\r\n	thread_cache_size 线程缓存，如果一个客户端断开连接，这个线程就会被放到thread_cache_size中（缓冲池未满），SHOW STATUS LIKE  \'threads%\';如果 Threads_created 不断增大，那么当前值设置要改大，改到 Threads_connected 值左右。（通常情况下，这个值改善性能不大），默认8即可设置方法，在my.cnf文件里：thread_cache_size = 8\r\n</p>\r\n<p>\r\n	innodb_thread_concurrency线程并发数，建议设置为CPU内核数*2设置方法，在my.cnf文件里：innodb_thread_concurrency = 8\r\n</p>\r\n<p>\r\n	key_buffer_size 仅作用于 MyISAM存储引擎，用来设置用于缓存 MyISAM存储引擎中索引文件的内存区域大小。如果我们有足够的内存，这个缓存区域最好是能够存放下我们所有的 MyISAM 引擎表的所有索引，以尽可能提高性能。不要设置超过可用内存的30%。即使不用MyISAM表，也要设置该值8-64M，用于临时表。设置方法，在my.cnf文件里：key_buffer_size = 8M\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－影响InnoDB性能的一些重要参数－－－－－－－－－－－－－－1）InnoDB_buffer_pool_size这个参数定义InnoDB存储引擎的表数据和索引数据的最大内存缓冲区,InnoDB_buffer_pool_size参数同时提供为数据块和索引块做缓存.这个值设置的越高,访问表中数据需要的磁盘IO就越少.\r\n</p>\r\n<p>\r\n	2）InnoDB_flush_log_at_trx_commit这个参数控制缓冲区的数据写入到日志文件以及日志文件数据刷新到磁盘的操作时机.在正式环境中建议设置成1。设置0时日志缓冲每秒一次被写到日志文件,并且对日志文件做向磁盘刷新的操作,但是在一个事物提交不做任何操作.设置1时在每个事物提交时,日志缓冲被写到日志文件,并且对日志文件做向磁盘刷新的操作设置2时在每个事物提交时,日志缓冲被写到日志文件,但不对日志文件做向磁盘刷新的操作,对日志文件每秒向磁盘做一次刷新操作.\r\n</p>\r\n<p>\r\n	3）InnoDB_additional_mem_pool_size这个参数是InnoDB用来存储数据库结构和其他内部数据结构的内存池.应用程序的表越多,则需要从这里分配越多的内存,如果用光这个池,则会从OS层分配.\r\n</p>\r\n<p>\r\n	4）InnoDB_lock_wait_timeout这个参数自动检测行锁导致的死锁并进行相应处理,但是对于表锁导致的死锁不能自动检测默认值为50秒.\r\n</p>\r\n<p>\r\n	5）InnoDB_support_xa这个参数设置MySQL是否支持分布式事务\r\n</p>\r\n<p>\r\n	6）InnoDB_log_buffer_size这个参数日志缓冲大小\r\n</p>\r\n<p>\r\n	7）InnoDB_log_file_size这个参数是一个日志组中每个日志文件的大小,此参数在高写入负载尤其是大数据集的情况下很重要.这个值越大则性能相对越高,但好似副作用是一旦系统崩溃恢复的时间会加长.\r\n</p>\r\n<p>\r\n	8）Innodb_io_capacity这个参数刷新脏页数量和合并插入数量，改善磁盘IO处理能力\r\n</p>\r\n<p>\r\n	9）Innodb_use_native_aio异步I/O在一定程度上提高系统的并发能力，在Linux系统上，可以通过将MySQL的服务器此参数的值设定为ON设定InnoDB可以使用Linux的异步I/O子系统.\r\n</p>\r\n<p>\r\n	10）Innodb_read_io_threads这个参数可调整的读请求的后台线程数\r\n</p>\r\n<p>\r\n	11）Innodb_write_io_threads这个参数可调整的写请求的后台线程数\r\n</p>\r\n<p>\r\n	12）InnoDB_buffer_pool_instances这个参数能较好的运行于多核处理器，支持使用 此参数对服务器变量建立多个缓冲池实例，每个缓冲池实例分别自我管理空闲列表、列表刷写、LRU以及其它跟缓冲池相关的数据结构，并通过各自的互斥锁进行保护\r\n</p>\r\n<p>\r\n	13）InnoDB_purge_threadsMySQL5.5以前碎片回收操作是主线程的一部分，这经定期调度的方式运行，但会阻塞数据库的其他操作.到5.5以后，可以将这个线程独立出来 ；这个能让碎片回收得更及时而且不影响其他线程的操作\r\n</p>\r\n<p>\r\n	14）Innodb_flush_method这个参数控制着innodb数据文件及redo log的打开、刷写模式，对于这个参数，文档上是这样描述的：有三个值：fdatasync(默认)，O_DSYNC，O_DIRECT默认是fdatasync，调用fsync()去刷数据文件与redo log的buffer为O_DSYNC时，innodb会使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件为O_DIRECT时，innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log总结一下三者写数据方式：fdatasync模式：写数据时，write这一步并不需要真正写到磁盘才算完成（可能写入到操作系统buffer中就会返回完成），真正完成是flush操作，buffer交给操作系统去flush,并且文件的元数据信息也都需要更新到磁盘。O_DSYNC模式：写日志操作是在write这步完成，而数据文件的写入是在flush这步通过fsync完成O_DIRECT模式：数据文件的写入操作是直接从mysql innodb buffer到磁盘的，并不用通过操作系统的缓冲，而真正的完成也是在flush这步,日志还是要经过OS缓冲\r\n</p>\r\n<p>\r\n	使用下面命令就可以查看到上面参数的设置：mysql&gt; show variables like \"%innodb%\";\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------------------------------------下面是线上mysql（innodb）的my.cnf配置参考：[client]port = 3306socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	[mysqld]port = 3306socket = /usr/local/mysql/var/mysql.sock\r\n</p>\r\n<p>\r\n	basedir = /usr/local/mysql/datadir = /data/mysql/datapid-file = /data/mysql/data/mysql.piduser = mysqlbind-address = 0.0.0.0server-id = 1sync_binlog=1log_bin = mysql-bin\r\n</p>\r\n<p>\r\n	skip-name-resolveback_log = 600\r\n</p>\r\n<p>\r\n	max_connections = 3000max_connect_errors = 3000table_open_cache = 512max_allowed_packet = 16Mbinlog_cache_size = 16Mmax_heap_table_size = 16Mtmp_table_size = 256M\r\n</p>\r\n<p>\r\n	read_buffer_size = 1024Mread_rnd_buffer_size = 1024Msort_buffer_size = 1024Mjoin_buffer_size = 1024Mkey_buffer_size = 8192M\r\n</p>\r\n<p>\r\n	thread_cache_size = 8\r\n</p>\r\n<p>\r\n	query_cache_size = 512Mquery_cache_limit = 1024M\r\n</p>\r\n<p>\r\n	ft_min_word_len = 4 binlog_format = mixedexpire_logs_days = 30\r\n</p>\r\n<p>\r\n	log_error = /data/mysql/data/mysql-error.logslow_query_log = 1long_query_time = 1slow_query_log_file = /data/mysql/data/mysql-slow.log\r\n</p>\r\n<p>\r\n	performance_schema = 0explicit_defaults_for_timestamp\r\n</p>\r\n<p>\r\n	skip-external-locking\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	default_storage_engine = InnoDBinnodb_file_per_table = 1innodb_open_files = 500innodb_buffer_pool_size = 1024Minnodb_write_io_threads = 1000innodb_read_io_threads = 1000innodb_thread_concurrency = 8innodb_purge_threads = 1innodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 4Minnodb_log_file_size = 32Minnodb_log_files_in_group = 3innodb_max_dirty_pages_pct = 90innodb_lock_wait_timeout = 120\r\n</p>\r\n<p>\r\n	bulk_insert_buffer_size = 8Mmyisam_sort_buffer_size = 8Mmyisam_max_sort_file_size = 10Gmyisam_repair_threads = 1\r\n</p>\r\n<p>\r\n	interactive_timeout = 28800wait_timeout = 28800\r\n</p>\r\n<p>\r\n	[mysqldump]quickmax_allowed_packet = 16M\r\n</p>\r\n<p>\r\n	[myisamchk]key_buffer_size = 8Msort_buffer_size = 8Mread_buffer = 4Mwrite_buffer = 4M\r\n</p>\r\n<p>\r\n	sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES port = 3306\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	下面分享一个mysql5.6下my.cnf的优化配置，能使mysql性能大大提升：# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It\'s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# basedir = .....# datadir = .....# port = .....# server_id = .....# socket = ..... # Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.###################################################innodbuser=mysqlinnodb_buffer_pool_size=6Ginnodb_log_file_size=4Ginnodb_log_buffer_size = 8Minnodb_flush_log_at_trx_commit=2innodb_file_per_table=1innodb_file_io_threads=4innodb_flush_method=O_DIRECTinnodb_io_capacity=2000innodb_io_capacity_max=6000innodb_lru_scan_depth=2000innodb_thread_concurrency = 0innodb_additional_mem_pool_size=16Minnodb_autoinc_lock_mode = 2################################################### Binary log/replicationlog-binsync_binlog=1sync_relay_log=1relay-log-info-repository=TABLEmaster-info-repository=TABLEexpire_logs_days=7binlog_format=ROWtransaction-isolation=READ-COMMITTED##################################################cachetmp_table_size=512Mcharacter-set-server=utf8collation-server=utf8_general_ciskip-external-lockingback_log=1024key_buffer_size=1024Mthread_stack=256kread_buffer_size=8Mthread_cache_size=64query_cache_size=128Mmax_heap_table_size=256Mquery_cache_type=1binlog_cache_size = 2Mtable_open_cache=128thread_cache=1024thread_concurrency=8wait_timeout=30join_buffer_size = 1024Msort_buffer_size = 8Mread_rnd_buffer_size = 8M##################################################connectmax-connect-errors=100000max-connections=1000#################################################explicit_defaults_for_timestamp=truesql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES##################################################\r\n</p>\r\n<p>\r\n	参数解释：\r\n</p>\r\n<p>\r\n	# Binary log/replication(这里主要是复制功能，也就是主从,提前配置好，后面讲主从配置)\r\n</p>\r\n<p>\r\n	#二进制日志log-bin#为了在最大程序上保证复制的InnoDB事务持久性和一致性sync_binlog=1sync_relay_log=1#启用此两项,可用于实现在崩溃时保证二进制及从服务器安全的功能relay-log-info-repository=TABLEmaster-info-repository=TABLE#设置清除日志时间expire_logs_days=7#行复制binlog_format=ROW#mysql数据库事务隔离级别有四种(READ UNCOMMITTED,READ COMMITTED,REPEATABLE READ,SERIALIZABLE)transaction-isolation=READ-COMMITTED#cache#内部内存临时表的最大值tmp_table_size=512Mcharacter-set-server=utf8collation-server=utf8_general_ci#即跳过外部锁定skip-external-locking#MySQL能暂存的连接数量(根据实际设置)back_log=1024#指定索引缓冲区的大小,只对MyISAM表起作用,这里写上也没有关系key_buffer_size=1024M#这条指令限定用于每个数据库线程的栈大小thread_stack=256k#当一个查询不断地扫描某一个表,MySQL会为它分配一段内存缓冲区read_buffer_size=8M#线程缓存thread_cache_size=64#查询缓存大小query_cache_size=128M#内部内存临时表的最大值,每个线程都要分配max_heap_table_size=256M#将查询结果放入查询缓存中query_cache_type=1#代表在事务过程中容纳二进制日志SQL语句的缓存大小binlog_cache_size = 2M#同样是缓存表大小table_open_cache=128#缓存线程thread_cache=1024#推荐设置为服务器 CPU核数的2倍thread_concurrency=8wait_timeout=30#表和表联接的缓冲区的大小join_buffer_size = 1024M#是一个connection级参数,在每个connection第一次需要使用这个buffer的时候,一次性分配设置的内存sort_buffer_size=8M#随机读取数据缓冲区使用内存read_rnd_buffer_size = 8M#connect#是一个MySQL中与安全有关的计数器值,它负责阻止过多尝试失败的客户端以防止暴力破解密码max-connect-errors=100000#连接数max-connections=1000#开启查询缓存explicit_defaults_for_timestamp=true#mysql服务器能够工作在不同的模式下,并能针对不同的客户端以不同的方式应用这些模式sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES下面列出了对性能优化影响较大的主要变量，主要分为连接请求的变量和缓冲区变量。1.连接请求的变量：1) max_connectionsMySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多， 介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。show variables like ‘max_connections’ 最大连接数show  status like ‘max_used_connections’响应的连接数如下：mysql&gt; show variables like ‘max_connections‘;+———————–+——-+| Variable_name　| Value |+———————–+——-+| max_connections | 256　　|+———————–+——-+mysql&gt; show status like ‘max%connections‘;+———————–+——-+| Variable_name　      | Value |+—————————-+——-+| max_used_connections | 256|+—————————-+——-+max_used_connections / max_connections * 100% （理想值≈ 85%） 如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。2)     back_logMySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过 back_log，将不被授予连接资源。back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。当观察你主机进程列表（mysql&gt; show full processlist），发现大量264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。默认数值是50，可调优为128，对系统设置范围为小于512的整数。 3)     interactive_timeout一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。 默认数值是28800，可调优为7200。 2.   缓冲区变量全局缓冲：4)     key_buffer_sizekey_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值 Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。举例如下：mysql&gt; show variables like ‘key_buffer_size‘;+——————-+————+| Variable_name | Value      |+———————+————+| key_buffer_size | 536870912 |+———— ———-+————+key_buffer_size为512MB，我们再看一下key_buffer_size的使用情况：mysql&gt; show global status like ‘key_read%‘;+————————+————-+| Variable_name　  | Value    |+————————+————-+| Key_read_requests| 27813678764 || Key_reads　　　|  6798830      |+————————+————-+一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：key_cache_miss_rate ＝Key_reads / Key_read_requests * 100%，设置在1/1000左右较好默认配置数值是8388600(8M)，主机有4GB内存，可以调优值为268435456(256MB)。5)     query_cache_size使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也 非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反 而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。 与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值 Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小 query_cache_min_res_unit。举例如下：mysql&gt; show global status like ‘qcache%‘;+——————————-+—————–+| Variable_name                  | Value　       |+——————————-+—————–+| Qcache_free_blocks　       | 22756　      || Qcache_free_memory　    | 76764704    || Qcache_hits　　　　　      | 213028692 || Qcache_inserts　　　　     | 208894227   || Qcache_lowmem_prunes   | 4010916      || Qcache_not_cached　| 13385031    || Qcache_queries_in_cache | 43560　|| Qcache_total_blocks          | 111212　     |+——————————-+—————–+mysql&gt; show variables like ‘query_cache%‘;+————————————–+————–+| Variable_name　　　　　       | Value　     |+————————————–+———–+| query_cache_limit　　　　　    | 2097152     || query_cache_min_res_unit　     | 4096　　  || query_cache_size　　　　　    | 203423744 || query_cache_type　　　　　   | ON　          || query_cache_wlock_invalidate | OFF　  |+————————————–+—————+查询缓存碎片率= Qcache_free_blocks / Qcache_total_blocks * 100%如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。查询缓存利用率= (query_cache_size – Qcache_free_memory) / query_cache_size * 100%查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。查询缓存命中率= (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%示例服务器查询缓存碎片率＝20.46％，查询缓存利用率＝62.26％，查询缓存命中率＝1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。每个连接的缓冲6)    record_buffer_size每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。默认数值是131072(128K)，可改为16773120 (16M)7)     read_rnd_buffer_size随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避 免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开 销过大。一般可设置为16M 8)     sort_buffer_size每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。默认数值是2097144(2M)，可改为16777208 (16M)。9)     join_buffer_size联合查询操作所能使用的缓冲区大小record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*10010)  table_cache表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如 果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了 （上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能 不稳定或者连接失败。1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。11)  max_heap_table_size用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。12)  tmp_table_size通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。mysql&gt; show global status like ‘created_tmp%‘;+——————————–+———+| Variable_name　　           | Value　|+———————————-+———+| Created_tmp_disk_tables | 21197  || Created_tmp_files　　　| 58　　|| Created_tmp_tables　　| 1771587 |+——————————–+———–+每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时 表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配 置是：Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%，应该相当好了默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞13) thread_cache_size可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。 14) thread_concurrency推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为815) wait_timeout指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。3. 配置InnoDB的几个变量innodb_buffer_pool_size对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。\r\n</p>\r\n<p>\r\n	innodb_flush_log_at_trx_commit主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的 ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。\r\n</p>\r\n<p>\r\n	innodb_log_buffer_sizelog缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。\r\n</p>\r\n<p>\r\n	innodb_additional_mem_pool_size该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。\r\n</p>\r\n<p>\r\n	innodb_thread_concurrency=8推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8MySQL 5.6相比于前代GA版本性能提升显著，但默认缓存设置对于小型站点并不合理。通过修改my.ini文件中的performance_schema_max_table_instances参数，能够有效降低内存占用。以下是5.6默认的设置performance_schema_max_table_instances 12500table_definition_cache 1400table_open_cache 2000可以调成，或者在小点都可以。 performance_schema_max_table_instances=600table_definition_cache=400table_open_cache=256 performance_schema_max_table_instancesThe maximum number of instrumented table objects  检测的表对象的最大数目。table_definition_cacheThe number of table definitions (from .frm files) that can be stored in the definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache. The minimum and default values are both 400. 缓存frm文件\r\n</p>\r\n<p>\r\n	table_open_cacheThe number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires. table_open_cache 指的是缓存数据文件的描述符(Linux/Unix)相关信息这个很重要啊，之前mount个单独的文件，数据库一直不成功，原来是这个在作怪啊。chcon -R -t mysqld_db_t /home/myusqldata mysql&gt; show variables;一、慢查询mysql&gt; show variables like \'%slow%\';+------------------+-------+| Variable_name | Value |+------------------+-------+| log_slow_queries | ON || slow_launch_time | 2     |+------------------+-------+\r\n</p>\r\n<p>\r\n	mysql&gt; show global status like \'%slow%\';+---------------------+-------+| Variable_name    | Value |+---------------------+-------+| Slow_launch_threads | 0     || Slow_queries        | 4148 |+---------------------+-------+配置中打开了记录慢查询，执行时间超过2秒的即为慢查询，系统显示有4148个慢查询，你可以分析慢查询日志，找出有问题的SQL语句，慢查询时间不宜设置过长，否则意义不大，最好在5秒以内，如果你需要微秒级别的慢查询，可以考虑给MySQL打补丁：http://www.percona.com/docs/wiki/release:start，记得找对应的版本。打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主－从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小。二、连接数经常会遇见”MySQL: ERROR 1040: Too manyconnections”的情况，一种是访问量确实很高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是MySQL配置文件中max_connections值过小：mysql&gt; show variables like \'max_connections\';+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 256 |+-----------------+-------+这台MySQL服务器最大连接数是256，然后查询一下服务器响应的最大连接数：mysql&gt; show global status like \'Max_used_connections\';+----------------------+-------+| Variable_name        | Value |+----------------------+-------+| Max_used_connections | 245 |+----------------------+-------+MySQL服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是：Max_used_connections / max_connections   * 100% ≈ 85%最大连接数占上限连接数的85％左右，如果发现比例在10%以下，MySQL服务器连接数上限设置的过高了。三、Key_buffer_sizekey_buffer_size是对MyISAM表性能影响最大的一个参数，下面一台以MyISAM为主要存储引擎服务器的配置：mysql&gt; show variables like \'key_buffer_size\';+-----------------+------------+| Variable_name | Value    |+-----------------+------------+| key_buffer_size | 536870912 |+-----------------+------------+分配了512MB内存给key_buffer_size，我们再看一下key_buffer_size的使用情况：mysql&gt; show global status like \'key_read%\';+------------------------+-------------+| Variable_name       | Value    |+------------------------+-------------+| Key_read_requests    | 27813678764 || Key_reads              | 6798830     |+------------------------+-------------+一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：key_cache_miss_rate ＝ Key_reads / Key_read_requests * 100%比 如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很BT 了，key_cache_miss_rate在0.1%以下都很好（每1000个请求有一个直接读硬盘），如果key_cache_miss_rate在 0.01%以下的话，key_buffer_size分配的过多，可以适当减少。MySQL服务器还提供了key_blocks_*参数：mysql&gt; show global status like \'key_blocks_u%\';+------------------------+-------------+| Variable_name       | Value    |+------------------------+-------------+| Key_blocks_unused    | 0           || Key_blocks_used        | 413543    |+------------------------+-------------+Key_blocks_unused 表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么 增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%四、临时表mysql&gt; show global status like \'created_tmp%\';+-------------------------+---------+| Variable_name           | Value |+-------------------------+---------+| Created_tmp_disk_tables | 21197 || Created_tmp_files    | 58    || Created_tmp_tables    | 1771587 |+-------------------------+---------+每次创建临时表，Created_tmp_tables增加，如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝ 1.20%，应该相当好了。我们再看一下MySQL服务器对临时表的配置：mysql&gt; show variables where Variable_name in (\'tmp_table_size\', \'max_heap_table_size\');+---------------------+-----------+| Variable_name    | Value     |+---------------------+-----------+| max_heap_table_size | 268435456 || tmp_table_size    | 536870912 |+---------------------+-----------+只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。五、Open Table情况mysql&gt; show global status like \'open%tables%\';+---------------+-------+| Variable_name | Value |+---------------+-------+| Open_tables | 919 || Opened_tables | 1951   |+---------------+-------+Open_tables 表示打开表的数量，Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中 table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值：mysql&gt; show variables like \'table_cache\';+---------------+-------+| Variable_name | Value |+---------------+-------+| table_cache | 2048   |\r\n</p>\r\n<p>\r\n	+---------------+-------+比较合适的值为：Open_tables / Opened_tables   * 100% &gt;= 85%Open_tables / table_cache * 100% &lt;= 95%\r\n</p>\r\n<p>\r\n	六、进程使用情况mysql&gt; show global status like \'Thread%\';+-------------------+-------+| Variable_name     | Value |+-------------------+-------+| Threads_cached | 46 || Threads_connected | 2     || Threads_created | 570 || Threads_running | 1     |+-------------------+-------+如 果我们在MySQL服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户 而不是销毁（前提是缓存数未达上限）。Threads_created表示创建过的线程数，如果发现Threads_created值过大的话，表明 MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器 thread_cache_size配置：mysql&gt; show variables like \'thread_cache_size\';+-------------------+-------+| Variable_name     | Value |+-------------------+-------+| thread_cache_size | 64 |+-------------------+-------+示例中的服务器还是挺健康的。七、查询缓存(query cache)mysql&gt; show global status like \'qcache%\';+-------------------------+-----------+| Variable_name           | Value     |+-------------------------+-----------+| Qcache_free_blocks    | 22756     || Qcache_free_memory    | 76764704   || Qcache_hits          | 213028692 || Qcache_inserts       | 208894227 || Qcache_lowmem_prunes | 4010916 || Qcache_not_cached    | 13385031   || Qcache_queries_in_cache | 43560     || Qcache_total_blocks     | 111212 |+-------------------------+-----------+MySQL查询缓存变量解释：Qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。Qcache_free_memory：缓存中的空闲内存。Qcache_hits：每次查询在缓存中命中时就增大Qcache_inserts：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。Qcache_lowmem_prunes： 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存 很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况）Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。Qcache_queries_in_cache：当前缓存的查询（和响应）的数量。Qcache_total_blocks：缓存中块的数量。我们再查询一下服务器关于query_cache的配置：mysql&gt; show variables like \'query_cache%\';+------------------------------+-----------+| Variable_name             | Value     |+------------------------------+-----------+| query_cache_limit          | 2097152 || query_cache_min_res_unit     | 4096    || query_cache_size          | 203423744 || query_cache_type          | ON        || query_cache_wlock_invalidate | OFF    |+------------------------------+-----------+各字段的解释：query_cache_limit：超过此大小的查询将不缓存query_cache_min_res_unit：缓存块的最小大小query_cache_size：查询缓存大小query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。查询缓存利用率 = (query_cache_size - Qcache_free_memory) / query_cache_size * 100%查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。查询缓存命中率 = (Qcache_hits - Qcache_inserts) / Qcache_hits * 100%示例服务器 查询缓存碎片率 ＝ 20.46％，查询缓存利用率 ＝ 62.26％，查询缓存命中率 ＝ 1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。八、排序使用情况mysql&gt; show global status like \'sort%\';+-------------------+------------+| Variable_name     | Value    |+-------------------+------------+| Sort_merge_passes | 29       || Sort_range        | 37432840 || Sort_rows       | 9178691532 || Sort_scan       | 1860569 |+-------------------+------------+Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等MySQL 找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。实际上，MySQL会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少Sort_merge_passes 和 创建临时文件的次数。但盲目的增加 Sort_buffer_size 并不一定能提高速度，另外，增加read_rnd_buffer_size(3.2.3是record_rnd_buffer_size)的值对排序的操作也有一点的好处，九、文件打开数(open_files)mysql&gt; show global status like \'open_files\';+---------------+-------+| Variable_name | Value |+---------------+-------+| Open_files | 1410   |+---------------+-------+\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'open_files_limit\';+------------------+-------+| Variable_name | Value |+------------------+-------+| open_files_limit | 4590   |+------------------+-------+比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75％十、表锁情况mysql&gt; show global status like \'table_locks%\';+-----------------------+-----------+| Variable_name       | Value     |+-----------------------+-----------+| Table_locks_immediate | 490206328 || Table_locks_waited | 2084912 |+-----------------------+-----------+Table_locks_immediate 表示立即释放表锁数，Table_locks_waited表示需要等待的表锁数，如果Table_locks_immediate / Table_locks_waited &gt;5000，最好采用InnoDB引擎，因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。示例中的服务 器Table_locks_immediate / Table_locks_waited ＝ 235，MyISAM就足够了。十一、表扫描情况mysql&gt; show global status like \'handler_read%\';+-----------------------+-------------+| Variable_name       | Value    |+-----------------------+-------------+| Handler_read_first | 5803750     || Handler_read_key    | 6049319850   || Handler_read_next     | 94440908210 || Handler_read_prev     | 34822001724 || Handler_read_rnd    | 405482605 || Handler_read_rnd_next | 18912877839 |+-----------------------+-------------+各字段解释参见,调出服务器完成的查询请求次数：mysql&gt; show global status like \'com_select\';+---------------+-----------+| Variable_name | Value     |+---------------+-----------+| Com_select | 222693559 |+---------------+-----------+计算表扫描率：表扫描率 ＝ Handler_read_rnd_next / Com_select如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8MB。要查看死锁，你要show engine innodb status\\G;在MySQL5.6版本，在my.cnf配置文件里，加入innodb_print_all_deadlocks = 1就可以把死锁信息打印到错误日志里\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('6e51ecf5-cb8d-4f7d-a9af-9710685fed33','nginx＋php负载均衡集群环境中的session共享方案梳理','nginx＋php负载均衡集群环境中的session共享方案梳理','<p>\r\n	在网站使用nginx+php做负载均衡情况下，同一个IP访问同一个页面会被分配到不同的服务器上，如果session不同步的话，就会出现很多问题，比如说最常见的登录状态。\r\n</p>\r\n<p>\r\n	下面罗列几种nginx负载均衡中session同步的方式\r\n</p>\r\n<p>\r\n	1）不使用session，换用cookiesession是存放在服务器端的，cookie是存放在客户端的，我们可以把用户访问页面产生的session放到cookie里面，就是以cookie为中转站。你访问web服务器A，产生了session然后把它放到cookie里面，当你的请求被分配到B服务器时，服务器B先判断服务器有没有这个session，如果没有，再去看看客户端的cookie里面有没有这个session，如果也没有，说明session真的不存，如果cookie里面有，就把cookie里面的sessoin同步到服务器B，这样就可以实现session的同步了。说明：这种方法实现起来简单，方便，也不会加大数据库的负担，但是如果客户端把cookie禁掉了的话，那么session就无从同步了，这样会给网站带来损失；cookie的安全性不高，虽然它已经加了密，但是还是可以伪造的。\r\n</p>\r\n<p>\r\n	2）session存在数据库（MySQL）中PHP可以配置将session保存在数据库中，这种方法是把存放session的表和其他数据库表放在一起，如果mysql也做了集群的话，每个mysql节点都要有这张表，并且这张session表数据表要实时同步。但是要注意的是：用数据库来同步session，会加大数据库的IO，增加数据库的负担。而且数据库读写速度较慢，不利于session的适时同步。\r\n</p>\r\n<p>\r\n	3）session存在memcache或者redis中memcache可以做分布式，php配置文件中设置存储方式为memcache，这样php自己会建立一个session集群，将session数据存储在memcache中。特别说明：以这种方式来同步session，不会加大数据库的负担，并且安全性比用cookie大大的提高，把session放到内存里面，比从文件中读取要快很多。但是memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出。\r\n</p>\r\n<p>\r\n	4）采用nginx中的ip_hash机制nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端web机器中，这样一来这个ip下的某个客户端和某个后端web机器就能建立起稳固的session。也就是说，ip_hash机制能够让某一客户机在相当长的一段时间内只访问固定的后端的某台真实的Web服务器，这样会话就会得以保持，我们在网站页面进行login的时候，就不会在后面的web服务器之间跳来跳去了，自然也不会出现登陆一次后网站又提醒你没有登陆需要重新登陆的情况；\r\n</p>\r\n<p>\r\n	ip_hash是在upstream配置中定义的：\r\n</p>\r\n<p>\r\n	upstream nginx.example.com {\r\n</p>\r\n<p>\r\n	server 192.168.74.235:80;\r\n</p>\r\n<p>\r\n	server 192.168.74.236:80;\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass\r\n</p>\r\n<p>\r\n	http://nginx.example.com;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端web，因此ip_hash是有缺陷的，不能在一些情况下使用：a）nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。b）nginx的后端还有其它方式的负载均衡。假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。这么算起来，nginx后端只能直接指向应用服务器，或者再搭一个squid，然后指向应用服务器。最好的办法是用 location作一次分流，将需要session的部分请求通过ip_hash分流，剩下的走其它后端去。\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	----------------------------顺便说一下之前线上用过的nginx负载均衡中的session共享处理方案----------------------------\r\n</p>\r\n<p>\r\n	用的就是上面第三站方式，将session存放在memcached里面。\r\n</p>\r\n<p>\r\n	公司的一些网站页面（LNMP框架）涉及到登陆需求（有sessionID），用到了memcache缓存服务，将php的sessionID缓存到memcache里面。\r\n</p>\r\n<p>\r\n	将sessionID放在memcache里后，会加快页面访问速度，页面访问飞快！\r\n</p>\r\n<p>\r\n	如果memcache里面存放的只是sessionID，而没有其他业务，那么memcache服务器的内存消耗就不大！\r\n</p>\r\n<p>\r\n	首先保障php扩展模块里要支持memcached功能（即一定要安装php的memcached扩展模块）\r\n</p>\r\n<p>\r\n	[root@huanqiu vhosts]# /Data/app/php5.5.1/bin/php -m\r\n</p>\r\n<p>\r\n	[PHP Modules]\r\n</p>\r\n<p>\r\n	..........\r\n</p>\r\n<p>\r\n	memcached\r\n</p>\r\n<p>\r\n	...........\r\n</p>\r\n<p>\r\n	遇到问题：\r\n</p>\r\n<p>\r\n	在迁移网站业务的过程中（迁移后使用的是新的memcache机器）\r\n</p>\r\n<p>\r\n	由于php.ini和代码中的memcache连接信息没有及时修改或者没有完全修改过来，导致迁移后的页面访问速度有点缓慢，有点卡！\r\n</p>\r\n<p>\r\n	最后仔细排查，把所有有关memcache连接信息的配置都改过来了，迁移后的页面访问速度就正常了！\r\n</p>\r\n<p>\r\n	1）\r\n</p>\r\n<p>\r\n	首先部署三台memcache服务器，主机名分别是memcache1.server ，memcache2.server ，memcache3.server ，启动相应的端口。\r\n</p>\r\n<p>\r\n	注意，不用业务应用到的memcache服务端口不能冲突。\r\n</p>\r\n<p>\r\n	比如：业务A用到memcache1-3.server服务器的11021,11022,11023端口，业务B就用到了memcache1-3.server的11031,11032,11033端口\r\n</p>\r\n<p>\r\n	部署memcache集群服务\r\n</p>\r\n<p>\r\n	yum安装即可，部署三台memcache1，memcache2，memcache3\r\n</p>\r\n<p>\r\n	启动相应缓存端口\r\n</p>\r\n<p>\r\n	[root@memcache2 ~]# ps -ef|grep memcache\r\n</p>\r\n<p>\r\n	root      6139     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11021 -u root -c 4096 -P  /var/lib/memcache/logs/memcached_11021.pid\r\n</p>\r\n<p>\r\n	root      6184     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11022  -u root -c 4096 -P /var/lib/memcache/logs/memcached_11022.pid\r\n</p>\r\n<p>\r\n	root      6198     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11023 -u root -c 4096 -P  /var/lib/memcache/logs/memcached_11023.pid\r\n</p>\r\n<p>\r\n	root      6214     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11031 -u root -c 4096 -P  /var/lib/memcache/logs/memcached_11031.pid\r\n</p>\r\n<p>\r\n	root      6229     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11032 -u root -c 4096 -P  /var/lib/memcache/logs/memcached_11032.pid\r\n</p>\r\n<p>\r\n	root      6244     1  0 May30 ?        00:00:05 /usr/bin/memcached -d -m 512 -p 11033 -u root -c 4096 -P  /var/lib/memcache/logs/memcached_11033.pid\r\n</p>\r\n<p>\r\n	将上面的程序添加到开机启动/etc/rc.local里面\r\n</p>\r\n<p>\r\n	2）在业务机器上应用memcache缓存\r\n</p>\r\n<p>\r\n	a）比如业务A\r\n</p>\r\n<p>\r\n	首先在相应的业务服务器上的/etc/hosts里设置主机映射（如果能ping通memcache机器的内网，就用内网）\r\n</p>\r\n<p>\r\n	#vim /etc/hosts\r\n</p>\r\n<p>\r\n	192.168.1.23  memcache1.server\r\n</p>\r\n<p>\r\n	192.168.1.24  memcache2.server\r\n</p>\r\n<p>\r\n	192.168.1.25  memcache3 .server\r\n</p>\r\n<p>\r\n	首先在php的php.ini里面设置memcache缓存\r\n</p>\r\n<p>\r\n	#vim /Data/app/php/etc/php.ini\r\n</p>\r\n<p>\r\n	...............\r\n</p>\r\n<p>\r\n	[Session]\r\n</p>\r\n<p>\r\n	session.save_handler = memcached\r\n</p>\r\n<p>\r\n	session.save_path = \"memcache1.server :11021,memcache2.server :11022,memcache3.server :11023\"\r\n</p>\r\n<p>\r\n	然后重启php服务\r\n</p>\r\n<p>\r\n	最后在相应的代码程序里使用memcache缓存，比如：\r\n</p>\r\n<p>\r\n	# vim  main.php\r\n</p>\r\n<p>\r\n	$config[\'params\'][\'erp_host\']   = \'http://www.xqshijie.com\';\r\n</p>\r\n<p>\r\n	//以下是memcache配置，把相应的参数都换成相应环境下的\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'class\'] = \'system.caching.CMemCache\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'useMemcached\'] = \'true\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'keyPrefix\'] = \'\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'hashKey\'] = false;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'serializer\'] = false;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'host\'] = \'memcache1.server\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'port\'] = 11021;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'weight\'] = 10;\r\n</p>\r\n<p>\r\n	...........................\r\n</p>\r\n<p>\r\n	b）业务B\r\n</p>\r\n<p>\r\n	在相应业务服务器的/etc/hosts里设置主机映射（如果能ping通memcache机器的内网，就用内网）\r\n</p>\r\n<p>\r\n	#vim /etc/hosts\r\n</p>\r\n<p>\r\n	192.168.1.23  memcache1.server\r\n</p>\r\n<p>\r\n	192.168.1.24  memcache2.server\r\n</p>\r\n<p>\r\n	192.168.1.25  memcache3 .server\r\n</p>\r\n<p>\r\n	首先在php的php.ini里面设置memcache缓存\r\n</p>\r\n<p>\r\n	#vim /Data/app/php/etc/php.ini\r\n</p>\r\n<p>\r\n	...............\r\n</p>\r\n<p>\r\n	[Session]\r\n</p>\r\n<p>\r\n	session.save_handler = memcached\r\n</p>\r\n<p>\r\n	session.save_path = \"memcache1.server :11031,memcache2.server :11032,memcache3.server :11033\"\r\n</p>\r\n<p>\r\n	然后重启php服务\r\n</p>\r\n<p>\r\n	最后在相应的代码程序里使用memcache缓存，比如：\r\n</p>\r\n<p>\r\n	# vim  main.php\r\n</p>\r\n<p>\r\n	$config[\'params\'][\'erp_host\']   = \'http://erp.fangfull.com\';\r\n</p>\r\n<p>\r\n	//以下是memcache配置，把相应的参数都换成相应环境下的\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'class\'] = \'system.caching.CMemCache\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'useMemcached\'] = \'true\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'keyPrefix\'] = \'\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'hashKey\'] = false;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'serializer\'] = false;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'host\'] = \'memcache1.server\';\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'port\'] = 11031;\r\n</p>\r\n<p>\r\n	$config[\'components\'][\'cache\'][\'servers\'][0][\'weight\'] = 10;\r\n</p>\r\n<p>\r\n	.............................................\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	清理memcache缓存的方法：\r\n</p>\r\n<p>\r\n	1）\r\n</p>\r\n<p>\r\n	默认memcache会监听11221端口，如果想清空服务器上memecache的缓存，大家一般使用的是：\r\n</p>\r\n<p>\r\n	telnet localhost 11211\r\n</p>\r\n<p>\r\n	flush_all\r\n</p>\r\n<p>\r\n	2）同样也可以使用：\r\n</p>\r\n<p>\r\n	echo \"flush_all\" | nc localhost 11211\r\n</p>\r\n<p>\r\n	使用flush_all 后并不是删除memcache上的key，而是置为过期\r\n</p>\r\n<p>\r\n	------------------------------------php.ini中关于session属性的相关设置-------------------------------------1）session.use_cookies：是否在客户端用 cookie 来存放会话 ID，1是开启 ，0是关闭若session.use_cookies = 1sessionid在客户端采用的存储方式，置1代表使用cookie记录客户端的sessionid，同时，$_COOKIE变量里才会有$_COOKIE[‘PHPSESSIONID’]这个元素存在\r\n</p>\r\n<p>\r\n	一般脚本语言都会原生支持“session机制”，如PHP程序配置：设置php.ini的session.use_trans_sid = 1，PHP自动在URL里传递session id设置php.ini的session.use_cookies = 1，使用cookie在客户端保存session id\r\n</p>\r\n<p>\r\n	2）session.auto start：将php.ini中的如下选项配置修改即可：session.auto_start=0修改成sessioin.auto_start=1开启session.auto_start优点在于，任何时候都不会因忘记执行session_start()或session_start()在程序里的位置不对，而导致错误；缺点在于，如果你使用的是第三方代码，则必须删去其中的全部 session_start()，否则将不能得到正确的结果。\r\n</p>\r\n<p>\r\n	3）session的内容存在文件里的话,文件在哪儿?如果不指定, Linux下默认在 \"/tmp\"目录。线上在php.ini配置文件了做了指定，session内容存放在memcache缓存里。默认session内容是存储在文件里的，即session.save_handler = files但是我们线上是设置将session内容保存到memcache里的\r\n</p>\r\n<p>\r\n	线上环境下的配置：[Session]; Handler used to store/retrieve data.; http://php.net/session.save-handler;session.save_handler = filessession.save_handler = memcachedsession.save_path = \"memcache1.huanqiu.com:11311,memcache1.huanqiu.com:11312,memcache2.huanqiu.com:11311,memcache2.huanqiu.com:11312\"\r\n</p>\r\n<p>\r\n	4）session的生命周期的设置a）session的默认生命周期是多久?  答:关闭浏览器就失效原因:因为session_id存在于cookie,而默认情况,cookie关闭浏览器即失败.b）如何设置session生命周期为30分钟呢?   在php.ini文件里设置session.cookie_lifetime = 1800\r\n</p>\r\n<p>\r\n	线上生产环境下设置的是7天，生命周期是一周; Lifetime in seconds of cookie or, if 0, until browser is restarted.; http://php.net/session.cookie-lifetimesession.cookie_lifetime = 604800\r\n</p>\r\n<p>\r\n	5）session的名字; Name of the session (used as cookie name).; http://php.net/session.namesession.name = PHPSESSID\r\n</p>\r\n<p>\r\n	------------------------------------------session与cookie的简单区别-----------------------------------------session和cookie本质上确实是两个东西，但cookie同时也是session id的载体，cookie保存session id。1）cookie数据存放在客户的浏览器上，session数据放在服务器上。session保存在服务器端与浏览器设置无关，cookie在客户端并受浏览器设置限制。cookie是在你的电脑上保存的,session是在服务器上的. 也就是说你换一个电脑你的cookie就不起作用了, 而session只要你的浏览器不关就还能访问到. 通常的都是两者结合着用的. cookie的话你自己就可以通过对浏览器的设置禁用掉.这样就不起作用了\r\n</p>\r\n<p>\r\n	2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。session是服务器端缓存，cookie是客户端缓存。cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案\r\n</p>\r\n<p>\r\n	3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。session是服务器保持客户端状态信息的方案，一般是保存在服务器中的一块内存中，session超时时间在服务器端进行设置。cookie是客户端保持用户信息的方案，一般是文件形式保存，cookie清空时间是在客户端浏览器设置。从开发角度说，session信息可以通过技术方案写到客户端保存，cookie中的用户信息，也可以在用户访问该网站时，通过技术手段自动更新用户的session信息。\r\n</p>\r\n<p>\r\n	4单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\r\n</p>\r\n<p>\r\n	5建议：将登陆信息等重要信息存放为session；其他信息如果需要保留，可以放在cookie中\r\n</p>\r\n<p>\r\n	-------------------------------------------开启session功能----------------------------------------开启session功能是很重要的，比如下面一个场景：某个网站程序在测试服务器上调试，首页是ok的，但一到后台去登录就登录不进去，起初怀疑是rewrite规则没有写对，后排查就是因为session功能没有打开引起的！那么session应该如何开启？1）编辑php.ini配置文件session.save_path=文件夹路径 &nbsp; &nbsp; &nbsp;指向任意一个有写权限的目录就行了.register_globals = On &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 打开全局变量,如果不打开,你就这样用$_SESSION[\'sessioname\'];但是我本人从来没成功过.2）重启php服务即可（如果是lamp模式，就重启apache）\r\n</p>\r\n<p>\r\n	-----------------------------------------看一个linux下Session丢失的案例分析----------------------------------------由于各种原因需要进行代码迁移，迁移后重新搭建php环境，运行代码。最后在登录页面时发现后台不能访问，会直接返回到登录页面，接着对代码进行测试，没有报任何错误，最后排查是因为跳转时session丢失造成的！那么session如何会丢失呢？发现造成这个原因有这几种：a）session存储路径（目录）不存在，自然就无法生成session临时文件b）session存储路径下有没有权限，如果没有，也就不可能存储session数据c）能正常存session数据，但session存入后被清空\r\n</p>\r\n<p>\r\n	尝试解决的措施：a）在项目根目录下创建phpinfo.php文件，在文件中写入phpinfo(),运行此文件，查看页面，就可以找到session的存储路径，b）在服务器上查找session存储路径是否存在，不存在创建存储目录，并分配权限，如果有session存储路径，就查看其是否有权限，没有就分配权限，c）是否是第三个原因，可在phpinfo.php页面中查找date.timezone是否设置不对，然后在php.ini配置文件中找到date.timezone进行配置\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------------------------------------------------需要清楚知道的：1）上面在php.ini文件里将session.save_handler修改为memcached，即表示将php的session信息存放到memcache里（前提是安装了memcached扩展），然后在session.save_path处配置连接memcache信息。如：session.save_handler = memcachedsession.save_path = \"memcache1.huanqiu.com:11311,memcache1.huanqiu.com:11312,memcache2.huanqiu.com:11311,memcache2.huanqiu.com:11312\"\r\n</p>\r\n<p>\r\n	注意：带d的memcached扩展，则session.save_path配置连接的时候不需要加tcp://如果是不带d的memcache扩展，则session.save_path配置连接的时候需要加tcp://\r\n</p>\r\n<p>\r\n	2）如果将session.save_handler修改为redis，即表示将php的session信息存放到redis里（前提是安装了php的phpredis扩展），然后在session.save_path处配置redis的connect 地址。如下：session.save_handler = redis session.save_path = \"tcp://127.0.0.1:6379\"-------------------------------------------------------------------------------------------------------------------\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('7006a19c-fbb0-440f-86a5-fd7110d0c8a7','报错问题：InnoDB: Error: log file ./ib_logfile0 is of d','报错问题：InnoDB: Error: log file ./ib_logfile0 is of different size','<p>\r\n	在使用xtrabackup对mysql执行备份操作的时候，出现下面的报错：.....................xtrabackup:   innodb_log_file_size = 50331648InnoDB: Error: log file ./ib_logfile0 is of different size 33554432 bytesInnoDB: than specified in the .cnf file 50331648 bytes!\r\n</p>\r\n<p>\r\n	解决办法：可以计算一下33554432的大小，33554432/1024/1024=32查看my.cnf配置文件的innodb_log_file_size参数配置：innodb_log_file_size = 32M\r\n</p>\r\n<p>\r\n	需要调整这个文件的大小再计算一下50331648的大小，50331648/1024/1024=48\r\n</p>\r\n<p>\r\n	修改my.cnf配置文件的下面一行参数值：innodb_log_file_size = 48M\r\n</p>\r\n<p>\r\n	然后重启mysql\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('71ff3fc8-b4dc-4a13-a933-ccdcff6fd013','mysql客户端授权后连接失败问题','mysql客户端授权后连接失败问题','<p>\r\n	在本地（192.168.1.152）部署好mysql环境，授权远程客户机192.168.1.%连接本机的mysql，在iptables防火墙也已开通3306端口。如下：mysql&gt; select host,user,password from mysql.user;+--------------+-----------------+---------------------------------------------------------+| host &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | password &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|+--------------+-----------------+----------------------------------------------------------+| localhost &nbsp; &nbsp; &nbsp; | root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fdm1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| 127.0.0.1 &nbsp; &nbsp; | root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| localhost &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fdm1         |                 |                                           || 192.168.1.%  | db_hqsb &nbsp; &nbsp; &nbsp; &nbsp; | *DFC9DC16B13651A95ECEC3A26E07D244431B55C9 || 192.168.1.%  | db_ro_hqsb &nbsp; &nbsp;| *2C0B0DD50595BB40879110437BEEF026D019DFB7 || 192.168.1.%  | db_jkhwuser &nbsp; | *2C0B0DD50595BB40879110437BEEF026D019DFB7 || 192.168.1.25| slave &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | *EE52B8EACB3CCD13624273AD6B5CDA52B9B53EB7 || 192.168.1.%  | tech_db_user &nbsp;| *6053E57C7B61043DC2C6B4E3291D5F61CCC23F5C || 192.168.1.%  | game_db_user| *05EA4D71C9A1273ECF3E24E6323F7175AE45C366 &nbsp;| | localhost &nbsp; &nbsp; &nbsp; &nbsp;| zabbix &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 &nbsp;|+---------------+---------------+------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	问题：在客户机（比如192.168.1.20）上远程连接上面192.168.1.152机器的mysql，连接失败！[root@huanqiu ~]# mysql -udb_ro_hqsb -h 192.168.1.152 -pmhxzkhl0802xqsjdbERROR 1130 (HY000): Host \'192.168.1.20\' is not allowed to connect to this MySQL server\r\n</p>\r\n<p>\r\n	解决：是由于192.168.1.152的mysql里“host为localhost，user和password为空”这条语句导致的，删除这条即可解决问题！\r\n</p>\r\n<p>\r\n	mysql&gt; delete from mysql.user where host=\"localhost\" and user=\"\";Query OK, 1 row affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	这样，授权连接的客户机就能成功连接了！[root@huanqiu ~]# mysql -uxqsj_db_ro_user -h 192.168.1.152 -pmhxzkhl0802xqsjdbWelcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 28Server version: 5.1.73 Source distribution\r\n</p>\r\n<p>\r\n	Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.\r\n</p>\r\n<p>\r\n	Type \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('77b28eb6-bd8c-4990-9cb5-bd5fbd9a2cfa','nginx利用geo模块做限速白名单以及geo实现全局负载均衡的操作记录','nginx利用geo模块做限速白名单以及geo实现全局负载均衡的操作记录','<p>\r\n	Nginx的geo模块不仅可以有限速白名单的作用，还可以做全局负载均衡，可以要根据客户端ip访问到不同的server。比如，可以将电信的用户访问定向到电信服务器，网通的用户重 定向到网通服务器”，从而实现智能DNS的作用。前面介绍过nginx域名访问的白名单配置梳理，下面对nginx的geo模块使用做一梳理（参考Geo模块-Nginx中文文档）\r\n</p>\r\n<p>\r\n	geo指令是通过ngx_http_geo_module模块提供的。默认情况下，nginx安装时是会自动加载这个模块，除非安装时人为的手动添加--without-http_geo_module。\r\n</p>\r\n<p>\r\n	ngx_http_geo_module模块可以用来创建变量，其值依赖于客户端IP地址。\r\n</p>\r\n<p>\r\n	geo指令\r\n</p>\r\n<p>\r\n	语法: geo [$address] $variable { ... }\r\n</p>\r\n<p>\r\n	默认值: —\r\n</p>\r\n<p>\r\n	配置段: http\r\n</p>\r\n<p>\r\n	定义从指定的变量获取客户端的IP地址。默认情况下，nginx从$remote_addr变量取得客户端IP地址，但也可以从其他变量获得。\r\n</p>\r\n<p>\r\n	例如：\r\n</p>\r\n<p>\r\n	geo $remote_addr $geo {\r\n</p>\r\n<p>\r\n	default 0;\r\n</p>\r\n<p>\r\n	127.0.0.1 1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	geo $arg_ttlsa_com $geo {\r\n</p>\r\n<p>\r\n	default 0;\r\n</p>\r\n<p>\r\n	127.0.0.1 1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如果该变量的值不能代表一个合法的IP地址，那么nginx将使用地址\"255.255.255.255\"。\r\n</p>\r\n<p>\r\n	nginx通过CIDR或者地址段来描述地址，支持下面几个参数：\r\n</p>\r\n<p>\r\n	1）delete：删除指定的网络\r\n</p>\r\n<p>\r\n	2）default：如果客户端地址不能匹配任意一个定义的地址，nginx将使用此值。 如果使用CIDR，可以用\"0.0.0.0/0\"代替default。\r\n</p>\r\n<p>\r\n	3）include： 包含一个定义地址和值的文件，可以包含多个。\r\n</p>\r\n<p>\r\n	4）proxy：定义可信地址。 如果请求来自可信地址，nginx将使用其“X-Forwarded-For”头来获得地址。 相对于普通地址，可信地址是顺序检测的。\r\n</p>\r\n<p>\r\n	5）proxy_recursive：开启递归查找地址。 如果关闭递归查找，在客户端地址与某个可信地址匹配时，nginx将使用\"X-Forwarded-For\"中的最后一个地址来代替原始客户端地址。如果开启递归查找，在客户端地址与某个可信地址匹配时，nginx将使用\"X-Forwarded-For\"中最后一个与所有可信地址都不匹配的地址来代替原始客户端地址。\r\n</p>\r\n<p>\r\n	6）ranges：使用以地址段的形式定义地址，这个参数必须放在首位。为了加速装载地址库，地址应按升序定义。\r\n</p>\r\n<p>\r\n	geo $country {\r\n</p>\r\n<p>\r\n	default ZZ;\r\n</p>\r\n<p>\r\n	include conf/geo.conf;\r\n</p>\r\n<p>\r\n	delete 127.0.0.0/16;\r\n</p>\r\n<p>\r\n	proxy 192.168.100.0/24;\r\n</p>\r\n<p>\r\n	proxy 2001:0db8::/32;\r\n</p>\r\n<p>\r\n	127.0.0.0/24 US;\r\n</p>\r\n<p>\r\n	127.0.0.1/32 RU;\r\n</p>\r\n<p>\r\n	10.1.0.0/16 RU;\r\n</p>\r\n<p>\r\n	192.168.1.0/24 UK;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# vim conf/geo.conf  //编辑conf/geo.cong文件\r\n</p>\r\n<p>\r\n	10.2.0.0/16 RU;\r\n</p>\r\n<p>\r\n	192.168.2.0/24 RU;\r\n</p>\r\n<p>\r\n	地址段例子：\r\n</p>\r\n<p>\r\n	geo $country {\r\n</p>\r\n<p>\r\n	ranges;\r\n</p>\r\n<p>\r\n	default ZZ;\r\n</p>\r\n<p>\r\n	127.0.0.0-127.0.0.0 US;\r\n</p>\r\n<p>\r\n	127.0.0.1-127.0.0.1 RU;\r\n</p>\r\n<p>\r\n	127.0.0.1-127.0.0.255 US;\r\n</p>\r\n<p>\r\n	10.1.0.0-10.1.255.255 RU;\r\n</p>\r\n<p>\r\n	192.168.1.0-192.168.1.255 UK;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	geo指令主要是根据IP来对变量进行赋值的。因此geo块下只能定义IP或网络段，否则会报错。\r\n</p>\r\n<p>\r\n	------------------------nginx利用geo模块做限速白名单操作------------------------\r\n</p>\r\n<p>\r\n	nginx的限速白名单需要结合geo和map指令来实现，map指令使用ngx_http_map_module模块提供的。默认情况下，nginx安装时是会自动加载这个模块，除非安装时人为手动添加--without-http_map_module。\r\n</p>\r\n<p>\r\n	ngx_http_map_module模块可以创建变量，这些变量的值与另外的变量值相关联。允许分类或者同时映射多个值到多个不同值并储存到一个变量中，map指令用来创建变量，但是仅在变量被接受的时候执行视\r\n</p>\r\n<p>\r\n	图映射操作，对于处理没有引用变量的请求时，这个模块并没有性能上的缺失。\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	geo $whiteiplist  {\r\n</p>\r\n<p>\r\n	default 1;\r\n</p>\r\n<p>\r\n	127.0.0.1 0;\r\n</p>\r\n<p>\r\n	192.0.0.0/8 0;\r\n</p>\r\n<p>\r\n	103.20.102.0/24 0;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	map $whiteiplist  $limit {\r\n</p>\r\n<p>\r\n	1 $binary_remote_addr;\r\n</p>\r\n<p>\r\n	0 \"\";\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	limit_conn_zone $limit zone=limit:10m;\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  test.huanqiu.com;\r\n</p>\r\n<p>\r\n	location ^~ /download/ {\r\n</p>\r\n<p>\r\n	limit_conn limit 4;\r\n</p>\r\n<p>\r\n	limit_rate 200k;\r\n</p>\r\n<p>\r\n	alias /data/www.huanqiu.com/data/download/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	------------------------如下是一个nginx中geo限速白名单的配置实例--------------------------\r\n</p>\r\n<p>\r\n	[root@localhost ~]# cat /usr/local/nginx/conf/vhosts/wangshibo.conf\r\n</p>\r\n<p>\r\n	geo $whiteiplist  {\r\n</p>\r\n<p>\r\n	default 1;\r\n</p>\r\n<p>\r\n	127.0.0.1 0;\r\n</p>\r\n<p>\r\n	192.168.0.0/16 0;\r\n</p>\r\n<p>\r\n	58.68.230.0/24 0;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	map $whiteiplist  $limit {\r\n</p>\r\n<p>\r\n	1 $binary_remote_addr;\r\n</p>\r\n<p>\r\n	0 \"\";\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	limit_conn_zone $limit zone=limit:10m;\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com wangshibo.com *.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /download/ {\r\n</p>\r\n<p>\r\n	limit_conn limit 4;        //最大的并发连接数\r\n</p>\r\n<p>\r\n	limit_rate 200k;           //每个连接的带宽\r\n</p>\r\n<p>\r\n	alias /data/wangshibo/download/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	配置要点解释：\r\n</p>\r\n<p>\r\n	1）geo指令定义一个白名单$whiteiplist, 默认值为1, 所有都受限制。 如果客户端IP与白名单列出的IP相匹配，则$whiteiplist值为0也就是不受限制。\r\n</p>\r\n<p>\r\n	2）map指令是将$whiteiplist值为1的，也就是受限制的IP，映射为客户端IP。将$whiteiplist值为0的，也就是白名单IP，映射为空的字符串。\r\n</p>\r\n<p>\r\n	3）limit_conn_zone和limit_req_zone指令对于键为空值的将会被忽略，从而实现对于列出来的IP不做限制。\r\n</p>\r\n<p>\r\n	测试方法\r\n</p>\r\n<p>\r\n	[root@localhost vhosts]# ab -c 100 -n 300  http://dev.wangshibo.com/download/docs/pdf/kevingarce.pdf\r\n</p>\r\n<p>\r\n	------------------------nginx利用geo模块做负载均衡的操作记录------------------------\r\n</p>\r\n<p>\r\n	本次测试的机器ip信息如下：\r\n</p>\r\n<p>\r\n	server1: 113.110.86.28\r\n</p>\r\n<p>\r\n	server2: 113.110.86.25\r\n</p>\r\n<p>\r\n	server3: 188.84.155.239\r\n</p>\r\n<p>\r\n	客户端1：113.110.86.23\r\n</p>\r\n<p>\r\n	客户端2：113.110.86.51\r\n</p>\r\n<p>\r\n	客户端3：113.110.86.19\r\n</p>\r\n<p>\r\n	三台server机器上都部署了nginx环境，为了测试效果，特意配置了server1和server2的9090端口的首页，如下：\r\n</p>\r\n<p>\r\n	[root@localhost ~]# curl http://113.110.86.28:9090\r\n</p>\r\n<p>\r\n	this is server1:113.110.86.28\r\n</p>\r\n<p>\r\n	[root@localhost ~]# curl http://113.110.86.25:9090\r\n</p>\r\n<p>\r\n	this is server2:113.110.86.25\r\n</p>\r\n<p>\r\n	配置server3，在server3上实现利用geo模块做负载均衡的目的,server3的nginx配置如下：\r\n</p>\r\n<p>\r\n	[root@localhost vhosts]# cat test.conf\r\n</p>\r\n<p>\r\n	geo $geo {\r\n</p>\r\n<p>\r\n	default default;\r\n</p>\r\n<p>\r\n	113.110.86.19/32   uk;\r\n</p>\r\n<p>\r\n	113.110.86.51/32   us;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	＃这里我是单网测试，所以掩码是32位；如果是vlan，可以是24位掩码，比如:\r\n</p>\r\n<p>\r\n	# 113.110.86.0/24   tw;\r\n</p>\r\n<p>\r\n	upstream  uk.server {\r\n</p>\r\n<p>\r\n	server 113.110.86.28:9090;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream  us.server {\r\n</p>\r\n<p>\r\n	server 113.110.86.25:9090;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream  default.server {\r\n</p>\r\n<p>\r\n	server 188.84.155.239:9090;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen    80;\r\n</p>\r\n<p>\r\n	server_name 188.84.155.239;\r\n</p>\r\n<p>\r\n	index index.html index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html/80;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_pass http://$geo.server$request_uri;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen    9090;\r\n</p>\r\n<p>\r\n	server_name 188.84.155.239;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root  /var/www/html/9090;\r\n</p>\r\n<p>\r\n	index index.html index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问server3的9090端口\r\n</p>\r\n<p>\r\n	[root@localhost vhosts]# curl http://188.84.155.239:9090\r\n</p>\r\n<p>\r\n	this is server3:188.84.155.239\r\n</p>\r\n<p>\r\n	------------------------接下来就开始测试-------------------------\r\n</p>\r\n<p>\r\n	1）在客户端1上访问http://188.84.155.239，如下：\r\n</p>\r\n<p>\r\n	[root@localhost ~]# curl http://188.84.155.239\r\n</p>\r\n<p>\r\n	this is server3:188.84.155.239\r\n</p>\r\n<p>\r\n	因为客户端1的IP地址为113.110.86.23，按照上面server3中nginx的配置，它访问的很明显是server3的9090端口！\r\n</p>\r\n<p>\r\n	2）在客户端2上访问http://188.84.155.239，如下：\r\n</p>\r\n<p>\r\n	[root@localhost ~]# curl http://188.84.155.239\r\n</p>\r\n<p>\r\n	this is server2:113.110.86.25\r\n</p>\r\n<p>\r\n	按照server3的nginx配置，客户端2访问server3的80端口就会被负载到server2的9090端口上！\r\n</p>\r\n<p>\r\n	3）在客户端3上访问http://188.84.155.239，如下：\r\n</p>\r\n<p>\r\n	[root@jenkins-server ~]# curl http://188.84.155.239\r\n</p>\r\n<p>\r\n	this is server1:113.110.86.28\r\n</p>\r\n<p>\r\n	按照server3的nginx配置，客户端3访问server3的80端口就会被负载到server1的9090端口上！\r\n</p>\r\n<p>\r\n	------------------------------------------------------------\r\n</p>\r\n<p>\r\n	通过上面的测试，很明显能看到geo模块起到了负载均衡的作用。这样就可以把三台服务器分别放到不同的IDC机房。然后在数据同步就可以了。\r\n</p>\r\n<p>\r\n	这样做的好处就是省去了在DNS上做手脚，因为智能DNS有时候按照来访IP解析的时候会解析对方的DNS地址，把它匹配到一台服务器，如果对方是\r\n</p>\r\n<p>\r\n	网通用户，它用的电信DNS，会直接把它匹配到电信的服务器。而nginx的geo模块就是根据来访问IP来匹配服务器的，这样只要我们把各地区的IP段收集起来就可以了~~\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('79338532-9b51-4e8a-9010-dbf52242be37','nginx应用总结（1）--基础认识和应用配置','nginx应用总结（1）--基础认识和应用配置','<p>\r\n	在linux系统下使用nginx作为web应用服务，用来提升网站访问速度的经验已五年多了，今天在此对nginx的使用做一简单总结。\r\n</p>\r\n<p>\r\n	一、nginx服务简介Nginx是一个高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP代理服务器。Nginx 已经因为它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名了。\r\n</p>\r\n<p>\r\n	使用 Nginx 前必须了解的事项：1）目前官方 Nginx 并不支持 Windows，您只能在包括 Linux、UNIX、BSD 系统下安装和使用；2）Nginx 本身只是一个 HTTP 和反向代理服务器，它无法像 Apache 一样通过安装各种模块来支持不同的页面脚本，例如 PHP、CGI 等；3）Nginx 支持简单的负载均衡和容错；4）支持作为基本 HTTP 服务器的功能，例如日志、压缩、Byte ranges、Chunked responses、SSL、虚拟主机等等，应有尽有。\r\n</p>\r\n<p>\r\n	Nginx工作原理：Nginx由内核和一系列模块组成，内核提供web服务的基本功能,如启用网络协议,创建运行环境,接收和分配客户端请求,处理模块之间的交互。Nginx的各种功能和操作都由模块来实现。Nginx的模块从结构上分为核心模块、基础模块和第三方模块。1）核心模块： HTTP模块、EVENT模块和MAIL模块2）基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块3）第三方模块： HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块及用户自己开发的模块这样的设计使Nginx方便开发和扩展，也正因此才使得Nginx功能如此强大。Nginx的模块默认编译进nginx中，如果需要增加或删除模块，需要重新编译Nginx,这一点不如Apache的动态加载模块方便。如果有需要动态加载模块，可以使用由淘宝网发起的web服务器Tengine，在nginx的基础上增加了很多高级特性，完全兼容Nginx，已被国内很多网站采用。\r\n</p>\r\n<p>\r\n	Nginx处理连接过程：nginx不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的循环来处理数千个连接。Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。监听套接字在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。\r\n</p>\r\n<p>\r\n	Nginx的工作模式很简单，就是采用一个master进程和多个worker工作进程：其中master进程的作用也是很明确的就是负责管理worker进程，同时监听连接请求，当连接请求到来之后将连接放入worker进程中去处理具体的业务请求，比如说http请求。 Nginx能够处理高并发的原因在于对socket的管理方式是异步非阻塞的，使用select/poll/epoll/kqueue 来实现对大量socket描述符的管理，每个worker进程有一个主线程，而没有其他的线程这样的好处就在于不需要进行线程间的切换，这样就节省了资源。所以总的来说：Nginx能够实现支持高并发的同时运行效率还很低的关键在于整个系统内部只有有限的几个工作进程和一个监听进程，而每个进程内部只有一个主线程，这样就不会引起很多的线程切换，从而降低了系统开销，同时每个线程内部使用异步非阻塞的方式来管理描述符这样就可以管理大量的描述符，当描述符多的时候也只是会占用较多的内存而已，而不会造成占用大量cpu时间。以上说的就是Nginx的进程模型和事件模型，事件模型中处理的情况主要有三种，分别是网络事件，如HTTP请求等，网络事件使用异步非阻塞模式就可以很好的解决；还有信号，定时器，信号和定时器还不是很明白。Nginx处理进程间争夺系统资源的方式：也就是进程间存在的惊群现象。\r\n</p>\r\n<p>\r\n	master：当 nginx 在启动后，会有一个 master 进程和多个 worker 进程。master进程主要用来管理worker进程，master 要做的就是：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。主要完成如下工作：1）读取并验证配置信息；2）创建、绑定及关闭套接字；3）启动、终止 worker 进程及维护 worker 进程的个数；4）无须中止服务而重新配置工作；5）控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；6）重新打开日志文件；7）编译嵌入式perl脚本\r\n</p>\r\n<p>\r\n	worker：对于基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求（一对一）。然而 nginx 没有专门地仲裁或连接分布的 worker,这项工作是由操作系统内核机制完成的。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。worker 进程主要完成的任务包括：1）接收、传入并处理来自客户端的连接；2）提供反向代理及过滤功能；3）nginx任何能完成的其它任务\r\n</p>\r\n<p>\r\n	举例说明一个完整请求如何通过互相协作来实现的：既然worker进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接。那么问题来了，到底最后怎样处理，是由什么决定的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求、解析请求、处理请求。产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到：一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。\r\n</p>\r\n<p>\r\n	也许有个疑问，那就是nginx采用多worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？然而，这就是 nginx 的高明之处，nginx 采用了异步非阻塞的方式来处理请求，也就是说，nginx 是可以同时处理成千上万个请求的。\r\n</p>\r\n<p>\r\n	异步非阻塞异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。\r\n</p>\r\n<p>\r\n	二、nginx相对于传统的apache服务的优缺点nginx相对比apache，实在有太多的优势。可以说，现在Nginx才是Web服务器的首选！！1）nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源；抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能； 高度模块化的设计，编写模块相对简单；社区活跃，各种高性能模块出品迅速；当然apache相对于nginx也有它自身的优点：rewrite比nginx 的rewrite强大；模块超多，基本想到的都可以找到；少bug，nginx的bug相对较多；超稳定；apache有自带php解析功能(apache环境部署好后，不需要再启动php服务，apache自动解析php文件，机器上只要有php命令即可；但是nginx不行，nginx必须结合php服务才能解析php文件，两则服务都要启动)\r\n</p>\r\n<p>\r\n	存在就是理由，一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就用apache。后者的各种功能模块实现得比前者，例如ssl 的模块就比前者好，可配置项多。这里要注意一点，epoll(freebsd 上是 kqueue )网络IO 模型是nginx 处理性能高的根本理由，但并不是所有的情况下都是epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的select 模型或许比epoll 更高性能。当然，这只是根据网络IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。\r\n</p>\r\n<p>\r\n	2）作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型. Nginx作为负载均衡服务器: Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多. 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验. Nginx 是一个安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）, Bugs 非常少的服务器: Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 . 3）Nginx 配置简洁,Apach复杂；Nginx静态处理性能比Apache高3倍以上；Apache对PHP支持比较简单，Nginx需要配合其他后端用；Apache的组件比Nginx多； 4）最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 5）nginx处理静态文件好,耗费内存少.但apache目前也有它的优势,有很多丰富的特性.所以还需要搭配着来.当然如果能确定nginx就适合需求,那么使用nginx会是更经济的方式. 6）从个人过往的使用情况来看，nginx的负载能力比apache高很多。最新的服务器也改用nginx了。而且nginx改完配置能-t测试一下配置有没有问题，apache重启的时候发现配置出错了，会很崩溃，改的时候都会非常小心翼翼现在看有好多集群站，前端nginx抗并发，后端apache集群，配合的也不错。 7）nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。 8）从个人经验来看，nginx是很不错的前端服务器，负载性能很好，linux服务器上运营nginx，用webbench模拟10000個个静态文件请求毫不吃力。apache对php等语言的支持很好，此外apache有強大的支持网路，反正时间相对nginx更久，bug少，但是apache有先天不支持多核心处理负载鸡肋的缺点，所以建议使用nginx做前端，后端用apache。大型网站建议用nginx自代的集群功能！9）Nginx优于apache的主要两点还体现在：Nginx本身就是一个反向代理服务器；Nginx支持7层负载均衡；其他的当然，Nginx可能会比apache支持更高的并发；Aapche因为其成熟的技术和开发社区，总体来说也有非常不错的性能，很多大公司而言还比较青睐apache。 10）你对web server的需求决定你的选择。大部分情况下nginx都优于apache，比如说静态文件处理、PHP-CGI的支持、反向代理功能、前端Cache、维持连接等等。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数飙升，从而拒绝服务的现象。 11）对于nginx，我喜欢它配置文件写的很简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器 12）Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache更好。\r\n</p>\r\n<p>\r\n	三、在 Linux 下安装 Nginx为了确保能在Nginx中使用正则表达式进行更灵活的配置，安装之前需要确定系统是否安装有PCRE（Perl Compatible Regular Expressions）包。您可以到ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/下载最新的PCR 源码包，使用下面命令下载编译和安装 PCRE 包：# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-7.7.tar.gz# tar zxvf pcre-7.7.tar.gz# cd pcre-7.7# ./configure# make# make install接下来安装 Nginx，Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /opt/nginx 目录下的详细步骤：# wget http://sysoev.ru/nginx/nginx-0.6.31.tar.gz# tar zxvf nginx-0.6.31.tar.gz# cd nginx-0.6.31# ./configure --with-http_stub_status_module –prefix=/opt/nginx# make# make install其中参数 --with-http_stub_status_module 是为了启用 nginx 的 NginxStatus 功能，用来监控 Nginx 的当前状态。安装成功后/opt/nginx 目录下有四个子目录分别是：conf、html、logs、sbin 。其中Nginx的配置文件存放于conf/nginx.conf，Nginx只有一个程序文件位于sbin目录下的nginx文件。确保系统的80端口没被其他程序占用，运行sbin/nginx命令来启动Nginx，打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。\r\n</p>\r\n<p>\r\n	常用的 Nginx 参数和控制程序运行参数Nginx 安装后只有一个程序文件，本身并不提供各种管理程序，它是使用参数和系统信号机制对 Nginx 进程本身进行控制的。 Nginx 的参数包括有如下几个：-c：使用指定的配置文件而不是 conf 目录下的 nginx.conf 。-t：测试配置文件是否正确，在运行时需要重新加载配置的时候，此命令非常重要，用来检测所修改的配置文件是否有语法错误。-v：显示 nginx 版本号。-V：显示 nginx 的版本号以及编译环境信息以及编译时的参数。例如我们要测试某个配置文件是否书写正确，我们可以使用以下命令sbin/nginx – t – c conf/nginx2.conf\r\n</p>\r\n<p>\r\n	通过信号对 Nginx 进行控制Nginx 支持下表中的信号：\r\n</p>\r\n<p>\r\n	有两种方式来通过这些信号去控制Nginx：第一是通过logs目录下的nginx.pid查看当前运行的Nginx的进程ID，通过 kill – XXX来控制 Nginx，其中 XXX 就是上表中列出的信号名。如果系统中只有一个Nginx进程，那也可以通过 killall 命令来完成，例如运行 killall – s HUP nginx 来让 Nginx 重新加载配置。\r\n</p>\r\n<p>\r\n	配置 Nginx先来看一个实际的配置文件：\r\n</p>\r\n<p>\r\n	user  nobody;# 工作进程的属主\r\n</p>\r\n<p>\r\n	worker_processes  4;# 工作进程数，一般与 CPU 核数等同\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  notice;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  info;\r\n</p>\r\n<p>\r\n	#pid        logs/nginx.pid;\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	use epoll;#Linux 下性能最好的 event 模式\r\n</p>\r\n<p>\r\n	worker_connections  2048;# 每个工作进程允许最大的同时连接数\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	#log_format  main  \'$remote_addr - $remote_user [$time_local] $request \'\r\n</p>\r\n<p>\r\n	#                  \'\"$status\" $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	#                  \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\r\n</p>\r\n<p>\r\n	#access_log  off;\r\n</p>\r\n<p>\r\n	access_log  logs/access.log;# 日志文件名\r\n</p>\r\n<p>\r\n	sendfile        on;\r\n</p>\r\n<p>\r\n	#tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay     on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	include 	 gzip.conf;\r\n</p>\r\n<p>\r\n	# 集群中的所有后台服务器的配置信息\r\n</p>\r\n<p>\r\n	upstream tomcats {\r\n</p>\r\n<p>\r\n	server 192.168.0.11:8080 weight=10;\r\n</p>\r\n<p>\r\n	server 192.168.0.11:8081 weight=10;\r\n</p>\r\n<p>\r\n	server 192.168.0.12:8080 weight=10;\r\n</p>\r\n<p>\r\n	server 192.168.0.12:8081 weight=10;\r\n</p>\r\n<p>\r\n	server 192.168.0.13:8080 weight=10;\r\n</p>\r\n<p>\r\n	server 192.168.0.13:8081 weight=10;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;#HTTP 的端口\r\n</p>\r\n<p>\r\n	server_name  localhost;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	#access_log  logs/host.access.log  main;\r\n</p>\r\n<p>\r\n	location ~ ^/NginxStatus/ {\r\n</p>\r\n<p>\r\n	stub_status on; #Nginx 状态监控配置\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ ^/(WEB-INF)/ {\r\n</p>\r\n<p>\r\n	deny all;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ \\.(htm|html|asp|php|gif|jpg|jpeg|png|bmp|ico|rar|css|js|\r\n</p>\r\n<p>\r\n	zip|java|jar|txt|flv|swf|mid|doc|ppt|xls|pdf|txt|mp3|wma)$ {\r\n</p>\r\n<p>\r\n	root /opt/webapp;\r\n</p>\r\n<p>\r\n	expires 24h;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcats;# 反向代理\r\n</p>\r\n<p>\r\n	include proxy.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	error_page 404 /html/404.html;\r\n</p>\r\n<p>\r\n	# redirect server error pages to the static page /50x.html\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	error_page 502 503 /html/502.html;\r\n</p>\r\n<p>\r\n	error_page 500 504 /50x.html;\r\n</p>\r\n<p>\r\n	location = /50x.html {\r\n</p>\r\n<p>\r\n	root   html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	Nginx 监控上面是一个实际网站的配置实例，其中#号后面的文字为配置说明。上述配置中，首先我们定义了一个 location ~ ^/NginxStatus/，这样通过 http://localhost/NginxStatus/ 就可以监控到 Nginx 的运行信息，显示的内容如下：Active connections: 70 server accepts handled requests 14553819 14553819 19239266 Reading: 0 Writing: 3 Waiting: 67\r\n</p>\r\n<p>\r\n	NginxStatus 显示的内容意思如下：active connections – 当前 Nginx 正处理的活动连接数。server accepts handled requests -- 总共处理了 14553819 个连接 , 成功创建 14553819 次握手 ( 证明中间没有失败的 ), 总共处理了 19239266 个请求 ( 平均每次握手处理了 1.3 个数据请求 )。reading -- nginx 读取到客户端的 Header 信息数。writing -- nginx 返回给客户端的 Header 信息数。waiting -- 开启 keep-alive 的情况下，这个值等于 active - (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接。\r\n</p>\r\n<p>\r\n	静态文件处理通过正则表达式，我们可让 Nginx 识别出各种静态文件，例如 images 路径下的所有请求可以写为：location ~ ^/images/ {&nbsp; &nbsp; &nbsp; &nbsp;root /opt/webapp/images;}而下面的配置则定义了几种文件类型的请求处理方式。location ~ \\.(htm|html|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ {&nbsp; &nbsp; &nbsp; root /opt/webapp;&nbsp; &nbsp; &nbsp; expires 24h;}对于例如图片、静态 HTML 文件、js 脚本文件和 css 样式文件等，我们希望 Nginx 直接处理并返回给浏览器，这样可以大大的加快网页浏览时的速度。因此对于这类文件我们需要通过 root 指令来指定文件的存放路径，同时因为这类文件并不常修改，通过 expires 指令来控制其在浏览器的缓存，以减少不必要的请求。 expires 指令可以控制 HTTP 应答中的“ Expires ”和“ Cache-Control ”的头标（起到控制页面缓存的作用）。您可以使用例如以下的格式来书写 Expires：expires 1 January, 1970, 00:00:01 GMT;expires 60s;expires 30m;expires 24h;expires 1d;expires max;expires off;\r\n</p>\r\n<p>\r\n	动态页面请求处理Nginx 本身并不支持现在流行的 JSP、ASP、PHP、PERL 等动态页面，但是它可以通过反向代理将请求发送到后端的服务器，例如 Tomcat、Apache、IIS 等来完成动态页面的请求处理。前面的配置示例中，我们首先定义了由 Nginx 直接处理的一些静态文件请求后，其他所有的请求通过 proxy_pass 指令传送给后端的服务器（在上述例子中是 Tomcat）。最简单的 proxy_pass 用法如下：location / {&nbsp; &nbsp; &nbsp; proxy_pass        http://localhost:8080;&nbsp; &nbsp; &nbsp; proxy_set_header  X-Real-IP  $remote_addr;}这里我们没有使用到集群，而是将请求直接送到运行在 8080 端口的 Tomcat 服务上来完成类似 JSP 和 Servlet 的请求处理。当页面的访问量非常大的时候，往往需要多个应用服务器来共同承担动态页面的执行操作，这时我们就需要使用集群的架构。 Nginx 通过 upstream 指令来定义一个服务器的集群，最前面那个完整的例子中我们定义了一个名为 tomcats 的集群，这个集群中包括了三台服务器共 6 个 Tomcat 服务。而 proxy_pass 指令的写法变成了：location / {&nbsp; &nbsp; &nbsp;proxy_pass        http://tomcats;&nbsp; &nbsp; &nbsp;proxy_set_header  X-Real-IP  $remote_addr;}在 Nginx 的集群配置中，Nginx 使用最简单的平均分配规则给集群中的每个节点分配请求。一旦某个节点失效时，或者重新起效时，Nginx 都会非常及时的处理状态的变化，以保证不会影响到用户的访问。\r\n</p>\r\n<p>\r\n	Nginx的location语法规则：location [=|~|~*|^~] /uri/ { … }=&nbsp; 开头表示精确匹配^~&nbsp; 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。~&nbsp; 开头表示区分大小写的正则匹配~*&nbsp; 开头表示不区分大小写的正则匹配!~和!~*&nbsp;分别为区分大小写不匹配及不区分大小写不匹配 的正则/&nbsp; 通用匹配，任何请求都会匹配到。\r\n</p>\r\n<p>\r\n	多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\r\n</p>\r\n<p>\r\n	示例说明：有如下匹配规则：location = / {   #规则A}location = /login {   #规则B}location ^~ /static/ {   #规则C}location ~ \\.(gif|jpg|png|js|css)$ {   #规则D}location ~* \\.png$ {   #规则E}location !~ \\.xhtml$ {   #规则F}location !~* \\.xhtml$ {   #规则G}location / {   #规则H}\r\n</p>\r\n<p>\r\n	产生的效果如下：访问根目录/， 比如http://localhost/ 将匹配规则A访问http://localhost/login 将匹配规则B，http://localhost/register 则匹配规则H访问http://localhost/static/a.html 将匹配规则C访问http://localhost/a.gif, http://localhost/b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用， 而 http://localhost/static/c.png 则优先匹配到 规则C访问http://localhost/a.PNG 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。访问http://localhost/a.xhtml 不会匹配规则F和规则G，http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。访问http://localhost/category/id/1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。\r\n</p>\r\n<p>\r\n	所以实际使用中，至少有三个匹配规则定义，如下：直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。这里是直接转发给后端应用服务器了，也可以是一个静态首页第一个必选规则location = / {    proxy_pass http://tomcat:8080/index}\r\n</p>\r\n<p>\r\n	第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ {    root /webroot/static/;}location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {    root /webroot/res/;}\r\n</p>\r\n<p>\r\n	第三个规则就是通用规则，用来转发动态请求到后端应用服务器非静态文件请求就默认是动态请求，自己根据实际把握毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location / {    proxy_pass http://tomcat:8080/}\r\n</p>\r\n<p>\r\n	尽管Nginx整个程序包只有500多K，但麻雀虽小、五脏俱全。 Nginx官方提供的各种功能模块应有尽有，结合这些模块可以完整各种各样的配置要求，例如：压缩、防盗链、集群、FastCGI、流媒体服务器、Memcached 支持、URL 重写等等，更关键的是Nginx拥有Apache和其他HTTP服务器无法比拟的高性能。甚至可以在不改变原有网站的架构上，通过在前端引入Nginx做负载均衡来提升网站的访问速度。\r\n</p>\r\n<p>\r\n	-------------------------------------------------------下面对Nginx的一些特殊设置做一说明-------------------------------------------------------\r\n</p>\r\n<p>\r\n	nginx的全局变量--------------------------------------------------------------------------------remote_addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端ip,如：192.168.4.2binary_remote_addr &nbsp; &nbsp;客户端ip（二进制)remote_port &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 客户端port，如：50472remote_user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 已经经过Auth Basic Module验证的用户名host &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求主机头字段，否则为服务器名称，如:dwz.stamhe.comrequest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;用户请求信息，如：GET /?_a=index&amp;_m=show&amp;count=10 HTTP/1.1request_filename &nbsp; &nbsp; &nbsp; &nbsp; 当前请求的文件的路径名，由root或alias和URI request组合而成，如：/webserver/htdocs/dwz/index.phpstatus &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求的响应状态码,如:200body_bytes_sent &nbsp; &nbsp; &nbsp; &nbsp; 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40content_length &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求头中的Content-length字段content_type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求头中的Content-Type字段http_referer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 引用地址http_user_agent &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 客户端agent信息,如：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11args &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如：_a=index&amp;_m=show&amp;count=10document_uri &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 与$uri相同,如：/index.phpdocument_root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 针对当前请求的根路径设置值,如：/webserver/htdocs/dwzhostname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如：centos53.localdomainhttp_cookie &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端cookie信息cookie_COOKIE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie &nbsp; COOKIE变量的值is_args &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果有$args参数，这个变量等于”?”，否则等于”\"，空值，如?limit_rate &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这个变量可以限制连接速率，0表示不限速query_string &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 与$args相同,如：_a=index&amp;_m=show&amp;count=10realpath_root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如：/webserver/htdocs/dwzrequest_body &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;记录POST过来的数据信息request_body_file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端请求主体信息的临时文件名request_method &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;客户端请求的动作，通常为GET或POST,如：GETrequest_uri &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。如：/index.php?_a=index&amp;_m=show&amp;count=10scheme &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HTTP方法（如http，https）,如：httpuri &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如：/index.phprequest_completion &nbsp; &nbsp; &nbsp; &nbsp;如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OKserver_protocol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1server_addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 服务器地址，在完成一次系统调用后可以确定这个值，如：192.168.4.129server_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器名称，如：dwz.stamhe.comserver_port &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 请求到达服务器的端口号,如：80\r\n</p>\r\n<p>\r\n	比如访问https://www.wangshibo.com/HouseGroup/index.html，跳转到https://www.wangshibo.com/index.php?r=houseGroup/index\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/index.html https://www.wangshibo.com/index.php?r=$1/index;\r\n</p>\r\n<p>\r\n	if ($request_uri  ~* \"/(jkhwpc|jkhw|jkhwadmin).php\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://www.jikehaiwai.com/$1 last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($request_uri  ~* \"/(qjspc|qjsmob|qjsadmin).php\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://www.qianjins.com/$1 last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-----------可以参考下面nginx的rewrite伪静态设置---------\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/equip(d+).html$ $1/index.php?m=content&amp;c=index&amp;a=lists&amp;catid=$2 last;\r\n</p>\r\n<p>\r\n	# nginx rewrite  rule\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/archiver/((fid|tid)-[w-]+.html)$ $1/archiver/index.php?$2 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/forum-([0-9]+)-([0-9]+).html$ $1/forumdisplay.php?fid=$2&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/thread-([0-9]+)-([0-9]+)-([0-9]+).html$ $1/viewthread.php?tid=$2&amp;extra=page%3D$4&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/profile-(username|uid)-(.+).html$ $1/viewpro.php?$2=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/space-(username|uid)-(.+).html$ $1/space.php?$2=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/tag-(.+).html$ $1/tag.php?name=$2 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)\\.(asp|aspx|asa|asax|dll|jsp|cgi|fcgi|pl)(.*)$ /404.php last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/(admin|cache|editor|file|include|lang|module|skin|template)/(.*)\\.php(.*)$ /404.php last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)-htm-(.*)$ /$1.php?$2 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/show-([0-9]+)([\\-])?([0-9]+)?\\.html$ /$1/show.php?itemid=$2&amp;page=$4 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/list-([0-9]+)([\\-])?([0-9]+)?\\.html$ /$1/list.php?catid=$2&amp;page=$4 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/show/([0-9]+)/([0-9]+)?([/])?$ /$1/show.php?itemid=$2&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/list/([0-9]+)/([0-9]+)?([/])?$ /$1/list.php?catid=$2&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/([A-za-z0-9_\\-]+)-c([0-9]+)-([0-9]+)\\.html$ /$1/list.php?catid=$3&amp;page=$4 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /$1/index.php?moduleid=$2&amp;catid=$3&amp;itemid=$4&amp;page=$5 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/([a-z]+)/(.*)\\.shtml$ $1/$2/index.php?rewrite=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(com)/([a-z0-9_\\-]+)/([a-z]+)/(.*)\\.html$ /index.php?homepage=$2&amp;file=$3&amp;rewrite=$4 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(com)/([a-z0-9_\\-]+)/([a-z]+)([/])?$ /index.php?homepage=$2&amp;file=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(com)/([a-z0-9_\\-]+)([/])?$ /index.php?homepage=$2 last;\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	1.rewrite跳转规则，有以下四种flag标记：last &nbsp; &nbsp; 基本上都用这个Flag，表示rewrite。break &nbsp; &nbsp; 中止Rewirte，不在继续匹配。就是说本条规则匹配完成后，终止匹配，不再匹配后面的规则。redirect &nbsp; &nbsp; 返回临时重定向的HTTP状态302；浏览器地址会显示跳转后的URL地址。permanent &nbsp; &nbsp; 返回永久重定向的HTTP状态301；浏览器地址会显示跳转后的URL地址。1）下面是可以用来判断的表达式：-f和!-f用来判断是否存在文件-d和!-d用来判断是否存在目录-e和!-e用来判断是否存在文件或目录-x和!-x用来判断文件是否可执行\r\n</p>\r\n<p>\r\n	先来看几个小例子说明\r\n</p>\r\n<p>\r\n	例如下面这段设定nginx将某个目录下面的文件重定向到另一个目录,$2对应第二个括号(.*)中对应的字符串：\r\n</p>\r\n<p>\r\n	location /download/ {\r\n</p>\r\n<p>\r\n	rewrite ^(/download/.*)/m/(.*)\\..*$ $1/nginx-rewrite/$2.gz break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	例如当用户输入 www.a.com.cn 自动跳转到www.a.com 这个域名：\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://www.a.com/$1 permanent;\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	例如下面设定nginx在用户使用ie的使用重定向到/nginx-ie目录下：\r\n</p>\r\n<p>\r\n	if ($http_user_agent ~ MSIE) {\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$ /nginx-ie/$1 break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	例如当用户访问testxqsjapi.xqshijie.com域名时跳转到本机的9501端口\r\n</p>\r\n<p>\r\n	upstream lb-9501 {\r\n</p>\r\n<p>\r\n	server 127.0.0.1:9501;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen  80;\r\n</p>\r\n<p>\r\n	server_name testxqsjapi.xqshijie.com;\r\n</p>\r\n<p>\r\n	root  /var/www/vhosts/testxqsjapi.xqshijie.com/;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://lb-9501;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	例如下面一例：nginx rewrite 实现二级域名跳转\r\n</p>\r\n<p>\r\n	当访问http://abc.wangshibo.com跳转到http://www.wangshibo.com/wangshibo/abc/\r\n</p>\r\n<p>\r\n	方法一:这种方法浏览器地址会变www.wangshibo.com/wangshibo/abc\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /data/wangshibo;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name *.wangshibo.com;\r\n</p>\r\n<p>\r\n	if ( $http_host ~* \"^(.*)\\.wangshibo\\.com$\") {\r\n</p>\r\n<p>\r\n	set $domain $1;\r\n</p>\r\n<p>\r\n	rewrite ^(.*) http://www.wangshibo.com/wangshibo/$domain/ break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	方法二：当访问http://abc.wangshibo.com跳转到http://www.wangshibo.com/wangshibo/abc/\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name *.wangshibo.com;\r\n</p>\r\n<p>\r\n	root /usr/local/www;\r\n</p>\r\n<p>\r\n	#这是里可以加多个目录,如果不加目录，会无法访问到abc.wangshibo.com/目录下的文件,如图片目录/images\r\n</p>\r\n<p>\r\n	location ~ ^/(wangshibo|images|styles)/\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	proxy_redirect        off;\r\n</p>\r\n<p>\r\n	proxy_set_header    Host   www.wangshibo.com;\r\n</p>\r\n<p>\r\n	proxy_pass      http://192.168.1.2:8080;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	set $domain default;\r\n</p>\r\n<p>\r\n	if ( $http_host ~* \"^(.*)\\.wangshibo\\.com$\") {\r\n</p>\r\n<p>\r\n	set $domain $1;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)    /wangshibo/$domain/$1 last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	再接着看下面的实例说明\r\n</p>\r\n<p>\r\n	#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。\r\n</p>\r\n<p>\r\n	#这里是直接转发给后端应用服务器了，也可以是一个静态首页\r\n</p>\r\n<p>\r\n	# 第一个必选规则\r\n</p>\r\n<p>\r\n	location = / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcat:8080/index\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\r\n</p>\r\n<p>\r\n	# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\r\n</p>\r\n<p>\r\n	location ^~ /static/ {\r\n</p>\r\n<p>\r\n	root /webroot/static/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\r\n</p>\r\n<p>\r\n	root /webroot/res/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#第三个规则就是通用规则，用来转发动态请求到后端应用服务器\r\n</p>\r\n<p>\r\n	#非静态文件请求就默认是动态请求，自己根据实际把握\r\n</p>\r\n<p>\r\n	#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcat:8080/\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）实例说明1）访问A站跳转(重定向)到B站server { &nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name www.wangshibo.com ; &nbsp; &nbsp; rewrite ^(.*) http://www.huanqiu.com$1 permanent;\r\n</p>\r\n<p>\r\n	root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log /usr/local/nginx/logs/image.log;}\r\n</p>\r\n<p>\r\n	访问wangshibo.com跳转到www.wangshibo.com\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com wangshibo.com;\r\n</p>\r\n<p>\r\n	index index.jsp index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	if ($host = \"wangshibo.com\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ http://www.wangshibo.com permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）多域名绑定一个目录，并且全部301跳转到其中一个域名（注意：多域名都要解析到本机ip上）server {&nbsp; &nbsp; &nbsp;listen 80;&nbsp; &nbsp; &nbsp;server_name www.wangshibo.com web01.wangshibo.com hehe.wangshibo.com wangshibo.com;&nbsp; &nbsp; &nbsp;if ($host != \'www.wangshibo.com\') {&nbsp; &nbsp; &nbsp;rewrite ^/(.*)$  http://www.wangshibo.com/$1 permanent;&nbsp; &nbsp; &nbsp;}&nbsp; &nbsp; &nbsp;root /var/www/html;&nbsp; &nbsp; &nbsp;index index.html index.php index.htm;&nbsp; &nbsp; &nbsp;access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	上面说明访问http://web01.wangshibo.com、http://hehe.wangshibo.com、http://wangshibo.com的时候都会自动跳转到http://www.wangshibo.com,并且浏览器地址会显示跳转后的URL地址。\r\n</p>\r\n<p>\r\n	如果是上面多域名访问后都重定向跳转到http://hehe.wangshibo.com，则配置修改如下：server {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name www.wangshibo.com web01.wangshibo.com hehe.wangshibo.com wangshibo.com;&nbsp; &nbsp; if ($host != \'hehe.wangshibo.com\') {&nbsp; &nbsp; rewrite ^/(.*)$  http://hehe.wangshibo.com/$1 permanent;&nbsp; &nbsp; }&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	如下配置：多域名中的某个域名访问时发生跳转，其他域名访问时不跳转server {&nbsp; &nbsp;listen 80;&nbsp; &nbsp;server_name www.wangshibo.com web01.wangshibo.com hehe.wangshibo.com wangshibo.com;&nbsp; &nbsp;if ($host = \'hehe.wangshibo.com\') {&nbsp; &nbsp; &nbsp; &nbsp;rewrite ^/(.*)$ http://www.huanqiu.com/$1 permanent;&nbsp; &nbsp;}&nbsp; &nbsp;root /var/www/html;&nbsp; &nbsp;index index.html index.php index.htm;&nbsp; &nbsp;access_log /usr/local/nginx/logs/image.log;}\r\n</p>\r\n<p>\r\n	3）将多级目录下的文件转成一个文件，增强seo效果比如将/wang-123-456-789.html指向wang/123/456/wangshow_789.html[root@test-huanqiu ~]# cat /usr/local/nginx/conf/vhosts/test.conf server {&nbsp; &nbsp; &nbsp;listen 80;&nbsp; &nbsp; &nbsp;server_name www.wangshibo.com;&nbsp; &nbsp; &nbsp;rewrite ^/wang-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ http://www.wangshibo.com/wang/$1/$2/wangshow_$3.html last;&nbsp; &nbsp; &nbsp;root /var/www/html;&nbsp; &nbsp; &nbsp;index index.html index.php index.htm;&nbsp; &nbsp; &nbsp;access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样访问http://www.wangshibo.com/wang-123-456-789.html就会跳转到http://www.wangshibo.com/wang/123/456/wangshow_789.html\r\n</p>\r\n<p>\r\n	4）访问的目标文件和目录资源不存在的时候重定向跳转如下配置，当访问http://www.wangshibo.com/后面的访问资源（文件或目录）不存在时，统统跳转到http://www.wangshibo.com/sorry.html页面server {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name www.wangshibo.com;&nbsp; &nbsp; if (!-e $request_filename) {&nbsp; &nbsp; &nbsp; &nbsp; rewrite ^/ http://www.wangshibo.com/sorry.html ;&nbsp; &nbsp; }&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log /usr/local/nginx/logs/image.log;}\r\n</p>\r\n<p>\r\n	5）将站点根目录下某个目录指向二级目录例如将/huanqiupc/指向/ops/huanqiu/，配置如下：server {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name www.wangshibo.com;&nbsp; &nbsp; rewrite ^/([0-9a-z]+)pc/(.*)$ http://www.wangshibo.com/ops/$1/$2 last;&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log /usr/local/nginx/logs/image.log;}\r\n</p>\r\n<p>\r\n	这样，访问http://www.wangshibo.com/huanqiupc的时候就会跳转到http://www.wangshibo.com/ops/huanqiu/注意：上面的配置中的last修改为permanent或redirect都可以\r\n</p>\r\n<p>\r\n	以上的配置也适用于：（前提是这些目录要真是存在于站点目录/var/www/html/中，并且权限要正确）将/wangshibopc/指向/ops/wangshibo/将/guohuihuipc/指向/ops/guohuihui/将/hahapc/指向/ops/haha/......\r\n</p>\r\n<p>\r\n	6）其他的rewrite跳转规则的例子：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.htm;\r\n</p>\r\n<p>\r\n	rewrite ^/site/resource/(.*)$ https://www.wangshibo.com/resource/$1 last;\r\n</p>\r\n<p>\r\n	rewrite ^/active/Ymf.html$ https://www.wangshibo.com/project/detail.html?project_id=1 last;\r\n</p>\r\n<p>\r\n	rewrite ^/active/Ysyg.html$ https://www.wangshibo.com/project/detail.html?project_id=7 last;\r\n</p>\r\n<p>\r\n	if ($host ~* \"^wangshibo.com$\") {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)$ https://www.wangshibo.com/ permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	rewrite /abc http://www.huanqiu.com break;    #本机站点目录下并不需要真实存在abc这个目录，对虚拟目录的访问都重写到http://www.huanqiu.com\r\n</p>\r\n<p>\r\n	}                                               #即访问http://www.wangshibo.com/abc，跳转到http://www.huanqiu.com\r\n</p>\r\n<p>\r\n	location /text {\r\n</p>\r\n<p>\r\n	rewrite / http://china.huanqiu.com break;     #本机站点目录下需要真实存在text目录，对其的访问都重写到http://china.huanqiu.com\r\n</p>\r\n<p>\r\n	}                                               #即访问http://www.wangshibo.com/text，跳转到http://china.huanqiu.com\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	下面一例：访问http://www.wangshibo.com/g/4HG45SkZ 实际访问地址跳转为 http://110.10.88.99:8081/qun/share/view?code=4HG45SkZ\r\n</p>\r\n<p>\r\n	upstream  g_server {\r\n</p>\r\n<p>\r\n	keepalive 64;\r\n</p>\r\n<p>\r\n	server 110.10.88.99:8081 max_fails=2 fail_timeout=5 weight=100;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	rewrite ^/bcloud.(swf|html|js)(.*)$ http://hehe.wangshibo.com/bcloud.$1$2 last;\r\n</p>\r\n<p>\r\n	root  /home/web/www;\r\n</p>\r\n<p>\r\n	location ~ \\.apk$ {\r\n</p>\r\n<p>\r\n	max_ranges 0;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /g {\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	#           proxy_set_header Host $host:$remote_port;\r\n</p>\r\n<p>\r\n	#           proxy_set_header REMOTE_PORT $remote_port;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	client_max_body_size 1G;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 30;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 30;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 16k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 32k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 64k;\r\n</p>\r\n<p>\r\n	proxy_pass  http://g_server;\r\n</p>\r\n<p>\r\n	#rewrite \"/g/(.*$)\"   www.wangshibo.com/qun/share/view?code=$1  break;\r\n</p>\r\n<p>\r\n	rewrite \"/g/(.*$)\"   /qun/share/view?code=$1  break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	另外注意：$1表示第一个变量，即前面rewrite后第一个（）内设置的变量$2表示第二个变量，即前面rewrite后第二个（）内设置的变量\r\n</p>\r\n<p>\r\n	再看一例：访问http://www.wangshibo.com/thumb/transcode 实际访问地址为 http://120.170.190.99:28080/transcode/thumb/transcode\r\n</p>\r\n<p>\r\n	upstream  thumb {\r\n</p>\r\n<p>\r\n	keepalive 64;\r\n</p>\r\n<p>\r\n	server 120.170.190.99:28080 max_fails=2 fail_timeout=5 weight=100;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com ;\r\n</p>\r\n<p>\r\n	root   /home/web/www;\r\n</p>\r\n<p>\r\n	location ^~ /thumb {\r\n</p>\r\n<p>\r\n	proxy_pass  http://thumb;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded_For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	client_max_body_size 1G;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 30;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 30;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 60;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 16k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 32k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 64k;\r\n</p>\r\n<p>\r\n	rewrite  \"^/(.*)$\"  /transcode/$1 break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	----------------------------再看一个访问nginx跳转后的url不变的例子--------------------------------------\r\n</p>\r\n<p>\r\n	需要特别注意的是：\r\n</p>\r\n<p>\r\n	proxy_pass 反向代理，可以实现只改变跳转后的内容，而跳转后的原url保持不变！\r\n</p>\r\n<p>\r\n	rewrite 重写跳转后会进行重定向，很难实现跳转后的原url不变的需求。\r\n</p>\r\n<p>\r\n	看看之前踩过的坑;\r\n</p>\r\n<p>\r\n	要求访问http://wx2.xqshijie.com/apiwx2/xqsj.php?r=houseGroup%2FgetToken，内容跳转到http://m.xqshijie.com/xqsj.php?r=houseGroup%2FgetToken，但是跳转后的url保持不变！\r\n</p>\r\n<p>\r\n	这是根据path路径进行反向代理的配置，即要求访问http://wx2.xqshijie.com/apiwx2/$1 跳转到http://m.xqshijie.com/$1，跳转后的url不变！\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	[root@fangfull_web1 vhosts]# cat wx2.xqshijie.com.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  wx2.xqshijie.com;\r\n</p>\r\n<p>\r\n	root  /Data/app/xqsj_wx2/dist;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	#if ($http_x_forwarded_for !~ ^(124.65.197.154|103.10.86.28|103.10.86.8)) {\r\n</p>\r\n<p>\r\n	#   rewrite ^.*$  /maintence.php last;\r\n</p>\r\n<p>\r\n	#}\r\n</p>\r\n<p>\r\n	location /apiwx2/ {\r\n</p>\r\n<p>\r\n	proxy_pass https://m.xqshijie.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	access_log  /var/log/betawx2.log  main;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	try_files $uri $uri/ @router;\r\n</p>\r\n<p>\r\n	index  index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#rewrite ^(.+)$ /index.html last;\r\n</p>\r\n<p>\r\n	location @router {\r\n</p>\r\n<p>\r\n	rewrite ^.*$ /index.html last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	根据上面配置后，就可以实现访问http://wx2.xqshijie.com/apiwx2/xqsj.php?r=houseGroup%2FgetToken，实际显示的是https://m.xqshijie.com/xqsj.php?r=houseGroup%2FgetToken的内容，但是跳转后的原来的url不变！\r\n</p>\r\n<p>\r\n	如果采用rewrite重写规则，即将：\r\n</p>\r\n<p>\r\n	location /apiwx2/ {\r\n</p>\r\n<p>\r\n	proxy_pass https://m.xqshijie.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	改为\r\n</p>\r\n<p>\r\n	location /apiwx2/ {\r\n</p>\r\n<p>\r\n	rewrite ^/apiwx2(.*)$ https://m.xqshijie.com.$1 last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	那么，访问http://wx2.xqshijie.com/apiwx2/xqsj.php?r=houseGroup%2FgetToken，实际显示的是https://m.xqshijie.com/xqsj.php?r=houseGroup%2FgetToken的内容，但是跳转后的url已经变了！\r\n</p>\r\n<p>\r\n	上面碰到过的坑：\r\n</p>\r\n<p>\r\n	由于访问http://m.xqshijie.com就会自动跳转到https://m.xqshijie.com，所以如果将上面的配置改为（即将https://m.xqshijie.com改为http://m.xqshijie.com）：\r\n</p>\r\n<p>\r\n	location /apiwx2/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://m.xqshijie.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样，访问http://wx2.xqshijie.com/apiwx2/xqsj.php?r=houseGroup%2FgetToken，实际显示的是https://m.xqshijie.com/xqsj.php?r=houseGroup%2FgetToken的内容，但是跳转后的原来的url已经变了！\r\n</p>\r\n<p>\r\n	原因是因为这里经过了两次跳转，即rewrite-&gt;http-&gt;https，所以跳转后的url变了。\r\n</p>\r\n<p>\r\n	解决办法：就是直接rewrite跳转到https，即proxy_pass https://m.xqshijie.com/;\r\n</p>\r\n<p>\r\n	----------------------------下面的跳转规则表示---------------------------------------访问http://www.wangshibo.com/wangshibo/ops就会跳转到http://www.wangshibo.com/ops/wangshibo访问http://www.wangshibo.com/wangshibo/beijing就会跳转到http://www.wangshibo.com/beijing/wangshibo......即由\"wangshibo/变量\"--&gt;\"变量/wangshibo\"\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	rewrite ^/wangshibo/(.*)$  http://www.wangshibo.com/$1/wangshibo last;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问http://www.wangshibo.com/ops/web 跳转到 http://www.wangshibo.com/web/ops/web/\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	rewrite ^/ops/(.*)$  http://www.wangshibo.com/$1/ops/$1 break;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	访问http://www.wangshibo.com/wang/123 实际访问地址跳转为 http://www.hehe.com/qun/share/view?code=123\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	rewrite ^/wang/(.*)$  http://www.hehe.com/qun/share/view?code=$1 last;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	其他配置实例\r\n</p>\r\n<p>\r\n	如果nginx在用户使用IE浏览器访问情况下,则重定向到/nginx-ie目录下\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	if ($http_user_agent ~ MSIE) {\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$ /nginx-ie/$1 break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	多目录转成参数\r\n</p>\r\n<p>\r\n	abc.domian.com/sort/2 =&gt; abc.domian.com/index.php?act=sort&amp;name=abc&amp;id=2\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	if ($host ~* (.*)\\.domain\\.com) {\r\n</p>\r\n<p>\r\n	set $sub_name $1;\r\n</p>\r\n<p>\r\n	rewrite ^/sort\\/(\\d+)\\/?$ /index.php?act=sort&amp;cid=$sub_name&amp;id=$1 last;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	目录自动加\"/\"，前提是访问目录存在\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	if (-d $request_filename){\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	三级域名跳转\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	if ($http_host ~* “^(.*)\\.i\\.beijing\\.com$”) {\r\n</p>\r\n<p>\r\n	rewrite ^(.*) http://www.wangshibo.com$1/;\r\n</p>\r\n<p>\r\n	break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	针对站点根目录下的某个子目录作镜向\r\n</p>\r\n<p>\r\n	配置如下：就会把http://www.huanqiu.com的内容（即首页）镜像到/var/www/html下的ops目录下了\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	location ^~ /ops {\r\n</p>\r\n<p>\r\n	rewrite ^.+ http://www.huanqiu.com/ last;\r\n</p>\r\n<p>\r\n	break;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	域名镜像（其实就是域名跳转）\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name www.wangshibo.com;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*) http://www.huanqiu.com/$1 last;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	其他：\r\n</p>\r\n<p>\r\n	rewrite ^/(space|network)-(.+)\\.html$ /$1.php?rewrite=$2 last;\r\n</p>\r\n<p>\r\n	rewrite ^/(space|network)\\.html$ /$1.php last;\r\n</p>\r\n<p>\r\n	rewrite ^/([0-9]+)$ /space.php?uid=$1 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/archiver/((fid|tid)-[\\w\\-]+\\.html)$ $1/archiver/index.php?$2 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/forum-([0-9]+)-([0-9]+)\\.html$ $1/forumdisplay.php?fid=$2&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ $1/viewthread.php?tid=$2&amp;extra=page\\%3D$4&amp;page=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/profile-(username|uid)-(.+)\\.html$ $1/viewpro.php?$2=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/space-(username|uid)-(.+)\\.html$ $1/space.php?$2=$3 last;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)/tag-(.+)\\.html$ $1/tag.php?name=$2 last;\r\n</p>\r\n<p>\r\n	目录对换：/1234/xxx -----&gt;xxx?id=1234配置如下：[root@test-huanqiu ~]# vim /usr/local/nginx/conf/vhosts/test.confserver {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name www.wangshibo.com;&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log /usr/local/nginx/logs/image.log;}\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cat /var/www/html/ops/index.html nginx的目录对换的跳转测试\r\n</p>\r\n<p>\r\n	如上配置后，那么：访问http://www.wangshibo.com/?id=567567567567567 的结果就是http://www.wangshibo.com/的结果访问http://www.wangshibo.com/ops/?id=wangshibo  的结果就是http://www.wangshibo.com/ops的结果访问http://www.wangshibo.com/wang/?id=123111  的结果就是http://www.wangshibo.com/wang的结果.......\r\n</p>\r\n<p>\r\n	2.反向代理（proxy_pass）简单测试nginx反向代理和负载均衡功能的操作记录（1）-----http代理简单测试nginx反向代理和负载均衡功能的操作记录（2）-----https代理\r\n</p>\r\n<p>\r\n	3.缓存设置nginx反向代理+缓存开启+url重写+负载均衡(带健康探测)的部署记录nginx缓存配置的操作记录梳理\r\n</p>\r\n<p>\r\n	4.防盗链。关于Nginx防盗链具体设置，可参考：Nginx中防盗链（下载防盗链和图片防盗链）的操作记录location ~* \\.(gif|jpg|swf)$ {    valid_referers none blocked start.igrow.cn sta.igrow.cn;    if ($invalid_referer) {        rewrite ^/ http://$host/logo.png;    }}\r\n</p>\r\n<p>\r\n	下面设置文件反盗链并设置过期时间：location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {&nbsp; &nbsp; valid_referers none blocked *.wangshibo.com*.wangshibo.net localhost 218.197.67.14;&nbsp; &nbsp; if ($invalid_referer) {&nbsp; &nbsp; &nbsp; &nbsp;rewrite ^/ http://img.wangshibo.net/leech.gif;&nbsp; &nbsp; &nbsp; &nbsp;return 412;&nbsp; &nbsp; &nbsp; &nbsp;break;&nbsp; &nbsp; &nbsp; }&nbsp; &nbsp;access_log  off;&nbsp; &nbsp;root /opt/lampp/htdocs/web;&nbsp; &nbsp;expires 3d;&nbsp; &nbsp;break;}\r\n</p>\r\n<p>\r\n	这里的return 412 是自定义的http状态码，默认为403，方便找出正确的盗链的请求“rewrite ^/ http://img.wangshibo.net/leech.gif;”显示一张防盗链图片“access_log off;”不记录访问日志，减轻压力“expires 3d”所有文件3天的浏览器缓存\r\n</p>\r\n<p>\r\n	5.根据文件类型设置过期时间1）expires起到控制页面缓存的作用，合理的配置expires可以减少很多服务器的请求；2）对于站点中不经常修改的静态内容（如图片，JS，CSS），可以在服务器中设置expires过期时间，控制浏览器缓存，达到有效减小带宽流量，降低服务器压力的目的。3）Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。要配置expires，可以在http段中或者server段中或者location段中加入；如下：控制图片等过期时间为30天，如果图片文件不怎么更新，过期可以设大一点；如果频繁更新，则可以设置得小一点，具体视情况而定location ~ \\.(gif|jpg|jpeg|png|bmp|swf|ico)$ {&nbsp; &nbsp; root /var/www/img/;&nbsp; &nbsp; expires 30d;       }\r\n</p>\r\n<p>\r\n	location ~ .*\\.(js|css)$ { &nbsp; &nbsp;expires 10d; }\r\n</p>\r\n<p>\r\n	location ~* \\.(js|css|jpg|jpeg|gif|png|swf)$ {&nbsp; &nbsp;if (-f $request_filename) {&nbsp; &nbsp;expires 1h;&nbsp; &nbsp;break;&nbsp; &nbsp;}}\r\n</p>\r\n<p>\r\n	location ~ \\.(wma|wmv|asf|mp3|mmf|zip|rar|swf|flv)$ {&nbsp; &nbsp;root /var/www/upload/;&nbsp; &nbsp;expires max;       }\r\n</p>\r\n<p>\r\n	expires 指令可以控制 HTTP 应答中的“ Expires ”和“ Cache-Control ”的头标（起到控制页面缓存的作用）语法：expires [time|epoch|max|off]默认值：offexpires指令控制HTTP应答中的“Expires”和“Cache-Control”Header头部信息，启动控制页面缓存的作用time:可以使用正数或负数。“Expires”头标的值将通过当前系统时间加上设定time值来设定。time值还控制\"Cache-Control\"的值：负数表示no-cache正数或零表示max-age=timeepoch：指定“Expires”的值为 1   January,1970,00:00:01 GMTmax:指定“Expires”的值为31      December2037 23:59:59GMT,\"Cache-Control\"的值为10年。（即设置过期时间最最长）-1：指定“Expires”的值为当前服务器时间-1s，即永远过期。off：不修改“Expires”和\"Cache-Control\"的值\r\n</p>\r\n<p>\r\n	expires使用了特定的时间，并且要求服务器和客户端的是中严格同步。而Cache-Control是用max-age指令指定组件被缓存多久。对于不支持http1.1的浏览器，还是需要expires来控制。所以最好能指定两个响应头。但HTTP规范规定max-age指令将重写expires头。\r\n</p>\r\n<p>\r\n	如何检测nginx中设置的expires网页过期时间是否生效？方法：打开webkaka的网站速度诊断工具(http://pagespeed.webkaka.com/)，输入你的网页地址，检测后，立即可以看到设置是否生效了。如下图所示：\r\n</p>\r\n<p>\r\n	上图可以看到，被检测网页的js文件过期时间为1天（12h）。\r\n</p>\r\n<p>\r\n	6.禁止访问某个文件或目录1）禁止访问以txt或doc结尾的文件location ~* \\.(txt|doc)${root /data/www/wwwroot/linuxtone/test;deny all;}\r\n</p>\r\n<p>\r\n	2）nginx禁止访问所有.开头的隐藏文件设置location ~* /.* {deny all;}\r\n</p>\r\n<p>\r\n	3）nginx禁止访问目录location ^~ /path {deny all;}\r\n</p>\r\n<p>\r\n	4）禁止访问扩展名为bat的文件location ~* /.bat {  deny all;}\r\n</p>\r\n<p>\r\n	5）禁止访问configs目录，以及其下所有子目录或文件location ^~ /configs/ {  deny all;}注意上述configs后面的斜杠不能少，否则所有以configs开头的目录或文件都将禁止访问。\r\n</p>\r\n<p>\r\n	6）禁止访问多个目录location ~ ^/(cron|templates)/ {deny all;break;}\r\n</p>\r\n<p>\r\n	7）禁止访问以/data开头的文件location ~ ^/data {deny all;}\r\n</p>\r\n<p>\r\n	8）禁止访问以.sh,.flv,.mp3为文件后缀名的文件location ~ .*\\.(sh|flv|mp3)$ {return 403;}\r\n</p>\r\n<p>\r\n	9）或者以=符号形式location = /config/ { return 404; } location =/config.ini{ return 404; }\r\n</p>\r\n<p>\r\n	10）禁止htaccesslocation ~/\\.ht {    deny all;}\r\n</p>\r\n<p>\r\n	return指令语法：returncode ;使用环境：server,location,if;该指令用于结束规则的执行并返回状态码给客户端。\r\n</p>\r\n<p>\r\n	例如：访问的URL以\".sh\"或\".bash\"结尾，则返回403状态码location ~ .*\\.(sh|bash)?$ {return 403;}\r\n</p>\r\n<p>\r\n	7.禁止IP访问 只允许域名访问当别人通过ip或者未知域名访问你的网站的时候，你希望禁止显示任何有效内容，可以给他返回500.目前国内很多机房都要求网站主关闭空主机头，防止未备案的域名指向过来造成麻烦。为了避免网站遭受恶意IP攻击，需要禁止IP访问，只能使用域名访问站点！\r\n</p>\r\n<p>\r\n	listen行加上default（或default_server）参数，表示这个是默认虚拟主机。所以，禁止ip访问，只能使用域名访问的正确配置是：server {&nbsp; &nbsp; &nbsp;listen 80 default_server;&nbsp; &nbsp; &nbsp;server_name _;&nbsp; &nbsp; &nbsp;return 500;}\r\n</p>\r\n<p>\r\n	server {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name  web01.wangshibo.cn;&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	注意：如果在上面的server_name配置中指定域名的同时，也指明了ip访问，比如server_name 103.110.186.17 web01.wangshibo.cn那么尽管上面已经做了返回500设置，也禁止不了ip访问！也就是说，只要server_name一行指明了ip访问，那么就禁止不了了。\r\n</p>\r\n<p>\r\n	以上设置，可以将ip访问禁用，这样的话，使用ip访问的流量就会丢失。如果想把这部分流量收集起来，导入到自己的网站，只要做以下跳转设置就可以：server { &nbsp; &nbsp; listen 80 default; &nbsp; &nbsp; rewrite ^(.*) http://www.wangshibo.com permanent;  }\r\n</p>\r\n<p>\r\n	server {&nbsp; &nbsp; listen 80;&nbsp; &nbsp; server_name web01.wangshibo.cn;&nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	下面列出其他的一些细节导致的不同效果：1）将ip和域名访问统统禁止，返回403（或者配置return 500）错误页server {     listen 80 default_server;     server_name _;     return 403;\r\n</p>\r\n<p>\r\n	root /var/www/html;     index index.html index.php index.htm;     access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	2）下面的配置：指明了只能使用域名，即http://web01.wangshibo.cn访问配置中的站点（/var/www/html）不能使用ip，即http://103.110.186.17访问配置中的站点。但是可以使用ip方式访问nginx默认的根目录下的内容（比如/usr/local/nginx/html）server {     listen 80 ;      server_name web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;     index index.html index.php index.htm;     access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	下面的配置，指明了使用域名或ip都可以访问配置中的站点。（使用ip访问只限于只有一个vhost虚拟主机配置的情况，如果是多个，那么指明ip访问就会混淆）server {     listen 80 ;      server_name 103.110.186.17 web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;     index index.html index.php index.htm;     access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	3）下面两个的配置后，都能使用域名或ip访问配置中的站点。server {     listen 80 default;      server_name web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;     index index.html index.php index.htm;     access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	server {     listen 80 default;      server_name 103.110.186.17 web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;     index index.html index.php index.htm;     access_log  /usr/local/nginx/logs/image.log; }\r\n</p>\r\n<p>\r\n	8.流量限制对于提供下载的网站，肯定是要进行流量控制的，例如BBS、视频服务，还是其它专门提供下载的网站。在nginx中我们完全可以做到限流，由Nginx模块中的Core模块提供了limit_rate、limit_rate_after命令，我们只需要调用命令实现流量限制就行。实现流量限制由两个指令limit_rate和limit_rate_after共同完成：limit_rate语法: limit_rate rate;默认值: limit_rate 0;作用域: http, server, location,&nbsp;location中的if字段命令概述：限制向客户端传送响应的速率限制。参数 rate 的单位是字节/秒，\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('7fa6083b-d62b-463f-87f1-4f285c7a6cf5','Nginx+keepalived双机热备（主主模式）','Nginx+keepalived双机热备（主主模式）','<p>\r\n	之前已经介绍了Nginx+Keepalived双机热备的主从模式，今天在此基础上说下主主模式的配置。\r\n</p>\r\n<p>\r\n	由之前的配置信息可知：master机器（master-node）：103.110.98.14/192.168.1.14 &nbsp; &nbsp; &nbsp;VIP1:103.110.98.20slave机器（slave-node）：103.110.98.24/192.168.1.24 &nbsp; &nbsp; &nbsp; VIP2:103.110.98.21\r\n</p>\r\n<p>\r\n	主主模式需要两台负载均衡机器都要绑定VIP，之前在master机器上已经绑定了VIP（103.110.98.20）所以需要在slave-node上再绑定一个VIP（103.110.98.21）\r\n</p>\r\n<p>\r\n	（1）在slave负载机上绑定另一个VIP（这一步其实可以不用这么直接在外部使用ifconfig绑定。Nginx或Haproxy+Keepalived的七层负载均衡的高可用环境中，VIP就直接在 Keepalived 的配置文件里配置就好，使用命令 ip addr 就能看出 vip；而LVS+Keepalived 四层负载均衡的高可用环境中， vip是要在外面单独设置的（即ifconfig eth0:0 ....的方式创建vip），通过 ifconfig 可以查看出来 vip。）\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# ifconfigem1: flags=4163<up,broadcast,running,multicast> mtu 1500inet 103.110.98.24 netmask 255.255.255.192 broadcast 103.110.98.63inet6 fe80::46a8:42ff:fe17:3ddd prefixlen 64 scopeid 0x20ether 44:a8:42:17:3d:dd txqueuelen 1000 (Ethernet)RX packets 133787818 bytes 14858530059 (13.8 GiB)RX errors 0 dropped 644 overruns 0 frame 0TX packets 2291619 bytes 426619870 (406.8 MiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0device interrupt 16 .......</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	接着开始绑定VIP[root@slave-node ~]# ifconfig em1:0 103.110.98.21 broadcast 103.110.98.63 netmask 255.255.255.192 up [root@slave-node ~]# route add -host 103.110.98.21 dev em1:0\r\n</p>\r\n<p>\r\n	查看VIP是否成功绑定了：[root@slave-node ~]# ifconfigem1: flags=4163<up,broadcast,running,multicast> mtu 1500inet 103.110.98.24 netmask 255.255.255.192 broadcast 103.110.98.63inet6 fe80::46a8:42ff:fe17:3ddd prefixlen 64 scopeid 0x20ether 44:a8:42:17:3d:dd txqueuelen 1000 (Ethernet)RX packets 133789569 bytes 14858744709 (13.8 GiB)RX errors 0 dropped 644 overruns 0 frame 0TX packets 2291620 bytes 426619960 (406.8 MiB)TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0device interrupt 16</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	em1:0: flags=4163<up,broadcast,running,multicast> mtu 1500inet 103.110.98.21 netmask 255.255.255.192 broadcast 103.110.98.63ether 44:a8:42:17:3d:dd txqueuelen 1000 (Ethernet)device interrupt 16 .......</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# ping 103.110.98.20PING 103.110.98.21 (103.110.98.20) 56(84) bytes of data.64 bytes from 103.110.98.20: icmp_seq=1 ttl=64 time=0.044 ms64 bytes from 103.110.98.20: icmp_seq=2 ttl=64 time=0.036 ms\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 103.10.86.1 0.0.0.0 UG 100 0 0 em1103.10.86.0 0.0.0.0 255.255.255.192 U 100 0 0 em1103.110.98.21 0.0.0.0 255.255.255.255 UH 0 0 0 em1192.168.1.0 0.0.0.0 255.255.255.0 U 100 0 0 em2\r\n</p>\r\n<p>\r\n	使用ip addr命令查看，确保master和slave上都已成功绑定了vip[root@master-node ~]# ip addr.........2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000    link/ether 44:a8:42:17:3d:dd brd ff:ff:ff:ff:ff:ff    inet 103.110.98.14/26 brd 103.110.98.63 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.20/26 brd 103.10.86.63 scope global secondary em1:0       valid_lft forever preferred_lft forever    inet6 fe80::46a8:42ff:fe17:3ddd/64 scope link        valid_lft forever preferred_lft forever</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# ip addr.........2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000    link/ether 44:a8:42:17:3d:dd brd ff:ff:ff:ff:ff:ff    inet 103.110.98.24/26 brd 103.110.98.63 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.21/26 brd 103.10.86.63 scope global secondary em1:0       valid_lft forever preferred_lft forever    inet6 fe80::46a8:42ff:fe17:3ddd/64 scope link        valid_lft forever preferred_lft forever</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	（2）修改keepalived的配置\r\n</p>\r\n<p>\r\n	1）master负载机上的keepalived配置：（注意，这里是双主配置，MASTER-BACKUP和BACKUP-MASTER;如果是多主，比如三主，就是MATER-BACKUP-BACKUP、BACKUP-MASTER-BACKUP和BACKUP-BACKUP-MASTER）注意：配置中的虚拟路由标识virtual_router_id在MASTER和BACKUP处配置不能一样（但在主从模式下配置是一样的）\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id master-node\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_http_port {\r\n</p>\r\n<p>\r\n	script \"/opt/chk_nginx.sh\"\r\n</p>\r\n<p>\r\n	interval 2\r\n</p>\r\n<p>\r\n	weight -5\r\n</p>\r\n<p>\r\n	fall 2\r\n</p>\r\n<p>\r\n	rise 1\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state MASTER\r\n</p>\r\n<p>\r\n	interface em1\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.14\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 101\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_http_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	103.110.98.20\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notify_master \"/etc/keepalived/clean_arp.sh 103.110.98.20\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_2 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface em1\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.24\r\n</p>\r\n<p>\r\n	virtual_router_id 52\r\n</p>\r\n<p>\r\n	priority 99\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_http_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	103.110.98.21\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notify_master \"/etc/keepalived/clean_arp.sh 103.10.86.21\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /etc/keepalived/clean_arp.sh &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//更新vip的arp记录到网关（注意脚本中的网卡别填错了，要跟vip所在网卡一致）#!/bin/shVIP=$1GATEWAY=103.110.98.1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//负载均衡器的公网网关地址/sbin/arping -I em1 -c 5 -s $VIP $GATEWAY &amp;&gt;/dev/null[root@master-node ~]# chmod 755 /etc/keepalived/clean_arp.sh\r\n</p>\r\n<p>\r\n	2）slave负载机上的keepalived配置：\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id slave-node\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_http_port {\r\n</p>\r\n<p>\r\n	script \"/opt/chk_nginx.sh\"\r\n</p>\r\n<p>\r\n	interval 2\r\n</p>\r\n<p>\r\n	weight -5\r\n</p>\r\n<p>\r\n	fall 2\r\n</p>\r\n<p>\r\n	rise 1\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface em1\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.14\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 99\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_http_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	103.110.98.20\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notify_master \"/etc/keepalived/clean_arp.sh 103.110.98.20\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_2 {\r\n</p>\r\n<p>\r\n	state MASTER\r\n</p>\r\n<p>\r\n	interface em1\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.24\r\n</p>\r\n<p>\r\n	virtual_router_id 52\r\n</p>\r\n<p>\r\n	priority 101\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_http_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	103.110.98.21\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notify_master \"/etc/keepalived/clean_arp.sh 21\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# vim /etc/keepalived/clean_arp.sh #!/bin/shVIP=$1GATEWAY=103.110.98.1                                                  /sbin/arping -I em1 -c 5 -s $VIP $GATEWAY &amp;&gt;/dev/null[root@slave-node ~]# chmod 755 /etc/keepalived/clean_arp.sh\r\n</p>\r\n<p>\r\n	重启master和slave负载机的keepalive（保证两台机器的ngixn和keepalived服务都启动）[root@master-node ~]# /etc/init.d/keepalived restart[root@slave-node ~]# /etc/init.d/keepalived restart\r\n</p>\r\n<p>\r\n	将nginx中配置的域名解析到这两个VIP地址上：103.110.98.20 dev.wangshibo.com103.110.98.21 dev.wangshibo.com\r\n</p>\r\n<p>\r\n	浏览器访问是正常的（如果master或slave有一台宕机，或其中一个VIP故障，只要另一台是正常的就行）\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	关闭两台负载机其中一台的keepalived服务，那么它的VIP就会自动漂移到另一台机器上。关闭两台机器的nginx，会自动重启（前提是keepalived服务要启动）！对网站域名的访问丝毫不受影响。\r\n</p>\r\n<p>\r\n	[root@master-node ~]# pkill -9 nginxroot 32365 9775 0 19:04 pts/0 00:00:00 grep --color=auto nginx[root@master-node ~]# ps -ef|grep nginxroot 32367 9775 0 19:04 pts/0 00:00:00 grep --color=auto nginx[root@master-node ~]# ps -ef|grep nginxroot 32369 32368 0 19:04 ? 00:00:00 /bin/bash /opt/chk_nginx.shroot 32374 1 0 19:04 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxwww 32376 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32377 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32378 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32379 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32380 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32381 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32382 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32383 32374 1 19:04 ? 00:00:00 nginx: worker processwww 32384 32374 0 19:04 ? 00:00:00 nginx: cache manager processwww 32385 32374 0 19:04 ? 00:00:00 nginx: cache loader processroot 32387 9775 0 19:04 pts/0 00:00:00 grep --color=auto nginx\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('7ff63c80-255f-4093-91c7-592b4b01eb5d','nginx下目录浏览及其验证功能、版本隐藏等配置记录','nginx下目录浏览及其验证功能、版本隐藏等配置记录','<p>\r\n	工作中常常有写不能有网页下载东西的需求，在Apache下搭建完成后直接导入文件即可达到下载/显示文件的效果;而Nginx的目录列表功能默认是关闭的，如果需要打开Nginx的目录列表功能,需要手动配置，还可以进行访问验证；nginx目录列表功能需要用到下面这个模块：ngx_http_autoindex_module　　此模块用于自动生成目录列表，只在 ngx_http_index_module模块未找到索引文件时发出请求.\r\n</p>\r\n<p>\r\n	下面就对nginx的目录浏览及验证访问功能的操作进行梳理：\r\n</p>\r\n<p>\r\n	1）设置目录浏览打开nginx的配置文件，如：\r\n</p>\r\n<p>\r\n	[root@wangshibo ~]# vim /usr/local/nginx/conf/vhost/test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;            //访问http://ip,发现访问的站点目录还是默认的；可以将此处的localhost直接改成服务器ip地址\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	autoindex on;\r\n</p>\r\n<p>\r\n	autoindex_exact_size off;\r\n</p>\r\n<p>\r\n	autoindex_localtime on;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /images {\r\n</p>\r\n<p>\r\n	root   /var/www/html/shibo;\r\n</p>\r\n<p>\r\n	autoindex on;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /bo   {\r\n</p>\r\n<p>\r\n	autoindex  on;                        #自动显示目录\r\n</p>\r\n<p>\r\n	autoindex_exact_size  off;            #改为off后，显示出文件的大概大小，单位是kB或者MB或者GB；即人性化方式显示文件大小否则以byte显示\r\n</p>\r\n<p>\r\n	autoindex_localtime on;               #显示的文件时间为文件的服务器时间；即按服务器时间显示\r\n</p>\r\n<p>\r\n	limit_rate_after 10m;                 #10m之后下载速度为10k\r\n</p>\r\n<p>\r\n	limit_rate 10k;\r\n</p>\r\n<p>\r\n	alias /opt/html/redhat;   #虚拟目录\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	查看下站点根目录下的文件：[root@wangshibo ~]# ls /var/www/html/aa  hehe  shibo  test.html重启nginx服务[root@wangshibo ~]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	然后就可以访问了：\r\n</p>\r\n<p>\r\n	如上的设置，要想设置nginx的目录浏览功能，必须要打开下面这个参数autoindex on;\r\n</p>\r\n<p>\r\n	此外，另外两个参数最好也加上去:autoindex_exact_size off;默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB\r\n</p>\r\n<p>\r\n	autoindex_localtime on;默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为文件的服务器时间\r\n</p>\r\n<p>\r\n	2）设置访问验证创建类htpasswd文件（如果没有htpasswd命令，可通过\"yum install -y *htpasswd*\"或\"yum install -y httpd\"）[root@wangshibo ~]# htpasswd -c /usr/local/nginx/conf/auth_password wangshibo        //会被要求输入两次密码[root@wangshibo ~]# cat /usr/local/nginx/conf/auth_passwordwangshibo:$awe1$I2FIVtPG$I51oSU4eatH.tJdnmxtg67\r\n</p>\r\n<p>\r\n	Nginx配置中添加auth认证配置[root@wangshibo ~]# vim /usr/local/nginx/conf/vhost/test.conf......location ^~ /soft/ {&nbsp; &nbsp; &nbsp;root /var/www/html; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//此处为soft的上一级目录。注意root和alias虚拟目录设置区别&nbsp; &nbsp; &nbsp;autoindex on;&nbsp; &nbsp; &nbsp;autoindex_exact_size off;&nbsp; &nbsp; &nbsp;autoindex_localtime on;&nbsp; &nbsp; &nbsp;auth_basic \"MyPath Authorized\"; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//为提示信息，可以自行修改；会出现在第一次访问Nginx站点的弹出框内&nbsp; &nbsp; &nbsp;auth_basic_user_file /usr/local/nginx/conf/auth_password; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//最好跟htpasswd文件的全路径}\r\n</p>\r\n<p>\r\n	重启nginx服务[root@wangshibo ~]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	这时候访问站点的soft目录时就会被要求输入用户名和密码：\r\n</p>\r\n<p>\r\n	如果用户名和密码输入错误会提示401错误（大名鼎鼎的http基本认证）\r\n</p>\r\n<p>\r\n	需要特别注意的是：加上认证之后该目录下的php文件将不会被解析，会运行下载。如果要使其能够解析php可以，可将上面的配置改为：\r\n</p>\r\n<p>\r\n	location ^~ /soft/ {\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {                           //或者是location ~ .*\\.(php|php5)?$ {\r\n</p>\r\n<p>\r\n	root   /var/www/html;\r\n</p>\r\n<p>\r\n	fastcgi_pass   127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 300;\r\n</p>\r\n<p>\r\n	fastcgi_index  index.php;\r\n</p>\r\n<p>\r\n	fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;;\r\n</p>\r\n<p>\r\n	include        fastcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	auth_basic \"Authorized users only\";\r\n</p>\r\n<p>\r\n	auth_basic_user_file /usr/local/nginx/conf/auth_password;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	nginx运行目录浏览后，就可以利用wget进行文件远程传输了（只针对文件，因为在http下只能文件访问，直接跟url访问目录是404）：比如：[root@wangshibo ~]# cat /var/www/html/aa/hahathis is test file\r\n</p>\r\n<p>\r\n	在浏览器里直接点击站点下的文件（比如上面的haha文件）就会下载下来了（点击文件，除了html格式的文件能直接读出来，其他文件都是直接下载）。也可以在linux终端命令行里使用wget进行文件传输，比如在远程机器上下载上面站点的haha文件：[root@bastion-IDC ~]# wget http://113.110.186.117/aa/haha -P /tmp/testmd--2017-01-03 15:14:18--  http://113.110.186.117/aa/hahaConnecting to 113.110.186.117... connected.HTTP request sent, awaiting response... 200 OKLength: 18 [application/octet-stream]Saving to: “/tmp/testmd/haha”\r\n</p>\r\n<p>\r\n	100%[=====================================================================================================&gt;] 18          --.-K/s   in 0s\r\n</p>\r\n<p>\r\n	2017-01-03 15:14:18 (2.60 MB/s) - “/tmp/testmd/haha” saved [18/18]\r\n</p>\r\n<p>\r\n	查看，发现已经传过来了[root@bastion-IDC ~]# ls /tmp/testmd/haha[root@bastion-IDC ~]# cat /tmp/testmd/hahathis is test file\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------版本隐藏设置-------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	1）在nginx下禁止使用ip访问，将使用ip访问的流量重定向到公司的官网上。\r\n</p>\r\n<p>\r\n	在vhost下重新编辑一个default.conf 文件，如下：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80 default_server;\r\n</p>\r\n<p>\r\n	#    server_name _;\r\n</p>\r\n<p>\r\n	#    return 500;\r\n</p>\r\n<p>\r\n	rewrite ^(.*) https://www.wangshibo.com permanent;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	然后重启nginx即可！\r\n</p>\r\n<p>\r\n	----------------------------------\r\n</p>\r\n<p>\r\n	下面就是直接紧张ip访问了\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80 default_server;\r\n</p>\r\n<p>\r\n	server_name _;\r\n</p>\r\n<p>\r\n	return 500;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	----------------------------------\r\n</p>\r\n<p>\r\n	2）隐藏nginx的版本号\r\n</p>\r\n<p>\r\n	直接在nginx.conf文件中的http{}里面添加：\r\n</p>\r\n<p>\r\n	server_tokens off;\r\n</p>\r\n<p>\r\n	重启nginx服务即可！\r\n</p>\r\n<p>\r\n	curl -i http://www.wangshibo.com    测试访问就会发现nginx的header信息中已没有版本信息了（-i参数）\r\n</p>\r\n<p>\r\n	3）隐藏tomcat的版本号\r\n</p>\r\n<p>\r\n	# /data/tomcat8/bin/version.sh        #查看版本号信息\r\n</p>\r\n<p>\r\n	Using CATALINA_BASE:   /data/tomcat8\r\n</p>\r\n<p>\r\n	Using CATALINA_HOME:   /data/tomcat8\r\n</p>\r\n<p>\r\n	Using CATALINA_TMPDIR: /data/tomcat8/temp\r\n</p>\r\n<p>\r\n	Using JRE_HOME:        /usr/lib/jvm/java-1.7.0-openjdk.x86_64\r\n</p>\r\n<p>\r\n	Using CLASSPATH:       /data/tomcat8/bin/bootstrap.jar:/data/tomcat8/bin/tomcat-juli.jar\r\n</p>\r\n<p>\r\n	Server version: Apache Tomcat/8.5.15\r\n</p>\r\n<p>\r\n	Server built:   May 5 2017 11:03:04 UTC\r\n</p>\r\n<p>\r\n	Server number:  8.5.15.0\r\n</p>\r\n<p>\r\n	OS Name:        Linux\r\n</p>\r\n<p>\r\n	OS Version:     2.6.32-696.3.2.el6.x86_64\r\n</p>\r\n<p>\r\n	Architecture:   amd64\r\n</p>\r\n<p>\r\n	JVM Version:    1.7.0_141-mockbuild_2017_05_09_14_20-b00\r\n</p>\r\n<p>\r\n	JVM Vendor:     Oracle Corporation\r\n</p>\r\n<p>\r\n	# cp -r /data/tomcat8 /data/tomcat8.bak\r\n</p>\r\n<p>\r\n	# cd /data/tomcat8/lib\r\n</p>\r\n<p>\r\n	# jar xf catalina.jar\r\n</p>\r\n<p>\r\n	# vim org/apache/catalina/util/ServerInfo.properties\r\n</p>\r\n<p>\r\n	server.info=Apache Tomcat        //修改成这样\r\n</p>\r\n<p>\r\n	server.number=                 //清空\r\n</p>\r\n<p>\r\n	server.built=                  //清空\r\n</p>\r\n<p>\r\n	# jar cf catalina.jar org     //再次打包覆盖\r\n</p>\r\n<p>\r\n	# ll catalina.jar\r\n</p>\r\n<p>\r\n	# /data/tomcat8/bin/version.sh        //发现tomcat的版本信息已被隐藏\r\n</p>\r\n<p>\r\n	Using CATALINA_BASE:   /data/tomcat8\r\n</p>\r\n<p>\r\n	Using CATALINA_HOME:   /data/tomcat8\r\n</p>\r\n<p>\r\n	Using CATALINA_TMPDIR: /data/tomcat8/temp\r\n</p>\r\n<p>\r\n	Using JRE_HOME:        /usr/lib/jvm/java-1.7.0-openjdk.x86_64\r\n</p>\r\n<p>\r\n	Using CLASSPATH:       /data/tomcat8/bin/bootstrap.jar:/data/tomcat8/bin/tomcat-juli.jar\r\n</p>\r\n<p>\r\n	Server version: Apache Tomcat\r\n</p>\r\n<p>\r\n	Server built:\r\n</p>\r\n<p>\r\n	Server number:\r\n</p>\r\n<p>\r\n	OS Name:        Linux\r\n</p>\r\n<p>\r\n	OS Version:     2.6.32-696.3.2.el6.x86_64\r\n</p>\r\n<p>\r\n	Architecture:   amd64\r\n</p>\r\n<p>\r\n	JVM Version:    1.7.0_141-mockbuild_2017_05_09_14_20-b00\r\n</p>\r\n<p>\r\n	JVM Vendor:     Oracle Corporation\r\n</p>\r\n<p>\r\n	4）nginx-status开启状态查看功能及参数说明\r\n</p>\r\n<p>\r\n	本模块在编译的时候默认是不编译的，如果是从源码编译安装的nginx，那么需要在./configure编译的时候加上对应的模块--with-http_stub_status_module\r\n</p>\r\n<p>\r\n	使用 ./configure --help 能看到更多的模块支持，然后编译安装即可。\r\n</p>\r\n<p>\r\n	[root@www vhosts]# /usr/local/nginx/sbin/nginx -V      //使用这个命令可以查看在编译安装的时候使用了哪些模块\r\n</p>\r\n<p>\r\n	nginx version: nginx/1.8.1\r\n</p>\r\n<p>\r\n	built by gcc 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC)\r\n</p>\r\n<p>\r\n	built with OpenSSL 1.0.1g 7 Apr 2014 (running with OpenSSL 1.0.1e-fips 11 Feb 2013)\r\n</p>\r\n<p>\r\n	TLS SNI support enabled\r\n</p>\r\n<p>\r\n	configure arguments: --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre\r\n</p>\r\n<p>\r\n	接下来需要在nginx的配置文件中增加这个配置项。打开nginx的配置文件 nginx.conf，在server段里面增加如下的内容：\r\n</p>\r\n<p>\r\n	location /nginx-status {\r\n</p>\r\n<p>\r\n	stub_status on;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	#allow 127.0.0.1;\r\n</p>\r\n<p>\r\n	#deny all;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	重启nginx服务后，访问：\r\n</p>\r\n<p>\r\n	# curl http://127.0.0.1/nginx-status\r\n</p>\r\n<p>\r\n	Active connections: 11921\r\n</p>\r\n<p>\r\n	server accepts handled requests\r\n</p>\r\n<p>\r\n	113    113     116\r\n</p>\r\n<p>\r\n	Reading: 0 Writing: 7 Waiting: 42\r\n</p>\r\n<p>\r\n	active connections – 活跃的连接数量\r\n</p>\r\n<p>\r\n	server accepts handled requests — 总共处理了113个连接 , 成功创建113次握手, 总共处理了116个请求\r\n</p>\r\n<p>\r\n	reading — 读取客户端的连接数.\r\n</p>\r\n<p>\r\n	writing — 响应数据到客户端的数量\r\n</p>\r\n<p>\r\n	waiting — 开启 keep-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('7ffc0961-7e84-4994-b110-bfc75a020e93','Mysql主从同步(1)-主从/主主环境部署梳理','Mysql主从同步(1)-主从/主主环境部署梳理','<p>\r\n	Mysql复制概念说明Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。\r\n</p>\r\n<p>\r\n	需要注意的是：在进行mysql复制时，所有对复制中的表的更新必须在主服务器上进行。否则必须要小心，以避免用户对主服务器上的表进行的更新与对从服务器上的表所进行的更新之间的冲突。\r\n</p>\r\n<p>\r\n	1）Mysql支持那些复制&nbsp; &nbsp; 1--基于语句的复制：  在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。    &nbsp; &nbsp; 2--基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持&nbsp; &nbsp; 3--混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。\r\n</p>\r\n<p>\r\n	2）Mysql复制能解决的问题&nbsp; &nbsp; 1--数据分布 (Data distribution )&nbsp; &nbsp; 2--负载平衡(load balancing)&nbsp; &nbsp; 3--数据备份(Backups) ，保证数据安全&nbsp; &nbsp; 4--高可用性和容错行(High availability and failover)&nbsp; &nbsp; 5--实现读写分离，缓解数据库压力\r\n</p>\r\n<p>\r\n	3）Mysql主从复制原理&nbsp; &nbsp; &nbsp;master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。注意几点：&nbsp; &nbsp; &nbsp;1--master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。&nbsp; &nbsp; &nbsp;2--slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。&nbsp; &nbsp; &nbsp;3--Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。&nbsp; &nbsp; &nbsp;4--Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）&nbsp; &nbsp; &nbsp;5--master和slave两节点间时间需同步\r\n</p>\r\n<p>\r\n	Mysql复制的流程图如下：\r\n</p>\r\n<p>\r\n	如上图所示：&nbsp; &nbsp; &nbsp;Mysql复制过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。&nbsp; &nbsp;&nbsp;第二部分就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。&nbsp; &nbsp;&nbsp;SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。&nbsp; &nbsp;此外，在master中也有一个工作线程：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。\r\n</p>\r\n<p>\r\n	4）Mysql复制的模式&nbsp; &nbsp; 1--主从复制：主库授权从库远程连接，读取binlog日志并更新到本地数据库的过程；主库写数据后，从库会自动同步过来（从库跟着主库变）；&nbsp; &nbsp; 2--主主复制：主从相互授权连接，读取对方binlog日志并更新到本地数据库的过程；只要对方数据改变，自己就跟着改变；\r\n</p>\r\n<p>\r\n	5）Mysql主从复制的优点&nbsp; &nbsp; 1--在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）&nbsp; &nbsp; 2--在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）&nbsp; &nbsp; 3--当主服务器出现问题时，可以切换到从服务器。（提升性能）\r\n</p>\r\n<p>\r\n	6）Mysql主从复制工作流程细节&nbsp; &nbsp; 1）MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。MySQL复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器上已经记录到其二进制日志的保存的更新。当一个从服务器连接主服务器时，它通知主服务器定位到从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。&nbsp; &nbsp; 2）MySQL使用3个线程来执行复制功能，其中两个线程(Sql线程和IO线程)在从服务器，另外一个线程(IO线程)在主服务器。当发出START SLAVE时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以即为主服务器上SHOW PROCESSLIST的输出中的Binlog Dump线程。从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。第3个线程是SQL线程，由从服务器创建，用于读取中继日志并执行日志中包含的更新。在从服务器上，读取和执行更新语句被分成两个独立的任务。当从服务器启动时，其I/O线程可以很快地从主服务器索取所有二进制日志内容，即使SQL线程执行更新的远远滞后。\r\n</p>\r\n<p>\r\n	7）几点总结\r\n</p>\r\n<p>\r\n	主从数据完成同步的过程：\r\n</p>\r\n<p>\r\n	1）在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。\r\n</p>\r\n<p>\r\n	2）此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从\r\n</p>\r\n<p>\r\n	复制服务时执行change master命令指定的）之后开始发送binlog日志内容\r\n</p>\r\n<p>\r\n	3）Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog\r\n</p>\r\n<p>\r\n	日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。\r\n</p>\r\n<p>\r\n	4）当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件\r\n</p>\r\n<p>\r\n	（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog\r\n</p>\r\n<p>\r\n	日志的指定文件及位置开始读取新的binlog日志内容\r\n</p>\r\n<p>\r\n	5）Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句\r\n</p>\r\n<p>\r\n	的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点\r\n</p>\r\n<p>\r\n	主从复制条件\r\n</p>\r\n<p>\r\n	1）开启Binlog功能\r\n</p>\r\n<p>\r\n	2）主库要建立账号\r\n</p>\r\n<p>\r\n	3）从库要配置master.info（CHANGE MASTER to...相当于配置密码文件和Master的相关信息）\r\n</p>\r\n<p>\r\n	4）start slave 开启复制功能\r\n</p>\r\n<p>\r\n	需要了解的：\r\n</p>\r\n<p>\r\n	1）3个线程，主库IO，从库IO和SQL及作用\r\n</p>\r\n<p>\r\n	2）master.info（从库）作用\r\n</p>\r\n<p>\r\n	3）relay-log 作用\r\n</p>\r\n<p>\r\n	4）异步复制\r\n</p>\r\n<p>\r\n	5）binlog作用（如果需要级联需要开启Binlog）\r\n</p>\r\n<p>\r\n	需要注意：\r\n</p>\r\n<p>\r\n	1）主从复制是异步的逻辑的SQL语句级的复制\r\n</p>\r\n<p>\r\n	2）复制时，主库有一个I/O线程，从库有两个线程，I/O和SQL线程\r\n</p>\r\n<p>\r\n	3）实现主从复制的必要条件是主库要开启记录binlog功能\r\n</p>\r\n<p>\r\n	4）作为复制的所有Mysql节点的server-id都不能相同\r\n</p>\r\n<p>\r\n	5）binlog文件只记录对数据库有更改的SQL语句（来自主库内容的变更），不记录任何查询（select，show）语句\r\n</p>\r\n<p>\r\n	...................................................................................................\r\n</p>\r\n<p>\r\n	彻底解除主从复制关系\r\n</p>\r\n<p>\r\n	1)stop slave;\r\n</p>\r\n<p>\r\n	2)reset slave; 或直接删除master.info和relay-log.info这两个文件；\r\n</p>\r\n<p>\r\n	3)修改my.cnf删除主从相关配置参数。\r\n</p>\r\n<p>\r\n	让slave不随MySQL自动启动\r\n</p>\r\n<p>\r\n	修改my.cnf 在[mysqld]中增加 skip-slave-start 选项。\r\n</p>\r\n<p>\r\n	做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：\r\n</p>\r\n<p>\r\n	mysqldump --master-data --single-transaction --user=username --password=password dbname&gt; dumpfilename\r\n</p>\r\n<p>\r\n	这样就可以保留 file 和 position 的信息，在新搭建一个slave的时候，还原完数据库， file 和 position 的信息也随之更新，接着再start slave 就可以很迅速\r\n</p>\r\n<p>\r\n	的完成增量同步！\r\n</p>\r\n<p>\r\n	需要限定同步哪些数据库，有3个思路：\r\n</p>\r\n<p>\r\n	1）在执行grant授权的时候就限定数据库；\r\n</p>\r\n<p>\r\n	2）在主服务器上限定binlog_do_db = 数据库名；\r\n</p>\r\n<p>\r\n	3）主服务器上不限定数据库，在从服务器上限定replicate-do-db = 数据库名；\r\n</p>\r\n<p>\r\n	如果想实现 主-从（主）-从 这样的链条式结构，需要设置：\r\n</p>\r\n<p>\r\n	log-slave-updates      只有加上它，从前一台机器上同步过来的数据才能同步到下一台机器。\r\n</p>\r\n<p>\r\n	当然，二进制日志也是必须开启的：\r\n</p>\r\n<p>\r\n	log-bin=/opt/mysql/binlogs/bin-log\r\n</p>\r\n<p>\r\n	log-bin-index=/opt/mysql/binlogs/bin-log.index\r\n</p>\r\n<p>\r\n	还可以设置一个log保存周期：\r\n</p>\r\n<p>\r\n	expire_logs_days=14\r\n</p>\r\n<p>\r\n	--------------------------下面记录下mysql主从／主主同步环境的实施过程-------------------------1）环境描述\r\n</p>\r\n<p>\r\n	mysql的安装可以参考：http://www.cnblogs.com/kevingrace/p/6109679.html\r\n</p>\r\n<p>\r\n	Centos6.8版本\r\n</p>\r\n<p>\r\n	master：182.148.15.238\r\n</p>\r\n<p>\r\n	slave: 182.148.15.237\r\n</p>\r\n<p>\r\n	注意下面几点：\r\n</p>\r\n<p>\r\n	1）要保证同步服务期间之间的网络联通。即能相互ping通，能使用对方授权信息连接到对方数据库（防火墙开放3306端口）。\r\n</p>\r\n<p>\r\n	2）关闭selinux。\r\n</p>\r\n<p>\r\n	3）同步前，双方数据库中需要同步的数据要保持一致。这样，同步环境实现后，再次更新的数据就会如期同步了。\r\n</p>\r\n<p>\r\n	2）主从复制实现过程记录\r\n</p>\r\n<p>\r\n	为了测试效果，先在master机器上创建测试库\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE DATABASE huanqiu CHARACTER SET utf8 COLLATE utf8_general_ci;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table if not exists haha (id int(10) PRIMARY KEY AUTO_INCREMENT,name varchar(50) NOT NULL);\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiu.haha values(1,\"wangshibo\"),(2,\"guohuihui\");\r\n</p>\r\n<p>\r\n	Query OK, 2 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	Records: 2  Duplicates: 0  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	温馨提示：\r\n</p>\r\n<p>\r\n	修改库或表的字符集\r\n</p>\r\n<p>\r\n	mysql&gt; alter database huanqiu default character set utf8;    //修改huanqiu库的字符集\r\n</p>\r\n<p>\r\n	mysql&gt; alter table huanqiu.haha default character set utf8;  //修改huanqiu.haha表的字符集\r\n</p>\r\n<p>\r\n	添加主键\r\n</p>\r\n<p>\r\n	mysql&gt; Alter table huanqiu.haha add primary key(id);     //将huanqiu.haha表的id添加主键\r\n</p>\r\n<p>\r\n	mysql&gt; Alter table huanqiu.haha change id id int(10) not null auto_increment;  //自增长属性\r\n</p>\r\n<p>\r\n	删除主键时要先删除自增长，再删除主键\r\n</p>\r\n<p>\r\n	mysql&gt; Alter table huanqiu.haha change id id int(10);    //删除自增长\r\n</p>\r\n<p>\r\n	mysql&gt; Alter table huanqiu.haha drop primary key;     //删除主建\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	下面是master数据库上的操作：\r\n</p>\r\n<p>\r\n	1）设置master数据库的my.cnf文件（在[mysqld]配置区域添加下面内容）\r\n</p>\r\n<p>\r\n	[root@master ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	server-id=1        #数据库唯一ID，主从的标识号绝对不能重复。\r\n</p>\r\n<p>\r\n	log-bin=mysql-bin    #开启bin-log，并指定文件目录和文件名前缀\r\n</p>\r\n<p>\r\n	binlog-do-db=huanqiu  #需要同步的数据库。如果是多个同步库，就以此格式另写几行即可。如果不指明对某个具体库同步，就去掉此行，表示同步所有库（除了ignore忽略的库）。\r\n</p>\r\n<p>\r\n	binlog-ignore-db=mysql  #不同步mysql系统数据库。如果是多个不同步库，就以此格式另写几行；也可以在一行，中间逗号隔开。\r\n</p>\r\n<p>\r\n	sync_binlog = 1      ＃确保binlog日志写入后与硬盘同步\r\n</p>\r\n<p>\r\n	binlog_checksum = none  ＃跳过现有的采用checksum的事件，mysql5.6.5以后的版本中binlog_checksum=crc32,而低版本都是binlog_checksum=none\r\n</p>\r\n<p>\r\n	binlog_format = mixed   ＃bin-log日志文件格式，设置为MIXED可以防止主键重复。\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	温馨提示：在主服务器上最重要的二进制日志设置是sync_binlog，这使得mysql在每次提交事务的时候把二进制日志的内容同步到磁盘上，即使服务器崩溃也会把事件写入日志中。\r\n</p>\r\n<p>\r\n	sync_binlog这个参数是对于MySQL系统来说是至关重要的，他不仅影响到Binlog对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。对于\"sync_binlog\"参数的各种设置的说明如下：\r\n</p>\r\n<p>\r\n	sync_binlog=0，当事务提交之后，MySQL不做fsync之类的磁盘同步指令刷新binlog_cache中的信息到磁盘，而让Filesystem自行决定什么时候来做同步，或者cache满了之后才同步到磁盘。\r\n</p>\r\n<p>\r\n	sync_binlog=n，当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将binlog_cache中的数据强制写入磁盘。\r\n</p>\r\n<p>\r\n	在MySQL中系统默认的设置是sync_binlog=0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使系统Crash，也最多丢失binlog_cache中未完成的一个事务，对实际数据没有任何实质性影响。\r\n</p>\r\n<p>\r\n	从以往经验和相关测试来看，对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）导出master数据库多余slave数据库中的数据，然后导入到slave数据库中。保证双方在同步环境实现前的数据一致。\r\n</p>\r\n<p>\r\n	导出数据库之前先锁定数据库\r\n</p>\r\n<p>\r\n	mysql&gt; flush tables with read lock;    #数据库只读锁定命令，防止导出数据库的时候有数据写入。unlock tables命令解除锁定\r\n</p>\r\n<p>\r\n	导出master数据库中多余的huanqiu库(master数据库的root用户登陆密码：123456)\r\n</p>\r\n<p>\r\n	[root@master ~]# mysqldump -uroot huanqiu -p123456 &gt;/opt/huanqiu.sql\r\n</p>\r\n<p>\r\n	[root@master ~]# rsync  -e \"ssh -p22\" -avpgolr /opt/huanqiu.sql 182.148.15.237:/opt/   ＃将导出的sql文件上传到slave机器上\r\n</p>\r\n<p>\r\n	3）设置数据同步权限\r\n</p>\r\n<p>\r\n	mysql&gt; grant replication slave,replication client on *.* to slave@\'182.148.15.237\' identified by \"slave@123\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	温馨提示：\r\n</p>\r\n<p>\r\n	权限查看方式\r\n</p>\r\n<p>\r\n	mysql&gt; show grants;\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for slave@\'182.148.1115.237\';\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	4）查看主服务器master状态(注意File与Position项，从服务器需要这两项参数)\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| mysql-bin.000007 |      120 | huanqiu      | mysql            |                   |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	下面是slave数据库上的操作：\r\n</p>\r\n<p>\r\n	1）设置slave数据库的my.cnf配置文件\r\n</p>\r\n<p>\r\n	[root@master ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	server-id=2   #设置从服务器id，必须于主服务器不同\r\n</p>\r\n<p>\r\n	log-bin=mysql-bin   #启动MySQ二进制日志系统\r\n</p>\r\n<p>\r\n	replicate-do-db=huanqiu  #需要同步的数据库名。如果不指明同步哪些库，就去掉这行，表示所有库的同步（除了ignore忽略的库）。\r\n</p>\r\n<p>\r\n	replicate-ignore-db=mysql  #不同步mysql系统数据库\r\n</p>\r\n<p>\r\n	slave-skip-errors = all   #跳过所有的错误错误，继续执行复制操作\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	温馨提示：\r\n</p>\r\n<p>\r\n	当只针对某些库的某张表进行同步时，如下，只同步huanqiu库的haha表和huanpc库的heihei表：\r\n</p>\r\n<p>\r\n	replicate-do-db = huanqiu\r\n</p>\r\n<p>\r\n	replicate-wild-do-table = huanqiu.haha       //当只同步几个或少数表时，可以这样设置。注意这要跟上面的库指定配合使用；\r\n</p>\r\n<p>\r\n	replicate-do-db = huanpc\r\n</p>\r\n<p>\r\n	replicate-wild-do-table = huanpc.heihei      //如果同步的库的表比较多时，就不能这样一一指定了，就把这个选项配置去掉，直接根据指定的库进行同步。\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）在slave数据库中导入从master传过来的数据。\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE DATABASE huanqiu CHARACTER SET utf8 COLLATE utf8_general_ci;   #先创建一个huanqiu空库，否则下面导入数据时会报错说此库不存在。\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	mysql&gt; source /opt/huanqiu.sql;   ＃导入master中多余的数据。\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	3）配置主从同步指令\r\n</p>\r\n<p>\r\n	mysql&gt; stop slave;   ＃执行同步前，要先关闭slave\r\n</p>\r\n<p>\r\n	mysql&gt; change  master to master_host=\'182.148.15.238\',master_user=\'slave\',master_password=\'slave@123\',master_log_file=\'mysql-bin.000007\',master_log_pos=120;\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 182.148.15.238\r\n</p>\r\n<p>\r\n	Master_User: slave\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000007\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 120\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000002\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 279\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000007\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	Replicate_Do_DB: huanqiu\r\n</p>\r\n<p>\r\n	Replicate_Ignore_DB: mysql\r\n</p>\r\n<p>\r\n	.............\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	如上，当IO和SQL线程的状态均为Yes，则表示主从已实现同步了！\r\n</p>\r\n<p>\r\n	查看slave数据库中的数据情况\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiu            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	下面测试下Mysql主从同步的效果\r\n</p>\r\n<p>\r\n	现在主数据库上写入新数据\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;    #解锁，否则新数据无法写入\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiu.haha values(100,\"anhui\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	然后在slave数据库上查看，发现master上新写入的数据已经同步过来了\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	| id  | name      |\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	|   1 | wangshibo |\r\n</p>\r\n<p>\r\n	|   2 | guohuihui |\r\n</p>\r\n<p>\r\n	| 100 | anhui     |\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	至此，主从同步环境已经实现！\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------注意：Mysql主从环境部署一段时间后，发现主从不同步时，如何进行数据同步至一致？有以下两种做法：1）参考：mysql主从同步(2)-问题梳理&nbsp;中的第（4）步的第二种方法2）参考：mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理--------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	3）主主复制实现过程记录\r\n</p>\r\n<p>\r\n	根据上面的主从环境部署，master和slave已经实现同步，即在master上写入新数据，自动同步到slave。而从库只能读不能写，一旦从库有写入数据，就会造成主从数据不一致！\r\n</p>\r\n<p>\r\n	下面就说下Mysql主主复制环境，在slave上更新数据时，master也能自动同步过来。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	温馨提示：\r\n</p>\r\n<p>\r\n	在做主主同步前，提醒下需要特别注意的一个问题：\r\n</p>\r\n<p>\r\n	主主复制和主从复制有一些区别，因为多主中都可以对服务器有写权限，所以设计到自增长重复问题，例如：\r\n</p>\r\n<p>\r\n	出现的问题（多主自增长ID重复）\r\n</p>\r\n<p>\r\n	1）首先在A和B两个库上创建test表结构;\r\n</p>\r\n<p>\r\n	2）停掉A，在B上对数据表test(存在自增长属性的ID字段)执行插入操作，返回插入ID为1;\r\n</p>\r\n<p>\r\n	3）然后停掉B，在A上对数据表test(存在自增长属性的ID字段)执行插入操作，返回的插入ID也是1;\r\n</p>\r\n<p>\r\n	4）然后 同时启动A,B，就会出现主键ID重复\r\n</p>\r\n<p>\r\n	解决方法：\r\n</p>\r\n<p>\r\n	只要保证两台服务器上的数据库里插入的自增长数据不同就可以了\r\n</p>\r\n<p>\r\n	如：A插入奇数ID，B插入偶数ID，当然如果服务器多的话，还可以自定义算法，只要不同就可以了\r\n</p>\r\n<p>\r\n	在下面例子中，在两台主主服务器上加入参数，以实现奇偶插入！\r\n</p>\r\n<p>\r\n	记住:在做主主同步时需要设置自增长的两个相关配置，如下：\r\n</p>\r\n<p>\r\n	auto_increment_offset       表示自增长字段从那个数开始，取值范围是1 .. 65535。这个就是序号。如果有n台mysql机器，则从第一台开始分为设1，2...n\r\n</p>\r\n<p>\r\n	auto_increment_increment    表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535。如果有n台mysql机器，这个值就设置为n。\r\n</p>\r\n<p>\r\n	在主主同步配置时，需要将两台服务器的：\r\n</p>\r\n<p>\r\n	auto_increment_increment     增长量都配置为2\r\n</p>\r\n<p>\r\n	auto_increment_offset        分别配置为1和2。这是序号，第一台从1开始，第二台就是2，以此类推.....\r\n</p>\r\n<p>\r\n	这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。（针对的是有自增长属性的字段）\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	现在记录下主主同步的操作过程：\r\n</p>\r\n<p>\r\n	1）在master上的my.cnf配置：\r\n</p>\r\n<p>\r\n	[root@master ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	server-id = 1\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db = mysql,information_schema\r\n</p>\r\n<p>\r\n	sync_binlog = 1\r\n</p>\r\n<p>\r\n	binlog_checksum = none\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 1\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	[root@master ~]# /etc/init.d/mysql restart\r\n</p>\r\n<p>\r\n	Shutting down MySQL. SUCCESS!\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）\r\n</p>\r\n<p>\r\n	mysql&gt; grant replication slave,replication client on *.* to slave@\'182.148.15.237\' identified by \"slave@123\";\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	最好将库锁住，仅仅允许读，以保证数据一致性；待主主同步环境部署后再解锁；锁住后，就不能往表里写数据，但是重启mysql服务后就会自动解锁！\r\n</p>\r\n<p>\r\n	mysql&gt; FLUSH TABLES WITH READ LOCK;    //注意该参数设置后，如果自己同步对方数据，同步前一定要记得先解锁！\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| mysql-bin.000001 |     1970 |              |                  |                   |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）slave数据库上\r\n</p>\r\n<p>\r\n	[root@slave ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	server-id = 2\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db = mysql,information_schema\r\n</p>\r\n<p>\r\n	sync_binlog = 1\r\n</p>\r\n<p>\r\n	binlog_checksum = none\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 2\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	[root@slave ~]# /etc/init.d/mysql restart\r\n</p>\r\n<p>\r\n	Shutting down MySQL. SUCCESS!\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）\r\n</p>\r\n<p>\r\n	同理，slave也要授权给master机器远程同步数据的权限\r\n</p>\r\n<p>\r\n	mysql&gt; grant replication slave ,replication client on *.* to slave@\'182.148.15.238\' identified by \"slave@123\";\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	mysql&gt; FLUSH TABLES WITH READ LOCK;\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	| mysql-bin.000001 |     4136 |              |                  |                   |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+------------------+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）执行主张同步操作\r\n</p>\r\n<p>\r\n	先在slave数据库上做同步master的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;     //先解锁，将对方数据同步到自己的数据库中\r\n</p>\r\n<p>\r\n	mysql&gt; slave stop；\r\n</p>\r\n<p>\r\n	mysql&gt; change master to master_host=\'182.148.15.238\',master_user=\'slave\',master_password=\'slave@123\',master_log_file=\'master-bin.000001\',master_log_pos=1970;\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 182.148.15.238\r\n</p>\r\n<p>\r\n	Master_User: slave\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 1970\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000003\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 750\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	..................\r\n</p>\r\n<p>\r\n	这样就实现了slave－&gt;master的同步环境。\r\n</p>\r\n<p>\r\n	再在master数据库上做同步slave的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;\r\n</p>\r\n<p>\r\n	mysql&gt; slave stop；\r\n</p>\r\n<p>\r\n	mysql&gt; change master to master_host=\'182.148.15.237\',master_user=\'slave\',master_password=\'slave@123\',master_log_file=\'master-bin.000001\',master_log_pos=4136;\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 182.148.15.237\r\n</p>\r\n<p>\r\n	Master_User: slave\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 4136\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000003\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 750\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000001\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	..................\r\n</p>\r\n<p>\r\n	这样就实现了master－&gt;slave的同步环境。至此，主主双向同步环境已经实现！\r\n</p>\r\n<p>\r\n	4）最后测试下Mysql主主同步的效果\r\n</p>\r\n<p>\r\n	在master上写入新数据\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	| id  | name      |\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	|   1 | wangshibo |\r\n</p>\r\n<p>\r\n	|   2 | guohuihui |\r\n</p>\r\n<p>\r\n	| 100 | anhui     |\r\n</p>\r\n<p>\r\n	+-----+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiu.haha values(15,\"guocongcong\");\r\n</p>\r\n<p>\r\n	在slave数据库中查看，发现master新写入的数据已经同步过来了\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	| id  | name       |\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	|   1 | wangshibo  |\r\n</p>\r\n<p>\r\n	|   2 | guohuihui  |\r\n</p>\r\n<p>\r\n	|  15 | guocongcong|\r\n</p>\r\n<p>\r\n	| 100 | anhui      |\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	在slave上删除数据\r\n</p>\r\n<p>\r\n	mysql&gt; delete from huanqiu.haha where id=100;\r\n</p>\r\n<p>\r\n	在master数据库中查看\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	| id  | name       |\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	|   1 | wangshibo  |\r\n</p>\r\n<p>\r\n	|   2 | guohuihui  |\r\n</p>\r\n<p>\r\n	|  15 | guocongcong|\r\n</p>\r\n<p>\r\n	+-----+------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('80c93bc1-fa9b-45f5-95ec-b708985ad8a6','Nginx中防盗链（下载防盗链和图片防盗链）及图片访问地址操作记录','Nginx中防盗链（下载防盗链和图片防盗链）及图片访问地址操作记录','<p>\r\n	日常运维工作中，设置防盗链的需求会经常碰到，这也是优化网站的一个必要措施。今天在此介绍Nginx中设置下载防盗链和图片防盗链的操作~\r\n</p>\r\n<p>\r\n	一、Nginx中下载防盗链的操作记录对于一些站点上的下载操作，有很多的下载来源不是本站，是迅雷、flashget, 源源不断的带宽,防盗链绝对是当务之急！使用来源判断根本不靠谱，只能防止一些小白站点的盗链，迅雷之类的下载工具完全无效；如果是nginx配置的站点，可以使用secure link来完美解决这个问题，远离迅雷.\r\n</p>\r\n<p>\r\n	以下Nginx的盗链配置，仅用于下载服务器的下载防盗链，不适用于图片防盗链：1）nginx的配置[root@test-huanqiu ~]# cat /usr/local/nginx/conf/vhost/down.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  x1.down.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /data/logs/nginx/x1.down.wangshibo.com.access.log  main;\r\n</p>\r\n<p>\r\n	index index.html index.php index.html;\r\n</p>\r\n<p>\r\n	root /data/site/x1.down.wangshibo.com;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	secure_link $arg_st,$arg_e;\r\n</p>\r\n<p>\r\n	secure_link_md5 wangshibo.com$uri$arg_e;\r\n</p>\r\n<p>\r\n	if ($secure_link = \"\") {\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	if ($secure_link = \"0\") {\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）php下载页面[root@test-huanqiu ~]# cd /data/site/x1.down.wangshibo.com[root@test-huanqiu x1.down.wangshibo.com]# cat down.php<!--?php # 作用：生成nginx secure link链接 # 站点：www.wangshibo.com $secret = \'wangshibo.com\'; # 密钥 $path = \'/web/nginx-1.4.2.tar.gz\'; # 下载文件 # 下载到期时间,time是当前时间,300表示300秒,也就是说从现在到300秒之内文件不过期 $expire = time()+300;# 用文件路径、密钥、过期时间生成加密串 $md5 = base64_encode(md5($secret . $path . $expire, true)); $md5 = strtr($md5, \'+/\', \'-_\'); $md5 = str_replace(\'=\', \'\', $md5);# 加密后的下载地址 echo \'<a href=http://x1.down.wangshibo.com/web/nginx-1.4.2.tar.gz?st=\'.$md5.\'&e=\'.$expire.\'-->nginx-1.4.2\'; echo \'<br />\r\nhttp://x1.down.wangshibo.com/web/nginx-1.4.2.tar.gz?st=\'.$md5.\'&amp;e=\'.$expire; ?&gt;\r\n</p>\r\n<p>\r\n	3）测试nginx防盗链浏览器上打开http://test.wangshibo.com/down.php点击上面的连接下载下载地址如下：http://x1.down.wangshibo.com/web/nginx-1.4.2.tar.gz?st=LSVzmZllg68AJaBmeK3E8Q&amp;e=1378881984页面不要刷新，等到5分钟后在下载一次，你会发现点击下载会跳转到403页面。\r\n</p>\r\n<p>\r\n	4）secure link 防盗链过程1.用户访问down.php2.down.php根据secret密钥、过期时间、文件uri生成加密串3.将加密串与过期时间作为参数跟到文件下载地址的后面4.nginx下载服务器接收到了过期时间，也使用过期时间、配置里密钥、文件uri生成加密串5.将用户传进来的加密串与自己生成的加密串进行对比，一致允许下载，不一致403整个过程实际上很简单，类似于用户密码验证. 尤为注意的一点是一定不要泄露了自己的密钥，否则别人就可以盗链了，除了泄露之外最好能经常更新密钥.\r\n</p>\r\n<p>\r\n	5）secure link 指令1.secure_link语法: secure_link md5_hash[,expiration_time]默认: none配置段: locationvariables: yes这个指令由uri中的MD5哈希值和过期时间组成. md5哈希必须由base64加密的,过期时间为unix时间.如果不加过期时间,那么这个连接永远都不会过期.2.secure_link_md5语法: secure_link_md5 secret_token_concatenated_with_protected_uri默认: none配置段: locationvariables: yesmd5值对比结果,使用上面提供的uri、密钥、过期时间生成md5哈希值.如果它生成的md5哈希值与用户提交过来的哈希值一致，那么这个变量的值为1，否则为03.secure_link_secret语法:     secure_link_secret word默认:配置段:     locationReference:    secure_link_secretnginx 0.8.50之后的版本已经使用secure_link_md5取代,不在多说.\r\n</p>\r\n<p>\r\n	注意事项1.密钥防止泄露、以及经常更新密钥2.下载服务器和php服务器的时间不能相差太大，否则容易出现文件一直都是过期状态.\r\n</p>\r\n<p>\r\n	secure link以及内置到了nginx，不需要额外安装第三方模块，有下载服务器的情况,极力推荐使用它，除非你不在乎你的带宽.\r\n</p>\r\n<p>\r\n	6）珍爱带宽，远离迅雷还可以配置nginx，让nginx防止迅雷、快车的多线程下载：作用域： server locationif ($http_range)   {   return 405;   }\r\n</p>\r\n<p>\r\n	这样给用户端的第二个线程返回405，只让nginx单线程给用户吐数据。\r\n</p>\r\n<p>\r\n	二、Nginx中图片防盗链的操作记录图片防盗链和下载防盗链使用的指令不同，下载防盗链使用secure link,并且需要程序配合,但是效果非常好;而图片防盗链不需要程序配合,根据图片来源来实现,但是只能先限制基本的图片盗用,无法防止图片采集.nginx referer指令简介nginx模块ngx_http_referer_module通常用于阻挡来源非法的域名请求.我们应该牢记,伪装Referer头部是非常简单的事情，所以这个模块只能用于阻止大部分非法请求.我们应该记住，有些合法的请求是不会带referer来源头部的,所以有时候不要拒绝来源头部（referer）为空的请求.\r\n</p>\r\n<p>\r\n	nginx防盗链指令1）语法: referer_hash_bucket_size size;默认值: referer_hash_bucket_size 64;配置段: server, location这个指令在nginx 1.0.5中开始出现.2）语法:     referer_hash_max_size size;默认值:     referer_hash_max_size 2048;配置段:     server, location这个指令在nginx 1.0.5中开始出现.3）语法: valid_referers none | blocked | server_names | string ...;默认值: —配置段: server, location指定合法的来源\'referer\', 它决定了内置变量$invalid_referer的值，如果referer头部包含在这个合法网址里面，这个变量被设置为0，否则设置为1.记住，不区分大小写的.\r\n</p>\r\n<p>\r\n	参数说明none：“Referer” 来源头部为空的情况，即表示空的来路，也就是直接访问，比如直接在浏览器打开一个图片blocked：“Referer”来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都不以http://或者https://开头.即表示被防火墙标记过的来路server_names：“Referer”来源头部包含当前的server_names（当前域名）string：任意字符串,定义服务器名或者可选的URI前缀.主机名可以使用*开头或者结尾，在检测来源头部这个过程中，来源域名中的主机端口将会被忽略掉regular expression：正则表达式,~表示排除https://或http://开头的字符串.\r\n</p>\r\n<p>\r\n	注意：图片使用来源头部做防盗链是最合理的. 简单、实用。但是没有办法防采集。\r\n</p>\r\n<p>\r\n	图片防盗链的配置有三种方法，下面一一介绍：1）针对不同文件类型的防盗链：配置示例1：location ~* \\.(gif|jpg|png|bmp)$ {&nbsp; &nbsp; &nbsp; valid_referers none blocked *.wangshibo.com server_names ~\\.google\\. ~\\.baidu\\.;&nbsp; &nbsp; &nbsp; if ($invalid_referer) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 403;&nbsp; &nbsp; &nbsp; &nbsp; #rewrite ^/ http://www.wangshibo.com/403.jpg;&nbsp; &nbsp; &nbsp; }}\r\n</p>\r\n<p>\r\n	配置说明：以上所有来至wangshibo.com和域名中包含google和baidu的站点都可以访问到当前站点的图片如果来源域名不在这个列表中，那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面；如果使用下面的rewrite，那么盗链的图片都会显示403.jpg；如果用户直接在浏览器输入你的图片地址,那么图片显示正常，因为它符合none这个规则.\r\n</p>\r\n<p>\r\n	配置示例2：location ~ .*\\.(wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv)$ {&nbsp; &nbsp; &nbsp;valid_referers none blocked *.wangshibo.com wangshibo.com;&nbsp; &nbsp; &nbsp;if($invalid_referer){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#rewrite ^/ http://www.765h.com/error.html;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 403;&nbsp; &nbsp; &nbsp;}}\r\n</p>\r\n<p>\r\n	配置说明：第一行：表示对wma|wmv|asf|mp3|mmf|zip|rar|jpg|gif|png|swf|flv后缀的文件实行防盗链第二行：表示对*.wangshibo.com和wangshibo.com这2个来路进行判断(*代表任何，任何的二级域名)，可以添加更多if{}里面内容的意思是，如果来路不是指定来路就跳转到403错误页面，当然直接返回404也是可以的，也可以是图片。\r\n</p>\r\n<p>\r\n	一般常用的图片防盗链的方法是在server或者location段中加入：valid_referers  none blocked www.wangshibo.com wangshibo.com;如上面的两个小示例能起到一定的图片防盗链功能，但其实并不是真正的彻底的防盗链设置。一般来说：做好防盗链之后，其他网站盗链的本站图片就会全部失效无法显示，但是如果通过浏览器直接输入图片地址，仍然会显示图片，仍然可以右键图片另存为下载文件！依然可以下载？这样就不是彻底的防盗了！那么，nginx应该怎么样彻底地实现真正意义上的防盗链呢？\r\n</p>\r\n<p>\r\n	首先，来看下nginx如何设置防盗链？修改 /usr/local/nginx/conf/nginx.conf 这个配置文件：默认图片是有过期时间设置的[root@bastion-IDC ~]# vim /usr/local/nginx/conf/nginx.conf location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {&nbsp; &nbsp;expires   30d;}\r\n</p>\r\n<p>\r\n	把上面的配置修改成：[root@bastion-IDC ~]# vim /usr/local/nginx/conf/nginx.conflocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {&nbsp; &nbsp; valid_referers none blocked *.wangshibo.com wangshibo.com;&nbsp; &nbsp; if($invalid_referer) {&nbsp; &nbsp; &nbsp; &nbsp;rewrite ^/ http://www.wangshibo.com/404.jpg;&nbsp; &nbsp; &nbsp; #return404;&nbsp; &nbsp; }&nbsp; &nbsp; expires   30d;}\r\n</p>\r\n<p>\r\n	配置解说：第一行：location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$其中“gif|jpg|jpeg|png|bmp|swf”设置防盗链文件类型，自行修改，每个后缀用“|”符号分开！\r\n</p>\r\n<p>\r\n	第二行：valid_referers none blocked *.wangshibo.com wangshibo.com;就是白名单，允许文件链出的域名白名单，自行修改成您的域名！*.wangshibo.com这个指的是子域名，域名与域名之间使用空格隔开！\r\n</p>\r\n<p>\r\n	第四行：rewrite ^/ http://www.wangshibo.com/404.jpg;这个图片是盗链返回的图片，也就是替换盗链网站所有盗链的图片。这个图片要放在没有设置防盗链的网站上，因为防盗链的作用，这个图片如果也放在防盗链网站上就会被当作防盗链显示不出来了，盗链者的网站所盗链图片会显示X符号。\r\n</p>\r\n<p>\r\n	这样设置差不多就可以起到防盗链作用了，但是这样并不是彻底地实现真正意义上的防盗链！我们来看第二行：valid_referers none blocked *.wangshibo.com wangshibo.com;valid_referers 里多了“none blocked”我们把“none blocked”删掉，改成：valid_referers *.wangshibo.com wangshibo.com; 所以说：nginx彻底地实现真正意义上的防盗链完整的代码应该是这样的：1.去掉valid_referers 后面的none blocked2.防盗链和expires图片过期时间设置整合到一起。其实就是保证server段中只有一个类似location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$的配置完整配置如下：\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\r\n</p>\r\n<p>\r\n	valid_referers *.wangshibo.com wangshibo.com;\r\n</p>\r\n<p>\r\n	if($invalid_referer) {\r\n</p>\r\n<p>\r\n	rewrite ^/ http://www.wangshibo.com/404.jpg;\r\n</p>\r\n<p>\r\n	#return404;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	expires 30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样您在浏览器直接输入图片地址就不会再显示图片出来了，也不可能会再右键另存什么的。第四行：rewrite ^/ http://www.wangshibo.com/404.jpg;这个是给图片防盗链设置的防盗链返回图片如果我们是文件需要防盗链下载，把第四行改成一个链接，比如可以改成是主站的链接rewrite ^/ http://www.wangshibo.com;这样，当别人输入文件下载地址，由于防盗链下载的作用就会跳转到您设置的这个链接！最后，配置文件设置完成别忘记重启nginx生效！\r\n</p>\r\n<p>\r\n	再看一例：比如现在google首页点击广告www.abc.com跳转到www.baidu.com,但是直接在浏览器输入www.abc.com，还是www.abc.com配置如下：valid_referers none blocked localhost *.abc.com abc.com;&nbsp; &nbsp;if ($invalid_referer){&nbsp; &nbsp; &nbsp;rewrite  ^/(.*)  http://www.baidu.com/? permanent;&nbsp; &nbsp; &nbsp;break;&nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------------------------------实验说明：[root@test-huanqiu ~]# vim /usr/local/nginx/conf/vhosts/image.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80 ;\r\n</p>\r\n<p>\r\n	server_name 192.168.1.14 web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	location ~* \\.(gif|jpg|png|swf|flv)$ {\r\n</p>\r\n<p>\r\n	valid_referers none blocked *.wangshibo.cn;\r\n</p>\r\n<p>\r\n	if ($invalid_referer) {\r\n</p>\r\n<p>\r\n	rewrite ^/ http://www.heihei.com/404.jpg;\r\n</p>\r\n<p>\r\n	#return 404;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	expires 30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(php|php5)?$ {\r\n</p>\r\n<p>\r\n	#fastcgi_pass  unix:/tmp/php-cgi.sock;\r\n</p>\r\n<p>\r\n	fastcgi_pass  127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	include fastcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	注意第8行 \"valid_referers none blocked\" 其中\"none\" \"blocked\" 的意思分别是：none代表没有referer;blocded代表有referer但是被防火墙或者是代理给去除了。\r\n</p>\r\n<p>\r\n	以上配置后，访问的跳转流程：1）首先当输入要打开的网址的时候，因为是直接输入的没有referer，所以匹配了valid_referers后面的none或者是blocked，invalid_referer值为0,因此不进行跳转.2）当是从这个网站里面的链接跳到该网站首页的时候，因为referer的值是肯定包含srever_names，所以匹配了server_names，因此不进行跳转；3）当从搜素引擎进去的时候因为referer字段类似于www.google.com.hk/search，开始进行匹配，发现没有一个匹配，则此时会设置invalid_referer值为1，if语句成功执行，进行了跳转. 达到功能！\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful[root@test-huanqiu ~]#  /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	只有把这两个none,blocked去掉，才可以真正的实现防盗连！因为只有匹配到server_name的时候，才不会进行跳转。如下说明：\r\n</p>\r\n<p>\r\n	[root@master-node html]# ll /var/www/html/total 16-rw-r--r-- 1 www www   143 Dec 14 11:34 index.html-rw-r--r-- 1 www www 10571 Dec 14 11:35 long.jpg[root@master-node html]# cat /var/www/html/index.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<h1>\r\n	\"王士博\",welcome to beijing!!\r\n</h1>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<img alt=\"long.jpg\" src=\"/long.jpg\" height=\"auto\" width=\"auto\" />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	访问，看看效果：\r\n</p>\r\n<p>\r\n	接真输入图片地址可以显示图片：\r\n</p>\r\n<p>\r\n	现在将none,blocked去掉，看看效果：[root@test-huanqiu ~]# vim /usr/local/nginx/conf/vhosts/image.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80 ;\r\n</p>\r\n<p>\r\n	server_name 192.168.1.14 web01.wangshibo.cn;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	location ~* \\.(gif|jpg|png|swf|flv)$ {\r\n</p>\r\n<p>\r\n	valid_referers *.wangshibo.cn;\r\n</p>\r\n<p>\r\n	if ($invalid_referer) {\r\n</p>\r\n<p>\r\n	rewrite ^/ http://www.heihei.com/404.jpg;\r\n</p>\r\n<p>\r\n	#return 404;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	expires 30d;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(php|php5)?$ {\r\n</p>\r\n<p>\r\n	#fastcgi_pass  unix:/tmp/php-cgi.sock;\r\n</p>\r\n<p>\r\n	fastcgi_pass  127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	include fastcgi.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful[root@test-huanqiu ~]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	再次访问\r\n</p>\r\n<p>\r\n	当再次访问http://web01.wangshibo.cn/long.jpg时就会跳转到http://www.heihei.com/404.jpg（测试时，记得删除浏览器缓存。nginx中有图片缓存配置）\r\n</p>\r\n<p>\r\n	这样就实现了完美的防盗链！！另外注意：1）请确保server段中只有一个location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$（比如还有另外的一个针对expires过期时间的这样的location配置，那么必须要将其和防盗链的location整合到一起），否则可能导致代码无效，如有这个代码段请合并或删除。2）切记：如果要跳转到图片，记得替换的图片地址要使用没有防盗链的网站图片，否则由于替换的图片其实也处于防盗链情况下，会造成仍旧无法显示设置的图片。\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）针对目录的防盗链：（ 这是nginx自带的防盗链功能。）location /img/ {   root  /data/img/;   valid_referers none blocked *.wangshibo.com wangshibo.com;   if($invalid_referer){      rewrite  ^/  http://www.wangshibo.com/images/error.gif;      #return  403;   }}\r\n</p>\r\n<p>\r\n	location /images/ {   alias /data/images/;   valid_referers none blocked server_names *.wangshibo.com wangshibo.com ;   if ($invalid_referer) {    return 403;  } }\r\n</p>\r\n<p>\r\n	3）使用第三方模块ngx_http_accesskey_module实现的防盗链： 1.下载Nginx和nginx-http-access模块http://nginx.org/download/nginx-1.8.0.tar.gzhttp://wiki.nginx.org/File:Nginx-accesskey-2.0.3.tar.gz2.安装[root@test-huanqiu ~]# tar -zxvf nginx-1.8.0.tar.gz[root@test-huanqiu ~]# cd nginx-1.8.0/[root@test-huanqiu ~]# tar -xvfz nginx-accesskey-2.0.3.tar.gz[root@test-huanqiu ~]# cd nginx-accesskey-2.0.3[root@test-huanqiu nginx-accesskey-2.0.3]# vim config#替换其中的”$HTTP_ACCESSKEY_MODULE”为”ngx_http_accesskey_module”   (这是此模块的一个bug)\r\n</p>\r\n<p>\r\n	接着编译安装nginx[root@test-huanqiu nginx-1.8.0]# ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --add-module=/root/nginx-accesskey-2.0.3\r\n</p>\r\n<p>\r\n	配置nginx：location /download {&nbsp; &nbsp; accesskey on;&nbsp; &nbsp; accesskey_hashmethod md5;&nbsp; &nbsp; accesskey_arg \"key\";&nbsp; &nbsp; accesskey_signature \"mypass$remote_addr\";}\r\n</p>\r\n<p>\r\n	配置说明： accesskey为模块开关； accesskey_hashmethod为加密方式MD5或者SHA-1； accesskey_arg为url中的关键字参数； accesskey_signature为加密值，此处为mypass和访问IP构成的字符串。\r\n</p>\r\n<p>\r\n	编写测试脚本download.php：<!--?$ipkey= md5(\"mypass\".$_SERVER[\'REMOTE_ADDR\']);$output_add_key=\"<a href=http://www.wangshibo.com/download/G3200507120520LM.rar?key=\".$ipkey.\"-->download_add_key<br />\r\n\";$output_org_url=\"<a href=\"http://www.wangshibo.com/download/G3200507120520LM.rar\">download_org_path</a><br />\r\n\";echo $output_add_key;echo $output_org_url;?&gt;\r\n</p>\r\n<p>\r\n	如上配置后：访问第一个download_add_key链接可以正常下载，第二个链接download_org_path会返回403 Forbidden错误。\r\n</p>\r\n<p>\r\n	如果不怕麻烦，有条件实现的话，推荐使用第三方模块ngx_http_accesskey_module实现的防盗链。它的运行方式是：比如download目录下有一个 file.zip 的文件。对应的URI 是http://www.wangshibo.com/download/file.zip使用ngx_http_accesskey_module模块后http://www.wangshibo.com/download/file.zip?key=09093abeac094. 只有给定的key值正确了，才能够下载download目录下的file.zip。而且 key 值是根据用户的IP有关的，这样就可以避免被盗链了。据说Nginx HttpAccessKeyModule现在连迅雷都可以防了，可以尝试一下。\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------图片访问地址操作记录------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	1）需求：配置一个图片上传下载的需求，及在nginx里配置一个url，用于图片上传和下载。\r\n</p>\r\n<p>\r\n	直接配置本机的nginx\r\n</p>\r\n<p>\r\n	# vim vhosts/images.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name images.wang.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	server_tokens off;\r\n</p>\r\n<p>\r\n	access_log  logs/ehr_access.log;\r\n</p>\r\n<p>\r\n	error_log   logs/ehr_error.log;\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\r\n</p>\r\n<p>\r\n	expires      7d;              //过期时间\r\n</p>\r\n<p>\r\n	root /data/nginx/images/;\r\n</p>\r\n<p>\r\n	proxy_store on;\r\n</p>\r\n<p>\r\n	proxy_store_access user:rw group:rw all:rw;\r\n</p>\r\n<p>\r\n	proxy_temp_path         /data/nginx/images/;      //存放图片的目录\r\n</p>\r\n<p>\r\n	proxy_redirect          off;\r\n</p>\r\n<p>\r\n	proxy_set_header        Host 127.0.0.1;\r\n</p>\r\n<p>\r\n	client_max_body_size    100m;           //图片上传的大小限制\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout   900;\r\n</p>\r\n<p>\r\n	proxy_send_timeout      900;\r\n</p>\r\n<p>\r\n	proxy_read_timeout      900;\r\n</p>\r\n<p>\r\n	proxy_buffer_size       40k;\r\n</p>\r\n<p>\r\n	proxy_buffers           40 320k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 640k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 640k;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(js|css)?$ {\r\n</p>\r\n<p>\r\n	expires      12h;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样：\r\n</p>\r\n<p>\r\n	图片上传和下载的url为：http://images.wang.com，\r\n</p>\r\n<p>\r\n	图片存放的目录为/data/nginx/images/\r\n</p>\r\n<p>\r\n	2）需求：在tomcat里部署一个用于图片上传和下载的目录，然后在nginx里配置图片访问的url。\r\n</p>\r\n<p>\r\n	先配置本机的tomcat\r\n</p>\r\n<p>\r\n	# cat /data/tomcat7/conf/server.xml\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	<host .....<=\"\" p=\"\">\r\n</p>\r\n<p>\r\n	.....\r\n</p>\r\n<p>\r\n	//这一行写在<host之间< p=\"\"></host之间<>\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# mkdir /data/tomcat7/ehrbak\r\n</p>\r\n<p>\r\n	接着配置本机的nginx\r\n</p>\r\n<p>\r\n	# cat /data/nginx/conf/vhosts/ehr.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name images.wang.com;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	server_tokens off;\r\n</p>\r\n<p>\r\n	access_log  logs/ehr_access.log;\r\n</p>\r\n<p>\r\n	error_log   logs/ehr_error.log;\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\r\n</p>\r\n<p>\r\n	expires      7d;\r\n</p>\r\n<p>\r\n	root /data/tomcat7/ehrbak/;\r\n</p>\r\n<p>\r\n	proxy_store on;\r\n</p>\r\n<p>\r\n	proxy_store_access user:rw group:rw all:rw;\r\n</p>\r\n<p>\r\n	proxy_temp_path         /data/tomcat7/ehrbak/;\r\n</p>\r\n<p>\r\n	proxy_redirect          off;\r\n</p>\r\n<p>\r\n	proxy_set_header        Host 127.0.0.1;\r\n</p>\r\n<p>\r\n	client_max_body_size    100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout   900;\r\n</p>\r\n<p>\r\n	proxy_send_timeout      900;\r\n</p>\r\n<p>\r\n	proxy_read_timeout      900;\r\n</p>\r\n<p>\r\n	proxy_buffer_size       40k;\r\n</p>\r\n<p>\r\n	proxy_buffers           40 320k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 640k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 640k;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ .*\\.(js|css)?$ {\r\n</p>\r\n<p>\r\n	expires      12h;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	然后在前面的nginx代理层（即另一台机器上）\r\n</p>\r\n<p>\r\n	[root@BJLX_4_21_P vhosts]# cat ssl-ehr.conf\r\n</p>\r\n<p>\r\n	upstream ehr {\r\n</p>\r\n<p>\r\n	server 172.29.34.27:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream download {\r\n</p>\r\n<p>\r\n	server 172.29.34.27:80 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name images.wang.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	server_tokens off;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/ehr_access.log;\r\n</p>\r\n<p>\r\n	error_log logs/ehr_error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wang.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wang.key;\r\n</p>\r\n<p>\r\n	#ssl_session_timeout 5m;\r\n</p>\r\n<p>\r\n	location /file/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://download/;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样：\r\n</p>\r\n<p>\r\n	图片访问的url是：https://images.wang.com/file/***\r\n</p>\r\n<p>\r\n	图片存放的路径是本机的/data/tomcat7/ehrbak/\r\n</p>\r\n<p>\r\n	比如有一张图片路径为/data/tomcat7/ehrbak/upload/201707/051622309x32.jpg\r\n</p>\r\n<p>\r\n	那么这张图片的访问地址是：https://images.wang.com/file/upload/201707/051622309x32.jpg\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('897c1211-2993-4a1b-99d8-38c9e898e617','监控暂无文章','监控暂无文章','监控暂无文章','2017-07-24 10:39:23',4,16,'images/zabbix.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('8bd3b1b0-50bd-4b31-9b09-367a89828a92','mysql下mysqladmin日常管理命令总结','mysql下mysqladmin日常管理命令总结','<p>\r\n	mysqladmin 工具的使用格式：mysqladmin [option] command [command option] command ......参数选项：-c  number 自动运行次数统计，必须和 -i 一起使用-i  number 间隔多长时间重复执行\r\n</p>\r\n<p>\r\n	0）每个两秒查看一次服务器的状态，总共重复5次。[root@test-huanqiu ~]# mysqladmin -uroot -p  -i 2 -c 5 status\r\n</p>\r\n<p>\r\n	1）查看服务器的状况：status[root@test-huanqiu ~]# mysqladmin -uroot -p status\r\n</p>\r\n<p>\r\n	2）修改root 密码：[root@test-huanqiu ~]# mysqladmin -u root -p原密码 password \'newpassword\'\r\n</p>\r\n<p>\r\n	3）检查mysqlserver是否可用：[root@test-huanqiu ~]# mysqladmin -uroot -p ping\r\n</p>\r\n<p>\r\n	4）查询服务器的版本[root@test-huanqiu ~]# mysqladmin -uroot -p version\r\n</p>\r\n<p>\r\n	5）查看服务器状态的当前值：[root@test-huanqiu ~]# mysqladmin -uroot -p extended-status\r\n</p>\r\n<p>\r\n	6）查询服务器系统变量值：[root@test-huanqiu ~]# mysqladmin -uroot -p variables\r\n</p>\r\n<p>\r\n	7）显示服务器所有运行的进程：[root@test-huanqiu ~]# mysqladmin -uroot -p processlist[root@test-huanqiu ~]# mysqladmin -uroot -p-i 1 processlist &nbsp; &nbsp; &nbsp; &nbsp;//每秒刷新一次\r\n</p>\r\n<p>\r\n	8）创建数据库[root@test-huanqiu ~]# mysqladmin -uroot -p create daba-test\r\n</p>\r\n<p>\r\n	9）显示服务器上的所有数据库[root@test-huanqiu ~]# mysqlshow -uroot -p\r\n</p>\r\n<p>\r\n	10）显示数据库daba-test下有些什么表：[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test\r\n</p>\r\n<p>\r\n	11）统计daba-test 下数据库表列的汇总[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v\r\n</p>\r\n<p>\r\n	12）统计daba-test 下数据库表的列数和行数[root@test-huanqiu ~]# mysqlshow -uroot -p daba-test -v -v\r\n</p>\r\n<p>\r\n	13）删除数据库 daba-test[root@test-huanqiu ~]# mysqladmin -uroot -p drop daba-test\r\n</p>\r\n<p>\r\n	14）重载权限信息[root@test-huanqiu ~]# mysqladmin -uroot -p reload\r\n</p>\r\n<p>\r\n	15）刷新所有表缓存，并关闭和打开log[root@test-huanqiu ~]# mysqladmin -uroot -p refresh\r\n</p>\r\n<p>\r\n	16）使用安全模式关闭数据库[root@test-huanqiu ~]# mysqladmin -uroot -p shutdown\r\n</p>\r\n<p>\r\n	17）刷新命令mysqladmin flush commands[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-hosts[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-logs[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-privileges[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-status[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-tables[root@test-huanqiu ~]# mysqladmin -u root -ptmppassword flush-threads\r\n</p>\r\n<p>\r\n	18）mysqladmin 执行kill 进程：[root@test-huanqiu ~]# mysqladmin -uroot -p processlist[root@test-huanqiu ~]# mysqladmin -uroot -p kill idnum\r\n</p>\r\n<p>\r\n	19）停止和启动MySQL replication on a slave server[root@test-huanqiu ~]# mysqladmin  -u root -p stop-slave[root@test-huanqiu ~]# mysqladmin  -u root -p start-slave\r\n</p>\r\n<p>\r\n	20）同时执行多个命令[root@test-huanqiu ~]# mysqladmin  -u root -p process status version\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('902dba53-097a-4659-a0a3-0b295fa3039f','Nginx反向代理+负载均衡简单实现（http方式）','Nginx反向代理+负载均衡简单实现（http方式）','<p>\r\n	1）nginx的反向代理：proxy_pass2）nginx的负载均衡：upstream\r\n</p>\r\n<p>\r\n	下面是nginx的反向代理和负载均衡的实例：\r\n</p>\r\n<p>\r\n	负载机：A机器：103.110.186.8/192.168.1.8\r\n</p>\r\n<p>\r\n	后端机器1：B机器：192.168.1.102 后端机器2：C机器：192.168.1.103\r\n</p>\r\n<p>\r\n	需求：\r\n</p>\r\n<p>\r\n	1）访问A机器的8080端口，反向代理到B机器的8080端口；     访问A机器的8088端口，反向代理到C机器的8088端口；     访问http://103.110.86.8:8090/ios，反向代理到B机器http://192.168.1.102:8090/ios/\r\n</p>\r\n<p>\r\n	2）访问A机器的80端口，负载均衡到后端的两台机器B和C的80端口\r\n</p>\r\n<p>\r\n	操作记录：--------------------------------------------------------------------------------------负载机：\r\n</p>\r\n<p>\r\n	A机器上的操作记录：\r\n</p>\r\n<p>\r\n	1）编译安装nginx\r\n</p>\r\n<p>\r\n	[root@opd ~]# yum install -y pcre* openssl* gcc gcc+\r\n</p>\r\n<p>\r\n	[root@opd ~]# cd /opt/src\r\n</p>\r\n<p>\r\n	[root@src ~]# wget http://nginx.org/download/nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@src ~]# tar -zxvf nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@src ~]# cd nginx-1.8.0#添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#useradd www -M -s /sbin/nologin\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#vim auto/cc/gcc#将这句注释掉 取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"\r\n</p>\r\n<p>\r\n	#我们再配置下nginx编译参数\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# ./configure --prefix=/opt/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#mak\r\n</p>\r\n<p>\r\n	e[root@nginx-1.8.0 ~]#make install clean\r\n</p>\r\n<p>\r\n	2）配置nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# cd /opt/nginx/conf\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim nginx.conf &nbsp; &nbsp; &nbsp; &nbsp; //这个可以作为nginx安装后的配置规范\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# ulimit -n 65535\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# mkdir vhosts\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# cd vhosts\r\n</p>\r\n<p>\r\n	配置反向代理和负载均衡\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# vim 8080.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8080;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.102:8080;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;             #跟后端服务器连接超时时间，发起握手等候响应时间\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;                #后端服务器回传时间，就是在规定时间内后端服务器必须传完所有数据\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;                #连接成功后等待后端服务器的响应时间，已经进入后端的排队之中等候处理\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;                #代理请求缓冲区,会保存用户的头信息以供nginx进行处理\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;                  #同上，告诉nginx保存单个用几个buffer最大用多少空间\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;          #如果系统很忙时候可以申请最大的proxy_buffers\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;       #proxy缓存临时文件的大小\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# cat 8088.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8088;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8088-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8088-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.103:8088;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------下面这个匹配path的代理设置需要注意几点：首先一定要保证目标B机器，也就是192.168.1.102的8090端口站点目录下有这个匹配path的目录ios存在！！也就是要保证A机器本机能顺利访问到目标B机器的8090端口的ios路径，即：[root@nginx-1.8.0 vhosts]# curl http://192.168.1.102:8090/ios/         #一定要保证这个能从A机器访问成功！\r\n</p>\r\n<p>\r\n	下面几种配置都是可以的：\r\n</p>\r\n<p>\r\n	第一种：[root@nginx-1.8.0 vhosts]# cat 8090.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8090;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8090-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8090-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /ios/ {                            #这种情况，这里一定要匹配的是/ios/，不能是/ios\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.102:8090;       #一定要保证192.168.1.102机器8090端口站点目录下有ios目录！否则访问会报错404！\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	第二种：[root@nginx-1.8.0 vhosts]# cat 8090.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8090;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8090-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8090-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /ios/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.102:8090/ios/;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	第三种：[root@nginx-1.8.0 vhosts]# cat 8090.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8090;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8090-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8090-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /ios {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.102:8090/ios/;         这种情况，这里一定要匹配的是/ios/，不能是/ios\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	以上三种配置方法都保证了访问http://103.110.86.8:8090/ios会自动变为http://103.10.86.8:8090/ios/，并代理到http://192.168.1.102:8090/ios/的结果\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# cat LB.conf\r\n</p>\r\n<p>\r\n	upstream lb {\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80 max_fails=3 fail_timeout=30s;   #max_fails = 3 为允许失败的次数，默认值为1\r\n</p>\r\n<p>\r\n	server 192.168.1.103:80 max_fails=3 fail_timeout=30s;   #fail_timeout = 30s 当max_fails次失败后，暂停将请求分发到该后端服务器的时间\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/80-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/80-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://lb;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	启动nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# /opt/nginx/sbin/nginx -t&nbsp;\r\n</p>\r\n<p>\r\n	【检查配置是否正确】nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx/conf/nginx.conf test is successful\r\n</p>\r\n<p>\r\n	[root@host-192-168-1-102 vhosts]# /opt/nginx/sbin/nginx        【启动nginx】\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------后端机：B机器上的操作记录：\r\n</p>\r\n<p>\r\n	1）编译安装nginx[root@B ~]# yum install -y pcre* openssl* gcc gcc+\r\n</p>\r\n<p>\r\n	[root@B ~]# cd /opt/src\r\n</p>\r\n<p>\r\n	[root@B ~]# wget http://nginx.org/download/nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@B ~]# tar -zxvf nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@B ~]# cd nginx-1.8.0#添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#useradd www -M -s /sbin/nologin\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]##vim auto/cc/gcc#将这句注释掉 取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"\r\n</p>\r\n<p>\r\n	#我们再配置下nginx编译参数\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# ./configure --prefix=/opt/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#make\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#make install clean\r\n</p>\r\n<p>\r\n	2）配置nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# cd /opt/nginx/conf注意，把默认的nginx.conf文件中的server区域配置注释掉，设置vhosts虚拟主机的配置，如下：\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim nginx.conf\r\n</p>\r\n<p>\r\n	user  www;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# ulimit -n 65535[root@nginx-1.8.0 conf]# mkdir vhosts[root@nginx-1.8.0 conf]# cd vhosts\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim 8080.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8080;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8080-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8080-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8080;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim 8090.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8090;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/8090-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/8090-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/8090;        #针对上面匹配ios的path代理，要保证站点目录/var/www/html/8080下有ios目录存在\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim 80.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/80-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/80-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	启动nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# /opt/nginx/sbin/nginx -t&nbsp;\r\n</p>\r\n<p>\r\n	【检查配置是否正确】nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx/conf/nginx.conf test is successful\r\n</p>\r\n<p>\r\n	[root@host-192-168-1-102 vhosts]# /opt/nginx/sbin/nginx&nbsp;\r\n</p>\r\n<p>\r\n	【启动nginx】\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------后端机：C机器上的操作记录：\r\n</p>\r\n<p>\r\n	1）编译安装nginx[root@C ~]# yum install -y pcre* openssl* gcc gcc+\r\n</p>\r\n<p>\r\n	[root@C ~]# cd /opt/src\r\n</p>\r\n<p>\r\n	[root@C ~]# wget http://nginx.org/download/nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@C ~]# tar -zxvf nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@C ~]# cd nginx-1.8.0#添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#useradd www -M -s /sbin/nologin\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]##vim auto/cc/gcc#将这句注释掉 取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"\r\n</p>\r\n<p>\r\n	#我们再配置下nginx编译参数\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# ./configure --prefix=/opt/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#make\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#make install clean\r\n</p>\r\n<p>\r\n	2）配置nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]# cd /opt/nginx/conf注意，把默认的nginx.conf文件中的server区域配置注释掉，设置vhosts虚拟主机的配置，如下：\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim nginx.conf\r\n</p>\r\n<p>\r\n	user  www;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# vim 80.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/80-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/80-error.log;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location ~ / {\r\n</p>\r\n<p>\r\n	root /var/www/html/;\r\n</p>\r\n<p>\r\n	index index.html index.php index.htm;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	启动nginx\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# /opt/nginx/sbin/nginx -t&nbsp;\r\n</p>\r\n<p>\r\n	【检查配置是否正确】nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is oknginx: configuration file /opt/nginx/conf/nginx.conf test is successful\r\n</p>\r\n<p>\r\n	[root@host-192-168-1-102 vhosts]# /opt/nginx/sbin/nginx        【启动nginx】\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	到此，上面需求中的nginx反向代理和负载均衡就已经配置完成了！访问http://103.110.86.8:8080的结果显示的就是B机器，即http://192.168.1.102:8080的结果访问http://103.110.86.8:8088的结果显示的就是C机器，即http://192.168.1.108:8088的结果访问http://103.110.86.8:8090/ios的结果显示的就是B机器，即http://192.168.1.102:8090/ios/的结果\r\n</p>\r\n<p>\r\n	访问http://103.110.86.8的请求就会被负载给到后端两台机器http://192.168.1.102和http://192.168.1.103\r\n</p>\r\n<p>\r\n	可以在103.110.86.8本机可以使用curl和telnet测试到目标机器是否通顺~\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 vhosts]# curl http://192.168.1.102:8080[root@nginx-1.8.0 vhosts]# telnet 192.168.1.102 8080\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------------------------------------------------------------说明一下：上面的nginx反向代理的需求，除了nginx反代配置之外，也可以使用iptables的nat转发实现。\r\n</p>\r\n<p>\r\n	比如：访问A机器的8080端口，反向代理到B机器的80端口；\r\n</p>\r\n<p>\r\n	iptables的nat转发规则设置如下：\r\n</p>\r\n<p>\r\n	[root@opd ~]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 8080 -j DNAT --to-destination 192.168.1.102:80&nbsp;\r\n</p>\r\n<p>\r\n	[root@opd ~]# iptables -t nat -A POSTROUTING -d 192.168.1.102 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.168.1.8\r\n</p>\r\n<p>\r\n	[root@opd ~]# iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT\r\n</p>\r\n<p>\r\n	[root@opd ~]# service iptables save\r\n</p>\r\n<p>\r\n	**************************************需要注意的是：要打开A机器的ip转发功能：\r\n</p>\r\n<p>\r\n	[root@opd ~]# echo 1 &gt; /proc/sys/net/ipv4/ip_forward然后后端机器B的route路由最好也设置成192.168.1.8**************************************\r\n</p>\r\n<p>\r\n	这样，访问http://103.110.86.8:8080的结果就是http://192.168.1.102的结果\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------------nginx反向代理一例：访问http://testwx3.wangshibo.com/apiwx3反向代理到https://testwww.wangshibo.com\r\n</p>\r\n<p>\r\n	[root@dev-new-test vhosts]# cat testwx3.wangshibo.com.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server_name  testwx3.wangshibo.com;\r\n</p>\r\n<p>\r\n	root  /Data/app/xqsj_wx3/dist;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	location /apiwx3/ {\r\n</p>\r\n<p>\r\n	proxy_pass https://testwww.wangshibo.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如上配置后：访问http://testwx3.wangshibo.com/apiwx3自动跳转到http://testwx3.wangshibo.com/apiwx3/访问http://testwx3.wangshibo.com/apiwx3/$1的内容和https://testwww.wangshibo.com/$1内容一致比如：访问http://testwx3.wangshibo.com/apiwx3/xqsj.php?r=HouseGroup/create &nbsp;显示的内容既是 &nbsp;http://testwww.wangshibo.com/xqsj.php?r=HouseGroup/create的内容\r\n</p>\r\n<p>\r\n	如果将上面的代理配置改为：\r\n</p>\r\n<p>\r\n	location /apiwx3 {\r\n</p>\r\n<p>\r\n	proxy_pass https://testwww.wangshibo.com;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	或者\r\n</p>\r\n<p>\r\n	location /apiwx3/ {\r\n</p>\r\n<p>\r\n	proxy_pass https://testwww.wangshibo.com/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	那么只能实现：访问http://testwx3.wangshibo.com/apiwx3的结果和https://testwww.wangshibo.com一致不能实现：访问http://testwx3.wangshibo.com/apiwx3/$1的内容和https://testwww.wangshibo.com/$1内容一致-----------------------------------------------------------------------------------------------------------\r\n</p>','2017-07-31 17:16:48',1,4,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('98fd382c-bdd3-4a10-a1a9-c59ad8febc09','Nginx的location配置规则梳理','Nginx的location配置规则梳理','<p>\r\n	Nginx几乎是当下绝大多数公司在用的web应用服务，熟悉Nginx的配置，对于我们日常的运维工作是至关重要的，下面就Nginx的location配置进行梳理：\r\n</p>\r\n<p>\r\n	1）location匹配的是nginx的哪个变量？\r\n</p>\r\n<p>\r\n	$request_uri\r\n</p>\r\n<p>\r\n	2）location的匹配种类有哪些?\r\n</p>\r\n<p>\r\n	格式：location [ 空格 | = | ~ | ~* | !~ | !~* ｜ @ ] /uri/ {}\r\n</p>\r\n<p>\r\n	解释：\r\n</p>\r\n<p>\r\n	=   表示精确匹配，如果找到，立即停止搜索并立即处理此请求。\r\n</p>\r\n<p>\r\n	~   表示执行一个正则匹配，区分大小写匹配\r\n</p>\r\n<p>\r\n	~*  表示执行一个正则匹配，不区分大小写匹配\r\n</p>\r\n<p>\r\n	!~  区分大小写不匹配\r\n</p>\r\n<p>\r\n	!~* 不区分大小写不匹配\r\n</p>\r\n<p>\r\n	^~  即表示只匹配普通字符（空格）。使用前缀匹配，^表示“非”，即不查询正则表达式。如果匹配成功，则不再匹配其他location。\r\n</p>\r\n<p>\r\n	@   指定一个命名的location，一般只用于内部重定向请求。例如 error_page, try_files\r\n</p>\r\n<p>\r\n	/   表示通用匹配，任何请求都会匹配到\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	对应示例说明：\r\n</p>\r\n<p>\r\n	1）=\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	server_name wangshibo.com;\r\n</p>\r\n<p>\r\n	location = /abcd {\r\n</p>\r\n<p>\r\n	[…]\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	匹配情况：\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd        # 正好完全匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/ABCD        # 如果运行 Nginx server 的系统本身对大小写不敏感，比如 Windows ，那么也匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd?param1?m2    # 忽略查询串参数（query string arguments），这里就是 /abcd 后面的 ?param1?m2\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd/    # 不匹配，因为末尾存在反斜杠（trailing slash），Nginx 不认为这种情况是完全匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcde    # 不匹配，因为不是完全匹配\r\n</p>\r\n<p>\r\n	2）(None)\r\n</p>\r\n<p>\r\n	可以不写 location modifier ，Nginx 仍然能去匹配 pattern 。这种情况下，匹配那些以指定的 patern 开头的 URI，注意这里的 URI 只能是普通字符串，不能使用正则表达式。\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	server_name website.com;\r\n</p>\r\n<p>\r\n	location /abcd {\r\n</p>\r\n<p>\r\n	[…]\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	匹配情况：\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd        # 正好完全匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/ABCD        # 如果运行 Nginx server 的系统本身对大小写不敏感，比如 Windows ，那么也匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd?param1?m2    # 忽略查询串参数（query string arguments），这里就是 /abcd 后面的 ?param1?m2\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd/    # 末尾存在反斜杠（trailing slash）也属于匹配范围内\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcde    # 仍然匹配，因为 URI 是以 pattern 开头的\r\n</p>\r\n<p>\r\n	3）~\r\n</p>\r\n<p>\r\n	这个 location modifier 对大小写敏感，且 pattern 须是正则表达式\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	server_name wangshibo.com;\r\n</p>\r\n<p>\r\n	location ~ ^/abcd$ {\r\n</p>\r\n<p>\r\n	[…]\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	匹配情况：\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd        # 完全匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/ABCD        # 不匹配，~ 对大小写是敏感的\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd?param1?m2    # 忽略查询串参数（query string arguments），这里就是 /abcd 后面的 ?param1?m2\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd/    # 不匹配，因为末尾存在反斜杠（trailing slash），并不匹配正则表达式 ^/abcd$\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcde    # 不匹配正则表达式 ^/abcd$\r\n</p>\r\n<p>\r\n	注意：对于一些对大小写不敏感的系统，比如 Windows ，~ 和 ~* 都是不起作用的，这主要是操作系统的原因。\r\n</p>\r\n<p>\r\n	4）~*\r\n</p>\r\n<p>\r\n	与 ~ 类似，但这个 location modifier 不区分大小写，pattern 须是正则表达式\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	server_name website.com;\r\n</p>\r\n<p>\r\n	location ~* ^/abcd$ {\r\n</p>\r\n<p>\r\n	[…]\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	匹配情况：\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd        # 完全匹配\r\n</p>\r\n<p>\r\n	http://wangshibo.com/ABCD        # 匹配，这就是它不区分大小写的特性\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd?param1?m2    # 忽略查询串参数（query string arguments），这里就是 /abcd 后面的 ?param1?m2\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcd/    # 不匹配，因为末尾存在反斜杠（trailing slash），并不匹配正则表达式 ^/abcd$\r\n</p>\r\n<p>\r\n	http://wangshibo.com/abcde    # 不匹配正则表达式 ^/abcd$\r\n</p>\r\n<p>\r\n	5）^~\r\n</p>\r\n<p>\r\n	匹配情况类似 2. (None) 的情况，以指定匹配模式开头的 URI 被匹配，不同的是，一旦匹配成功，那么 Nginx 就停止去寻找其他的 Location 块进行匹配了（与 Location 匹配顺序有关）\r\n</p>\r\n<p>\r\n	6. @\r\n</p>\r\n<p>\r\n	用于定义一个 Location块，且该块不能被外部Client 所访问，只能被Nginx内部配置指令所访问，比如try_files 或 error_page\r\n</p>\r\n<p>\r\n	location @resize {\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/cache/(.*)?(.*)$ /resize.php?dir=$1&amp;path=$2$3;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/orgi/cert/(.*)?(.*)$ /pass/resize?dir=$1&amp;type=cert&amp;path=$2$3&amp;is_orgi=true;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/orgi/card/(.*)?(.*)$ /pass/resize?dir=$1&amp;type=card&amp;path=$2$3&amp;is_orgi=true;\r\n</p>\r\n<p>\r\n	rewrite ^/(.*)/orgi/(.*)/(.*)?(.*)$ /pass/resize?dir=$1&amp;type=$2&amp;path=$3$4&amp;is_orgi=true;\r\n</p>\r\n<p>\r\n	include fastcgi_params;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如下示例：\r\n</p>\r\n<p>\r\n	#通用匹配\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/web/;\r\n</p>\r\n<p>\r\n	autoindex on;\r\n</p>\r\n<p>\r\n	autoindex_exact_size off;\r\n</p>\r\n<p>\r\n	autoindex_localtime on;\r\n</p>\r\n<p>\r\n	access_log /var/www/log/nginx/access.log;\r\n</p>\r\n<p>\r\n	error_log /var/www/log/nginx/error.log;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	＃正则匹配\r\n</p>\r\n<p>\r\n	＃proxy the php scripts to php-fpm\r\n</p>\r\n<p>\r\n	location ~ \\.php(.*)$  {\r\n</p>\r\n<p>\r\n	root /var/www/web/;\r\n</p>\r\n<p>\r\n	fastcgi_pass 127.0.0.1:9000;\r\n</p>\r\n<p>\r\n	fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\r\n</p>\r\n<p>\r\n	fastcgi_index index.php;\r\n</p>\r\n<p>\r\n	include fastcgi_params;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 300;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#精确匹配\r\n</p>\r\n<p>\r\n	location = /hello.php {\r\n</p>\r\n<p>\r\n	root /var/www/web/;\r\n</p>\r\n<p>\r\n	rewrite ^(.*)$ http://www.wangshibo.com  redirect;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	产生的效果如下：\r\n</p>\r\n<p>\r\n	访问根目录/，匹配到location /\r\n</p>\r\n<p>\r\n	访问除hello.php之外的其它php程序，匹配到location ~ \\.php$,并且用php5-fpm去运行\r\n</p>\r\n<p>\r\n	访问hello.php，匹配到location = /hello.php,访问被重定向到http://www.wangshibo.com\r\n</p>\r\n<p>\r\n	3）location搜索优先级顺序如何？\r\n</p>\r\n<p>\r\n	精确匹配 &gt; 字符串匹配( 长 &gt; 短 [ 注: ^~ 匹配则停止匹配 ]) &gt; 正则匹配( 上 &gt; 下 )\r\n</p>\r\n<p>\r\n	在nginx的location和配置中location的顺序没有太大关系。正location表达式的类型有关。相同类型的表达式，字符串长的会优先匹配。\r\n</p>\r\n<p>\r\n	优先级排列：\r\n</p>\r\n<p>\r\n	1）等号类型（=）的精确匹配优先级最高，精确匹配只能命中一个。一旦匹配成功，则不再查找其他匹配项。\r\n</p>\r\n<p>\r\n	2）^~类型表达式，即字符串匹配，使用匹配最长的最为匹配结果。一旦匹配成功，则不再查找其他匹配项。\r\n</p>\r\n<p>\r\n	3）正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。\r\n</p>\r\n<p>\r\n	4）常规字符串匹配类型。按前缀匹配。\r\n</p>\r\n<p>\r\n	特别注意：\r\n</p>\r\n<p>\r\n	字符串匹配优先搜索，但是只是记录下最长的匹配 (如果 ^~ 是最长的匹配，则会直接命中，停止搜索正则)，然后继续搜索正则匹配，如果有正则匹配，则命中正则匹配，如果没有正则匹配，则命中最长的字符串匹配.\r\n</p>\r\n<p>\r\n	实例说明：\r\n</p>\r\n<p>\r\n	1）先来测试下区分大小写和不区分大小写的优先级.如下：\r\n</p>\r\n<p>\r\n	location ~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 501\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~* /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果为：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt ------------501\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5B.txt ------------504\r\n</p>\r\n<p>\r\n	将顺序反下，将~*放前面\r\n</p>\r\n<p>\r\n	location ~＊ /5b.txt {\r\n</p>\r\n<p>\r\n	return 501\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果为：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt ------------501\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5B.txt ------------501\r\n</p>\r\n<p>\r\n	结论： 去分和不区分大小写的正则匹配优先级相同，以先后顺序来决定匹配哪一个.\r\n</p>\r\n<p>\r\n	2）再来比较=与~的优先级\r\n</p>\r\n<p>\r\n	location ＝ /5b.txt {\r\n</p>\r\n<p>\r\n	return 502\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果为：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt -------------502\r\n</p>\r\n<p>\r\n	结论：=的优先级比~高\r\n</p>\r\n<p>\r\n	3）再来比较下 ^~ 与 ~的优先级\r\n</p>\r\n<p>\r\n	location ~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 502\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果为：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt  --------------504\r\n</p>\r\n<p>\r\n	结论：^~的优先级比~高\r\n</p>\r\n<p>\r\n	4）再测试 ^~ 与 = 的优先级\r\n</p>\r\n<p>\r\n	location ^~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 502\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ＝ /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt  --------------504\r\n</p>\r\n<p>\r\n	结论：=的优先级比 ^~高\r\n</p>\r\n<p>\r\n	5）再来测试^~同级之间的优先级\r\n</p>\r\n<p>\r\n	location ^~ 5b.txt {\r\n</p>\r\n<p>\r\n	return 502\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /3a/ {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt  --------------504\r\n</p>\r\n<p>\r\n	结论 ：^~优先匹配的是从根开始的匹配\r\n</p>\r\n<p>\r\n	6）再来看空格（即什么都不加）与~的优先级比较\r\n</p>\r\n<p>\r\n	location /5b.txt {\r\n</p>\r\n<p>\r\n	return 502\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ /5b.txt {\r\n</p>\r\n<p>\r\n	return 504\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	测试结果为：\r\n</p>\r\n<p>\r\n	http://192.168.1.80/5b.txt  --------------504\r\n</p>\r\n<p>\r\n	结论：空格的优先级比~低\r\n</p>\r\n<p>\r\n	优先级排序为：\r\n</p>\r\n<p>\r\n	空格（即不加）\r\n</p>\r\n<p>\r\n	~与*~正则匹配的优先级按先后次序来决定的\r\n</p>\r\n<p>\r\n	^~同级之间的匹配是按照根目录顺序来的\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	再来看看下面的例子：\r\n</p>\r\n<p>\r\n	1）精确匹配，即“＝”\r\n</p>\r\n<p>\r\n	location = /images/test.png {\r\n</p>\r\n<p>\r\n	echo \'config1\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /images/test.png {\r\n</p>\r\n<p>\r\n	echo \'config2\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location \\/images\\/test\\.png$ {\r\n</p>\r\n<p>\r\n	echo \'config3\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如果此时请求 http://127.0.0.1/images/test.png 输出的内容是config1, 毋容置疑，精确匹配优先级最高！\r\n</p>\r\n<p>\r\n	2）精确匹配的特殊情况\r\n</p>\r\n<p>\r\n	location = / {\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	echo \'config2\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	此时输入http://127.0.0.1 输出的内容是config2, 怎么精确匹配的优先级不灵了呢？\r\n</p>\r\n<p>\r\n	是这样的，精确匹配还是起作用了，请求目录(非具体文件)，nginx会将请求内部定向到index文件，\r\n</p>\r\n<p>\r\n	既此时真正的请求是http://127.0.0.1/index.html, 这是config2则被命中!\r\n</p>\r\n<p>\r\n	所以精确匹配不要用来匹配/\r\n</p>\r\n<p>\r\n	3）字符串搜索与正则搜索\r\n</p>\r\n<p>\r\n	location /images/test.png {\r\n</p>\r\n<p>\r\n	echo \'config1\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /images/ {\r\n</p>\r\n<p>\r\n	echo \'config2\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ \\/images\\/test\\.png$ {\r\n</p>\r\n<p>\r\n	echo \'config3\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ \\/images\\/ {\r\n</p>\r\n<p>\r\n	echo \'config4\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如果此时请求http://127.0.0.1/images/test.png 输出的内容是config3，正则命中。\r\n</p>\r\n<p>\r\n	(虽然config1为最长匹配的字符串，此时只做记录，后面还要搜索正则匹配，则config3正则匹配命中),\r\n</p>\r\n<p>\r\n	仔细观察可以发现config4也被匹配成功了，但是正则的匹配顺序是按照location的定义顺序匹配的，所以config3命中.\r\n</p>\r\n<p>\r\n	4）字符串匹配优先级的提升( ^~ )\r\n</p>\r\n<p>\r\n	location /images/ {\r\n</p>\r\n<p>\r\n	echo \'config1\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ^~ /images/test.png {\r\n</p>\r\n<p>\r\n	echo \'config2\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ /images/test\\.png$ {\r\n</p>\r\n<p>\r\n	echo \'config3\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~ \\/images\\/ {\r\n</p>\r\n<p>\r\n	echo \'config4\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	如果此时请求 http://127.0.0.1/images/test.png 输出的内容是config2, 首部匹配命中。\r\n</p>\r\n<p>\r\n	(因为字符串匹配是优先搜索的，此时发现config2 为最长的字符串匹配且为^~匹配方式，所以停止搜索正则，直接命中！)\r\n</p>\r\n<p>\r\n	所以这里的 ^~ 符号比较特殊，就是为了提高字符串匹配的优先级，优先于正则匹配.\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	/ 通用匹配，任何请求都会匹配到。\r\n</p>\r\n<p>\r\n	多个location配置的情况下，需要遵循：\r\n</p>\r\n<p>\r\n	首先匹配=\r\n</p>\r\n<p>\r\n	其次匹配^~\r\n</p>\r\n<p>\r\n	再其次按照配置文件的顺序进行正则匹配、\r\n</p>\r\n<p>\r\n	最后是交给/进行通用匹配\r\n</p>\r\n<p>\r\n	注意：当有匹配成功时，立刻停止匹配，按照当前匹配规则处理请求\r\n</p>\r\n<p>\r\n	看看下面匹配规则：\r\n</p>\r\n<p>\r\n	#规则A\r\n</p>\r\n<p>\r\n	location = / {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则B\r\n</p>\r\n<p>\r\n	location = /login {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则C\r\n</p>\r\n<p>\r\n	location ^~ /static/ {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则D\r\n</p>\r\n<p>\r\n	location ~ \\.(gif|jpg|png|js|css)$ {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则E\r\n</p>\r\n<p>\r\n	location ~* \\.png$ {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则F\r\n</p>\r\n<p>\r\n	location !~ \\.xhtml$ {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则G\r\n</p>\r\n<p>\r\n	location !~* \\.xhtml$ {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#规则H\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	那么产生的效果如下：\r\n</p>\r\n<p>\r\n	1）访问根目录/， 比如http://localhost/ 将匹配规则A\r\n</p>\r\n<p>\r\n	2）访问 http://localhost/login 将匹配规则B，http://localhost/register 则匹配规则H\r\n</p>\r\n<p>\r\n	3）访问 http://localhost/static/a.html 将匹配规则C\r\n</p>\r\n<p>\r\n	4）访问 http://localhost/a.gif, http://localhost/b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 http://localhost/static/c.png 则优先匹配到规则C\r\n</p>\r\n<p>\r\n	5）访问 http://localhost/a.PNG 则匹配规则E，而不会匹配规则D，因为规则E不区分大小写。\r\n</p>\r\n<p>\r\n	6）访问 http://localhost/a.xhtml 不会匹配规则F和规则G，http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。\r\n</p>\r\n<p>\r\n	7）访问 http://localhost/category/id/1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。\r\n</p>\r\n<p>\r\n	注意：在实际使用中，至少清楚下面匹配规则\r\n</p>\r\n<p>\r\n	1）直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。\r\n</p>\r\n<p>\r\n	2）这里是直接转发给后端应用服务器了，也可以是一个静态首页\r\n</p>\r\n<p>\r\n	第一个必选规则：\r\n</p>\r\n<p>\r\n	location = / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcat:8080/index\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\r\n</p>\r\n<p>\r\n	有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\r\n</p>\r\n<p>\r\n	location ^~ /static/ {\r\n</p>\r\n<p>\r\n	root /webroot/static/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\r\n</p>\r\n<p>\r\n	root /webroot/res/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	第三个规则就是通用规则，用来转发动态请求到后端应用服务器\r\n</p>\r\n<p>\r\n	非静态文件请求就默认是动态请求，自己根据实际把握\r\n</p>\r\n<p>\r\n	毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://tomcat:8080/\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	看看下面几个设置\r\n</p>\r\n<p>\r\n	# 重写跳转\r\n</p>\r\n<p>\r\n	rewrite  \"^/conference/([^/]+)$\" /con_detail.php?con_title=$1 last;\r\n</p>\r\n<p>\r\n	rewrite  \"^/conference/([^/]+)/$\" /con_detail.php?con_title=$1 last;\r\n</p>\r\n<p>\r\n	#屏蔽爬虫\r\n</p>\r\n<p>\r\n	if ($http_user_agent ~* \"qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot\")\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	return 403;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#favicon.ico不用打日志\r\n</p>\r\n<p>\r\n	location = /favicon.ico {\r\n</p>\r\n<p>\r\n	log_not_found off;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#不允许访问隐藏文件\r\n</p>\r\n<p>\r\n	location ~ /\\. {\r\n</p>\r\n<p>\r\n	deny all;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	log_not_found off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#访问图片，flash文件等不用打日志\r\n</p>\r\n<p>\r\n	location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\r\n</p>\r\n<p>\r\n	expires      7d; #文件返回的过期时间是7天\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#访问js和css文件不用打日志\r\n</p>\r\n<p>\r\n	location ~ .*\\.(js|css)?$ {\r\n</p>\r\n<p>\r\n	expires      1d; #文件返回的过期时间是1天\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	#设置php-cgi\r\n</p>\r\n<p>\r\n	location ~ [^/]\\.php(/|$) {\r\n</p>\r\n<p>\r\n	fastcgi_split_path_info ^(.+?\\.php)(/.*)$;\r\n</p>\r\n<p>\r\n	#拦截不存在的php页面请求\r\n</p>\r\n<p>\r\n	if (!-f $document_root$fastcgi_script_name) {\r\n</p>\r\n<p>\r\n	return 404;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('9d45b00b-cbbe-40ed-8c30-d00e5e816eb4','Nginx负载均衡中后端节点服务器健康检查的操作梳理','Nginx负载均衡中后端节点服务器健康检查的操作梳理','<p>\r\n	正常情况下，nginx做反向代理，如果后端节点服务器宕掉的话，nginx默认是不能把这台realserver踢出upstream负载集群的，所以还会有请求转发到后端的这台realserver上面，这样势必造成网站访问故障。虽然nginx可以在localtion中启用proxy_next_upstream来解决返回给用户的错误页面，如下：\r\n</p>\r\n<p>\r\n	例如公司的网站访问的时候全部变成404页面，最好发现是后端的一台服务器不可用，直接访问那台后台的服务器的时候，返回的是404页面，因为upstream 里面设置了ip_hash。所以导致访问网站时怎么刷新都是404页面。这时可以使用nginx的一个功能，就是当后端的服务器返回给nginx502、504、404、执行超时等错误状态的时候，nginx会自动再把这个请求转发到upstream里面别的服务器上面，从而给网站用户提供更稳定的服务。\r\n</p>\r\n<p>\r\n	配置如下：\r\n</p>\r\n<p>\r\n	location /\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	#如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。\r\n</p>\r\n<p>\r\n	proxy_next_upstream http_502 http_504 http_404 error timeout invalid_header;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样的话，也算是保障了后端服务器的一个高可用性。（下面实例配置中会用到）\r\n</p>\r\n<p>\r\n	以上的配置大家可以参考一下，但这个还是会把请求转发给这台服务器的，然后再转发给别的服务器，这样以来就浪费了一次转发，对于网站性能来说也不是最佳理想的方案。为了避免上面说顾虑的情况，可以对nginx后方realserver的健康状态进行检查，如果发现后端服务器不可用，则请求不转发到这台服务器。目前主要有三种方式可以实现对nginx负载均衡的后端节点服务器进行健康检查：1）ngx_http_proxy_module模块和ngx_http_upstream_module模块（这是nginx自带模块）&nbsp; &nbsp; 参考地址：http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream2）nginx_upstream_check_module模块（淘宝技术团队开发）&nbsp; &nbsp; 参考地址：https://github.com/yaoweibin/nginx_upstream_check_module3）ngx_http_healthcheck_module模块------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	一、利用nginx自带模块ngx_http_proxy_module和ngx_http_upstream_module对后端节点做健康检查严格来说，nginx自带是没有针对负载均衡后端节点的健康检查的，但是可以通过默认自带的ngx_http_proxy_module模块和ngx_http_upstream_module模块中的相关指令来完成当后端节点出现故障时，自动切换到健康节点来提供访问。下面列出这两个模块中相关的指令：\r\n</p>\r\n<p>\r\n	1）ngx_http_proxy_module模块中的 proxy_connect_timeout指令、proxy_read_timeout指令和proxy_next_upstream指令\r\n</p>\r\n<p>\r\n	语法:   proxy_connect_timeout time;\r\n</p>\r\n<p>\r\n	默认值:  proxy_connect_timeout 60s;\r\n</p>\r\n<p>\r\n	上下文:  http, server, location\r\n</p>\r\n<p>\r\n	设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。\r\n</p>\r\n<p>\r\n	语法: proxy_read_timeout time;\r\n</p>\r\n<p>\r\n	默认值:  proxy_read_timeout 60s;\r\n</p>\r\n<p>\r\n	上下文:  http, server, location\r\n</p>\r\n<p>\r\n	定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	语法: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 |http_404 | off ...;\r\n</p>\r\n<p>\r\n	默认值:  proxy_next_upstream error timeout;\r\n</p>\r\n<p>\r\n	上下文:  http, server, location\r\n</p>\r\n<p>\r\n	指定在何种情况下一个失败的请求应该被发送到下一台后端服务器：\r\n</p>\r\n<p>\r\n	error      和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误\r\n</p>\r\n<p>\r\n	timeout    和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时\r\n</p>\r\n<p>\r\n	invalid_header  后端服务器返回空响应或者非法响应头\r\n</p>\r\n<p>\r\n	http_500   后端服务器返回的响应状态码为500\r\n</p>\r\n<p>\r\n	http_502   后端服务器返回的响应状态码为502\r\n</p>\r\n<p>\r\n	http_503   后端服务器返回的响应状态码为503\r\n</p>\r\n<p>\r\n	http_504   后端服务器返回的响应状态码为504\r\n</p>\r\n<p>\r\n	http_404   后端服务器返回的响应状态码为404\r\n</p>\r\n<p>\r\n	off        停止将请求发送给下一台后端服务器\r\n</p>\r\n<p>\r\n	需要理解一点的是，只有在没有向客户端发送任何数据以前，将请求转给下一台后端服务器才是可行的。也就是说，如果在传输响应到客户端时出现错误或者超时，这类错误是不可能恢复的。\r\n</p>\r\n<p>\r\n	范例如下（这个在文档开头已介绍）：\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	proxy_next_upstream http_502 http_504 http_404 error timeout invalid_header;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）ngx_http_upstream_module模块中的server指令\r\n</p>\r\n<p>\r\n	语法: server address [parameters];\r\n</p>\r\n<p>\r\n	默认值:  ―\r\n</p>\r\n<p>\r\n	上下文:  upstream\r\n</p>\r\n<p>\r\n	范例如下：\r\n</p>\r\n<p>\r\n	upstream name {\r\n</p>\r\n<p>\r\n	server 10.1.1.110:8080 max_fails=1 fail_timeout=10s;\r\n</p>\r\n<p>\r\n	server 10.1.1.122:8080 max_fails=1 fail_timeout=10s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	--------------指令参数解释----------------\r\n</p>\r\n<p>\r\n	max_fails=number   设定Nginx与服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不可用。在下一个fail_timeout时间段，服务器不会再被尝试。\r\n</p>\r\n<p>\r\n	失败的尝试次数默认是1。设为0就会停止统计尝试次数，即不对后端节点进行健康检查。认为服务器是一直可用的。\r\n</p>\r\n<p>\r\n	fail_timeout=time  设定服务器被认为不可用的时间段以及统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。\r\n</p>\r\n<p>\r\n	默认情况下，该超时时间是10秒。\r\n</p>\r\n<p>\r\n	在实际应用当中：\r\n</p>\r\n<p>\r\n	1）如果后端应用是能够快速重启的应用，比如nginx的话，自带的模块是可以满足需求的。\r\n</p>\r\n<p>\r\n	但是需要注意，如果后端有不健康节点，负载均衡器依然会先把该请求转发给该不健康节点，然后再转发给别的节点，这样就会浪费一次转发。\r\n</p>\r\n<p>\r\n	2）如果当后端应用重启时，重启操作需要很久才能完成的时候就会有可能拖死整个负载均衡器。\r\n</p>\r\n<p>\r\n	此时，由于无法准确判断节点健康状态，导致请求handle住，出现假死状态，最终整个负载均衡器上的所有节点都无法正常响应请求。\r\n</p>\r\n<p>\r\n	比如公司的业务程序是java开发的，因此后端主要是nginx集群和tomcat集群。由于tomcat重启应部署上面的业务不同，有些业务启动初始化时间过长，就会导致上述现象的发生，因此不是很建议使用该模式。\r\n</p>\r\n<p>\r\n	并且ngx_http_upstream_module模块中的server指令中的max_fails参数设置值，也会和ngx_http_proxy_module 模块中的的proxy_next_upstream指令设置起冲突。\r\n</p>\r\n<p>\r\n	如果将max_fails设置为0，则代表不对后端服务器进行健康检查，这样还会使fail_timeout参数失效（即不起作用）。\r\n</p>\r\n<p>\r\n	此时判断后端服务器情况的唯一依据便是ngx_http_proxy_module模块中的proxy_connect_timeout指令和proxy_read_timeout指令，通过将它们的值调低来发现不健康节点，进而将请求往健康节点转移。\r\n</p>\r\n<p>\r\n	如果这两个参数设置得过小，但后端程序的执行或多或少会超过这个时间的话，这种情况nginx的效率是非常低的。\r\n</p>\r\n<p>\r\n	具体实例配置如下：\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	user  www;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  notice;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  info;\r\n</p>\r\n<p>\r\n	#pid        logs/nginx.pid;\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	######\r\n</p>\r\n<p>\r\n	## set access log format\r\n</p>\r\n<p>\r\n	######\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	## http setting\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	proxy_cache_path /var/www/cache levels=1:2 keys_zone=mycache:20m max_size=2048m inactive=60m;\r\n</p>\r\n<p>\r\n	proxy_temp_path /var/www/cache/tmp;\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	# client_max_body_size 50m;\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;               #允许客户端请求的最大单个文件字节数\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;            #缓冲区代理缓冲请求的最大字节数，可以理解为先保存到本地再传给用户\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	## includes vhosts\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@master-node ~]# mkdir /usr/local/nginx/conf/vhosts\r\n</p>\r\n<p>\r\n	[root@master-node ~]# mkdir /var/www/cache\r\n</p>\r\n<p>\r\n	[root@master-node ~]# ulimit 65535\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /usr/local/nginx/conf/vhosts/LB.conf\r\n</p>\r\n<p>\r\n	upstream LB-WWW {\r\n</p>\r\n<p>\r\n	ip_hash;                                                  #这是对负载均衡的算法\r\n</p>\r\n<p>\r\n	server 192.168.1.101:80 max_fails=3 fail_timeout=30s;     #max_fails = 3 为允许失败的次数，默认值为1。 这是对后端节点做健康检查。\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80 max_fails=3 fail_timeout=30s;     #fail_timeout = 30s 当max_fails次失败后，暂停将请求分发到该后端服务器的时间\r\n</p>\r\n<p>\r\n	server 192.168.1.118:80 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/www-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/www-error.log;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-WWW;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;             #跟后端服务器连接超时时间，发起握手等候响应时间\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;                #后端服务器回传时间，就是在规定时间内后端服务器必须传完所有数据\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;                #连接成功后等待后端服务器的响应时间，已经进入后端的排队之中等候处理\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;                #代理请求缓冲区,会保存用户的头信息以供nginx进行处理\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;                  #同上，告诉nginx保存单个用几个buffer最大用多少空间\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;          #如果系统很忙时候可以申请最大的proxy_buffers\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;       #proxy缓存临时文件的大小\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	二、利用nginx_upstream_check_module模块对后端节点做健康检查除了上面介绍的nginx自带模块，还有一个更专业的模块，来专门提供负载均衡器内节点的健康检查的。这个就是淘宝技术团队开发的nginx模块nginx_upstream_check_module，通过它可以用来检测后端realserver的健康状态。如果后端realserver不可用，则所以的请求就不会转发到该节点上。个人比较推荐使用这种方式来检查nginx后端节点的健康状态。\r\n</p>\r\n<p>\r\n	在淘宝自己的tengine上是自带了该模块的，大家可以访问淘宝tengine的官网http://tengine.taobao.org来获取该版本的nginx，如果没有使用淘宝的tengine的话，可以通过补丁的方式来添加该模块到我们自己的nginx中。部署流程如下：\r\n</p>\r\n<p>\r\n	比如健康检查配置：\r\n</p>\r\n<p>\r\n	upstream test_web {\r\n</p>\r\n<p>\r\n	server 192.168.1.21:80;\r\n</p>\r\n<p>\r\n	server 192.168.1.22:80;\r\n</p>\r\n<p>\r\n	check interval=3000 rise=2 fall=5 timeout=1000 type=http;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	上面配置的意思是，对test_web这个负载均衡条目中的所有节点，每个3秒检测一次，请求2次正常则标记realserver状态为up，如果检测5次都失败，则标记realserver的状态为down，超时时间为1秒。\r\n</p>\r\n<p>\r\n	---------------------下面列出nginx_upstream_check_module 模块所支持的指令含义----------------------\r\n</p>\r\n<p>\r\n	Syntax:  check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [default_down=true|false] [type=tcp|http|ssl_hello|mysql|ajp] [port=check_port]\r\n</p>\r\n<p>\r\n	Default: 如果没有配置参数，默认值是：interval=30000 fall=5 rise=2 timeout=1000 default_down=true type=tcp\r\n</p>\r\n<p>\r\n	Context: upstream\r\n</p>\r\n<p>\r\n	该指令可以打开后端服务器的健康检查功能。指令后面的参数意义是：\r\n</p>\r\n<p>\r\n	interval：向后端发送的健康检查包的间隔。\r\n</p>\r\n<p>\r\n	fall(fall_count): 如果连续失败次数达到fall_count，服务器就被认为是down。\r\n</p>\r\n<p>\r\n	rise(rise_count): 如果连续成功次数达到rise_count，服务器就被认为是up。\r\n</p>\r\n<p>\r\n	timeout: 后端健康请求的超时时间。\r\n</p>\r\n<p>\r\n	default_down: 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。默认值是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。\r\n</p>\r\n<p>\r\n	type：健康检查包的类型，现在支持以下多种类型\r\n</p>\r\n<p>\r\n	tcp：简单的tcp连接，如果连接成功，就说明后端正常。\r\n</p>\r\n<p>\r\n	ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包。\r\n</p>\r\n<p>\r\n	http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活。\r\n</p>\r\n<p>\r\n	mysql: 向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活。\r\n</p>\r\n<p>\r\n	ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活。\r\n</p>\r\n<p>\r\n	port: 指定后端服务器的检查端口。你可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，表示跟后端server提供真实服务的端口一样。该选项出现于Tengine-1.4.0。\r\n</p>\r\n<p>\r\n	Syntax: check_keepalive_requests request_num\r\n</p>\r\n<p>\r\n	Default: 1\r\n</p>\r\n<p>\r\n	Context: upstream\r\n</p>\r\n<p>\r\n	该指令可以配置一个连接发送的请求数，其默认值为1，表示Tengine完成1次请求后即关闭连接。\r\n</p>\r\n<p>\r\n	Syntax: check_http_send http_packet\r\n</p>\r\n<p>\r\n	Default: \"GET / HTTP/1.0\\r\\n\\r\\n\"\r\n</p>\r\n<p>\r\n	Context: upstream\r\n</p>\r\n<p>\r\n	该指令可以配置http健康检查包发送的请求内容。为了减少传输数据量，推荐采用\"HEAD\"方法。\r\n</p>\r\n<p>\r\n	当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，如：\"HEAD / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n\"。 同时，在采用\"GET\"方法的情况下，请求uri的size不宜过大，确保可以在1个interval内传输完成，否则会被健康检查模块视为后端服务器或网络异常。\r\n</p>\r\n<p>\r\n	Syntax: check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]\r\n</p>\r\n<p>\r\n	Default: http_2xx | http_3xx\r\n</p>\r\n<p>\r\n	Context: upstream\r\n</p>\r\n<p>\r\n	该指令指定HTTP回复的成功状态，默认认为2XX和3XX的状态是健康的。\r\n</p>\r\n<p>\r\n	Syntax: check_shm_size size\r\n</p>\r\n<p>\r\n	Default: 1M\r\n</p>\r\n<p>\r\n	Context: http\r\n</p>\r\n<p>\r\n	所有的后端服务器健康检查状态都存于共享内存中，该指令可以设置共享内存的大小。默认是1M，如果你有1千台以上的服务器并在配置的时候出现了错误，就可能需要扩大该内存的大小。\r\n</p>\r\n<p>\r\n	Syntax: check_status [html|csv|json]\r\n</p>\r\n<p>\r\n	Default: check_status html\r\n</p>\r\n<p>\r\n	Context: location\r\n</p>\r\n<p>\r\n	显示服务器的健康状态页面。该指令需要在http块中配置。\r\n</p>\r\n<p>\r\n	在Tengine-1.4.0以后，可以配置显示页面的格式。支持的格式有: html、csv、 json。默认类型是html。\r\n</p>\r\n<p>\r\n	也可以通过请求的参数来指定格式，假设‘/status’是你状态页面的URL， format参数改变页面的格式，比如：\r\n</p>\r\n<p>\r\n	/status?format=html\r\n</p>\r\n<p>\r\n	/status?format=csv\r\n</p>\r\n<p>\r\n	/status?format=json\r\n</p>\r\n<p>\r\n	同时你也可以通过status参数来获取相同服务器状态的列表，比如：\r\n</p>\r\n<p>\r\n	/status?format=html&amp;status=down\r\n</p>\r\n<p>\r\n	/status?format=csv&amp;status=up\r\n</p>\r\n<p>\r\n	下面是一个状态配置的范例：\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	location /nstatus {\r\n</p>\r\n<p>\r\n	check_status;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	#allow IP;\r\n</p>\r\n<p>\r\n	#deny all;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	具体实例配置如下：\r\n</p>\r\n<p>\r\n	1）下载nginx_upstream_check_module模块，并部署到nginx中。\r\n</p>\r\n<p>\r\n	[root@localhost ~]# cd /usr/local/src\r\n</p>\r\n<p>\r\n	[root@localhost src]# wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/master.zip\r\n</p>\r\n<p>\r\n	[root@localhost src]# unzip unzip master.zip\r\n</p>\r\n<p>\r\n	[root@localhost src]# ls\r\n</p>\r\n<p>\r\n	master.zip  nginx_upstream_check_module-master\r\n</p>\r\n<p>\r\n	[root@localhost src]# ls nginx_upstream_check_module-master/\r\n</p>\r\n<p>\r\n	CHANGES              check_1.2.6+.patch   check.patch                ngx_http_upstream_check_module.c          upstream_fair.patch\r\n</p>\r\n<p>\r\n	check_1.11.1+.patch  check_1.5.12+.patch  config                     ngx_http_upstream_check_module.h          util\r\n</p>\r\n<p>\r\n	check_1.11.5+.patch  check_1.7.2+.patch   doc                        ngx_http_upstream_jvm_route_module.patch\r\n</p>\r\n<p>\r\n	check_1.2.1.patch    check_1.7.5+.patch   nginx-sticky-module.patch  README\r\n</p>\r\n<p>\r\n	check_1.2.2+.patch   check_1.9.2+.patch   nginx-tests                test\r\n</p>\r\n<p>\r\n	[root@localhost src]# wget http://nginx.org/download/nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@localhost src]# tar -zxvf nginx-1.8.0.tar.gz\r\n</p>\r\n<p>\r\n	[root@localhost src]# cd nginx-1.8.0\r\n</p>\r\n<p>\r\n	[root@localhost nginx-1.8.0]# patch -p1 &lt; ../nginx_upstream_check_module-master/check_1.9.2+.patch\r\n</p>\r\n<p>\r\n	[root@localhost nginx-1.8.0]# ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --add-module=../nginx_upstream_check_module-master/\r\n</p>\r\n<p>\r\n	[root@node1 src]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	2)nginx配置\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /usr/local/nginx/conf/vhosts/LB.conf\r\n</p>\r\n<p>\r\n	upstream LB-WWW {\r\n</p>\r\n<p>\r\n	server 192.168.1.101:80;\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80;\r\n</p>\r\n<p>\r\n	check interval=3000 rise=2 fall=5 timeout=1000 type=http;\r\n</p>\r\n<p>\r\n	check_keepalive_requests 100;\r\n</p>\r\n<p>\r\n	check_http_send \"HEAD / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\r\n</p>\r\n<p>\r\n	check_http_expect_alive http_2xx http_3xx;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/www-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/www-error.log;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-WWW;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /nstatus {\r\n</p>\r\n<p>\r\n	check_status;\r\n</p>\r\n<p>\r\n	access_log off;\r\n</p>\r\n<p>\r\n	#allow IP;\r\n</p>\r\n<p>\r\n	#deny all;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	配置完毕后，重启nginx。然后访问http://localhost/nstatus这个页面就可以看到当前两台realserver实时的健康状态。温馨提示：在生产环境的实施应用中需要注意下面两点\r\n</p>\r\n<p>\r\n	1）主要定义好type。由于默认的type是tcp类型，因此假设服务启动，不管是否初始化完毕，它的端口都会起来，所以此时前段负载均衡器为认为该服务已经可用，其实是不可用状态。\r\n</p>\r\n<p>\r\n	2）注意check_http_send值的设定。由于它的默认值是\"GET / HTTP/1.0\\r\\n\\r\\n\"。\r\n</p>\r\n<p>\r\n	假设应用是通过http://ip/name访问的，那么这里check_http_send值就需要更改为 \"GET /name HTTP/1.0\\r\\n\\r\\n\"才可以。\r\n</p>\r\n<p>\r\n	针对采用长连接进行检查的， 这里增加 keep-alive请求 头，即\"HEAD /name HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n\"。\r\n</p>\r\n<p>\r\n	如果后端的tomcat是基于域名的多虚拟机，此时你需要通过 check_http_send定义host，不然每次访问都是失败，范例：\r\n</p>\r\n<p>\r\n	check_http_send \"GET /mobileapi HTTP/1.0\\r\\n HOST  www.redhat.sx\\r\\n\\r\\n\";\r\n</p>\r\n<p>\r\n	也可以参考http://www.cnblogs.com/kevingrace/p/5882006.html这篇文档里的nginx后端节点健康检查的方法\r\n</p>\r\n<p>\r\n	三、利用ngx_http_healthcheck_module模块对后端节点做健康检查除了上面两个模块，nginx官方在早期的时候还提供了一个ngx_http_healthcheck_module模块用来进行nginx后端节点的健康检查。nginx_upstream_check_module模块就是参照该模块的设计理念进行开发的，因此在使用和效果上都大同小异。但是需要注意的是，ngx_http_healthcheck_module模块仅仅支持nginx的1.0.0版本，1.1.0版本以后都不支持了！因此，对于目前常见的生产环境上基本都不会去用这个模块了～\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('9ef4b265-6cfb-40bd-8216-5baaffcb78bf','mysql启动后随即关闭问题解决（ibdata1文件损坏导致）','mysql启动后随即关闭问题解决（ibdata1文件损坏导致）','<p>\r\n	机房一台服务器上的mysql运行一段时间了，突然出现了一个很奇怪的现象：重启后无法恢复了！准确情况是：启动mysql后随即就又关闭了。\r\n</p>\r\n<p>\r\n	查看mysql错误日志如下：\r\n</p>\r\n<p>\r\n	160920 22:41:41 mysqld_safe Starting mysqld daemon with databases from /home/MysqlData/2016-09-20 22:41:41 0 [Note] /Data/app/mysql5.6.25/bin/mysqld (mysqld 5.6.25-log) starting as process 32372 ...2016-09-20 22:41:42 32372 [Note] Plugin \'FEDERATED\' is disabled.2016-09-20 22:41:42 32372 [Warning] option \'innodb-write-io-threads\': unsigned value 1000 adjusted to 642016-09-20 22:41:42 32372 [Warning] option \'innodb-read-io-threads\': unsigned value 1000 adjusted to 642016-09-20 22:41:42 32372 [Note] InnoDB: Using atomics to ref count buffer pool pages2016-09-20 22:41:42 32372 [Note] InnoDB: The InnoDB memory heap is disabled2016-09-20 22:41:42 32372 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins2016-09-20 22:41:42 32372 [Note] InnoDB: Memory barrier is not used2016-09-20 22:41:42 32372 [Note] InnoDB: Compressed tables use zlib 1.2.32016-09-20 22:41:42 32372 [Note] InnoDB: Using CPU crc32 instructions2016-09-20 22:41:42 32372 [Note] InnoDB: Initializing buffer pool, size = 1.0G2016-09-20 22:41:42 32372 [Note] InnoDB: Completed initialization of buffer pool2016-09-20 22:41:42 32372 [Note] InnoDB: Highest supported file format is Barracuda.2016-09-20 22:41:42 32372 [Note] InnoDB: Log scan progressed past the checkpoint lsn 202935879572016-09-20 22:41:42 32372 [Note] InnoDB: Database was not shutdown normally!2016-09-20 22:41:42 32372 [Note] InnoDB: Starting crash recovery.2016-09-20 22:41:42 32372 [Note] InnoDB: Reading tablespace information from the .ibd files...2016-09-20 22:41:42 32372 [Note] InnoDB: Restoring possible half-written data pages 2016-09-20 22:41:42 32372 [Note] InnoDB: from the doublewrite buffer...InnoDB: Doing recovery: scanned up to log sequence number 202935961302016-09-20 22:41:42 32372 [Note] InnoDB: Starting an apply batch of log records to the database...InnoDB: Progress in percent: 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 InnoDB: Apply batch completedInnoDB: Last MySQL binlog file position 0 136254, file name mysql-bin.0000132016-09-20 22:41:43 32372 [Note] InnoDB: 128 rollback segment(s) are active.2016-09-20 22:41:43 32372 [Note] InnoDB: Waiting for purge to start2016-09-20 22:41:43 7f77a9edd700  InnoDB: Assertion failure in thread 140151928772352 in file trx0purge.cc line 699InnoDB: Failing assertion: purge_sys-&gt;iter.trx_no &lt;= purge_sys-&gt;rseg-&gt;last_trx_noInnoDB: We intentionally generate a memory trap.InnoDB: Submit a detailed bug report to http://bugs.mysql.com.InnoDB: If you get repeated assertion failures or crashes, evenInnoDB: immediately after the mysqld startup, there may beInnoDB: corruption in the InnoDB tablespace. Please refer toInnoDB: http://dev.mysql.com/doc/refman/5.6/en/forcing-innodb-recovery.htmlInnoDB: about forcing recovery.02:41:43 UTC - mysqld got signal 6 ;This could be because you hit a bug. It is also possible that this binaryor one of the libraries it was linked against is corrupt, improperly built,or misconfigured. This error can also be caused by malfunctioning hardware.We will try our best to scrape up some info that will hopefully helpdiagnose the problem, but since we have already crashed, something is definitely wrong and this may fail.\r\n</p>\r\n<p>\r\n	分析日志后发现，数据库无法重启的原因是因为ibdata1文件损坏，重启后无法正常恢复。\r\n</p>\r\n<p>\r\n	解决办法：需要跳过恢复步骤，修改my.cnf文件，在my.cnf中的[mysqld]中添加：innodb_force_recovery = 6innodb_purge_threads = 1\r\n</p>\r\n<p>\r\n	解释：innodb_force_recovery可以设置为1-6,大的数字包含前面所有数字的影响。具体数字对应的含义：1-----(SRVFORCEIGNORECORRUPT):忽略检查到的corrupt页。2-----(SRVFORCENOBACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。3-----(SRVFORCENOTRXUNDO):不执行事务回滚操作。4-----(SRVFORCENOIBUFMERGE):不执行插入缓冲的合并操作。5-----(SRVFORCENOUNDOLOGSCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。6-----(SRVFORCENOLOG_REDO):不执行前滚的操作。\r\n</p>\r\n<p>\r\n	再次启动mysql就ok了~如果还无法启动，则需要删除数据目录datafile下的 ibdata1,ib_logfile*等文件。启动后导出MySQL数据库，重新恢复即可。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('a0ebea49-33b2-42b4-ba84-94b5b88cee1d','Nginx反向代理+负载均衡简单实现（https方式）','Nginx反向代理+负载均衡简单实现（https方式）','<p>\r\n	背景：A服务器（192.168.1.8）作为nginx代理服务器B服务器（192.168.1.150）作为后端真实服务器\r\n</p>\r\n<p>\r\n	现在需要访问https://testwww.huanqiu.com请求时从A服务器上反向代理到B服务器上\r\n</p>\r\n<p>\r\n	这就涉及到nginx反向代理https请求的配置了~~~\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------A服务器（192.168.1.8）上的操作流程：\r\n</p>\r\n<p>\r\n	1）编译安装nginx[root@opd ~]# yum install -y pcre pcre-devel openssl openssl-devel gcc [root@opd ~]# cd /usr/loca/src[root@src ~]# wget http://nginx.org/download/nginx-1.8.0.tar.gz[root@src ~]# tar -zxvf nginx-1.8.0.tar.gz[root@src ~]# cd nginx-1.8.0#添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 ~]#useradd www -M -s /sbin/nologin[root@nginx-1.8.0 ~]##vim auto/cc/gcc#将这句注释掉 取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"\r\n</p>\r\n<p>\r\n	#我们再配置下nginx编译参数，编译时一定要添加--with-http_ssl_module，以便让nginx支持ssl功能！[root@nginx-1.8.0 ~]# ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module[root@nginx-1.8.0 ~]#make[root@nginx-1.8.0 ~]#make install clean\r\n</p>\r\n<p>\r\n	2）配置nginx[root@nginx-1.8.0 ~]# cd /usr/local/nginx/conf[root@nginx-1.8.0 conf]# vim nginx.conf\r\n</p>\r\n<p>\r\n	user  nobody;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#error_log logs/error.log;\r\n</p>\r\n<p>\r\n	#error_log logs/error.log notice;\r\n</p>\r\n<p>\r\n	#error_log logs/error.log info;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	## support more than 15 test environments    server_names_hash_max_size 512;    server_names_hash_bucket_size 128;\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@nginx-1.8.0 conf]# ulimit -n 65535[root@nginx-1.8.0 conf]# mkdir vhosts\r\n</p>\r\n<p>\r\n	-----------------------------------------------------接下来手动配置ssl证书如果自己手动颁发证书的话，那么https是不被浏览器认可的，就是https上面会有一个大红叉****************************************************推荐一个免费的网站：https://www.startssl.com/startssl的操作教程看这个：http://www.freehao123.com/startssl-ssl/****************************************************\r\n</p>\r\n<p>\r\n	下面是手动颁发证书的操作：[root@linux-node1 ~]# cd /usr/local/nginx/conf/[root@linux-node1 conf]# mkdir ssl[root@linux-node1 conf]# cd ssl/[root@linux-node1 ssl]# openssl genrsa -des3 -out aoshiwei.com.key 1024Generating RSA private key, 1024 bit long modulus................................++++++....................................++++++e is 65537 (0x10001)Enter pass phrase for aoshiwei.com.key: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#提示输入密码，比如这里我输入123456Verifying - Enter pass phrase for aoshiwei.com.key: &nbsp; &nbsp; #确认密码，继续输入123456\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# ls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #查看，已生成CSR(Certificate Signing Request)文件aoshiwei.com.key\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# openssl req -new -key aoshiwei.com.key -out aoshiwei.com.csrEnter pass phrase for aoshiwei.com.key: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#输入123456You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter \'.\', the field will be left blank.-----Country Name (2 letter code) [XX]:cn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #国家State or Province Name (full name) []:beijing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #省份Locality Name (eg, city) [Default City]:beijing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #地区名字Organization Name (eg, company) [Default Company Ltd]:huanqiu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #公司名Organizational Unit Name (eg, section) []:Technology &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;#部门Common Name (eg, your name or your server\'s hostname) []:huanqiu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#CA主机名Email Address []:wangshibo@xqshijie.cn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#邮箱\r\n</p>\r\n<p>\r\n	Please enter the following \'extra\' attributesto be sent with your certificate requestA challenge password []:123456 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #证书请求密钥，CA读取证书的时候需要输入密码An optional company name []:huanqiu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#-公司名称，CA读取证书的时候需要输入名称\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# lsaoshiwei.com.csr  aoshiwei.com.key\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# cp aoshiwei.com.key aoshiwei.com.key.bak[root@linux-node1 ssl]# openssl rsa -in aoshiwei.com.key.bak -out aoshiwei.com.keyEnter pass phrase for aoshiwei.com.key.bak: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#输入123456writing RSA key[root@linux-node1 ssl]# openssl x509 -req -days 365 -in aoshiwei.com.csr -signkey aoshiwei.com.key -out aoshiwei.com.crtSignature oksubject=/C=cn/ST=beijing/L=beijing/O=huanqiu/OU=Technology/CN=huanqiu/emailAddress=wangshibo@xqshijie.cnGetting Private key[root@linux-node1 ssl]# lltotal 24-rw-r--r-- 1 root root  960 Sep 12 16:01 aoshiwei.com.crt-rw-r--r-- 1 root root  769 Sep 12 15:59 aoshiwei.com.csr-rw-r--r-- 1 root root  887 Sep 12 16:01 aoshiwei.com.key-rw-r--r-- 1 root root  963 Sep 12 16:01 aoshiwei.com.key.bak\r\n</p>\r\n<p>\r\n	然后配置nginx的反向代理：[root@linux-node1 vhosts]# pwd/usr/local/nginx/conf/vhosts[root@linux-node1 vhosts]# cat test.xqshijie.com-ssl.conf upstream 8090  {&nbsp; &nbsp; server 192.168.1.150:8090 max_fails=3 fail_timeout=30s;;&nbsp;    }\r\n</p>\r\n<p>\r\n	server {&nbsp; &nbsp;listen 443;&nbsp; &nbsp;server_name  testwww.huanqiu.com;&nbsp; &nbsp;ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###  &nbsp; &nbsp;access_log      logs/ssl-access.log;           &nbsp; &nbsp;error_log       logs/ssl-error.log;         ### SSL cert files ###  &nbsp; &nbsp;ssl_certificate      ssl/aoshiwei.com.crt; &nbsp; &nbsp; &nbsp;#由于这个证书是自己手动颁发的，是不受信任的，访问时会有个“大叉”提示，但是不影响访问https://testwww.huanqiu.com&nbsp; &nbsp;ssl_certificate_key  ssl/aoshiwei.com.key; &nbsp; #如果是线上环境，可以购买被信任后的证书，拷贝过来使用。&nbsp; &nbsp;ssl_session_timeout  5m;\r\n</p>\r\n<p>\r\n	location  /     {&nbsp; &nbsp;proxy_pass  https://8090; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#这个一定要是https&nbsp; &nbsp;proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;  &nbsp; &nbsp;proxy_set_header Host $host;  &nbsp; &nbsp;proxy_set_header X-Real-IP $remote_addr;  &nbsp; &nbsp;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &nbsp; &nbsp;proxy_set_header X-Forwarded-Proto https;  &nbsp; &nbsp;proxy_redirect     off;        }    }\r\n</p>\r\n<p>\r\n	重启nginx[root@linux-node1 ssl]# /usr/local/nginx/sbin/nginx -t[root@linux-node1 ssl]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# lsof -i:443COMMAND   PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAMEnginx   15755 nobody   24u  IPv4 4717921      0t0  TCP *:https (LISTEN)nginx   15756 nobody   24u  IPv4 4717921      0t0  TCP *:https (LISTEN)nginx   15757 nobody   24u  IPv4 4717921      0t0  TCP *:https (LISTEN)nginx   15758 nobody   24u  IPv4 4717921      0t0  TCP *:https (LISTEN)\r\n</p>\r\n<p>\r\n	A服务器要开启防火墙了，则需要在iptables里开通443端口的访问-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT\r\n</p>\r\n<p>\r\n	[root@linux-node1 ssl]# /etc/init.d/iptables restart\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------后端真实服务器（192.168.1.150）上的nginx配置\r\n</p>\r\n<p>\r\n	[root@dev-new-test1 vhosts]# cat test.xqshijie.com-ssl.conf server {&nbsp; &nbsp;listen       8090; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#这里后端服务器的https没有采用默认的443端口\r\n</p>\r\n<p>\r\n	server_name  testwww.huanqiu.com;&nbsp; &nbsp;root /var/www/vhosts/test.huanqiu.com/httpdocs/main/;\r\n</p>\r\n<p>\r\n	ssl on;&nbsp; &nbsp;ssl_certificate /Data/app/nginx/certificates/xqshijie.cer; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#这是后端服务器上的证书，这个是购买的被信任的证书，可以把它的证书拷贝给上面的代理机器使用&nbsp; &nbsp;ssl_certificate_key /Data/app/nginx/certificates/xqshijie.key; &nbsp; #可以将这两个证书拷给上面192.168.1.8的/usr/loca/nginx/conf/ssl下使用，修改nginx代理配置部分的证书路径即可！\r\n</p>\r\n<p>\r\n	ssl_session_timeout  5m;\r\n</p>\r\n<p>\r\n	ssl_protocols  SSLv2 SSLv3 TLSv1;&nbsp; &nbsp;ssl_ciphers  HIGH:!aNULL:!MD5;&nbsp; &nbsp;ssl_prefer_server_ciphers   on;\r\n</p>\r\n<p>\r\n	access_log  /var/www/vhosts/test.huanqiu.com/logs/clickstream_ssl.log  main;\r\n</p>\r\n<p>\r\n	location / {&nbsp; &nbsp;try_files $uri $uri/ @router;&nbsp; &nbsp;index  index.php;        }\r\n</p>\r\n<p>\r\n	error_page   500 502 503 504  /50x.html;\r\n</p>\r\n<p>\r\n	location @router {&nbsp; &nbsp;rewrite ^.*$ /index.php last;        }\r\n</p>\r\n<p>\r\n	location ~ \\.php$ {&nbsp; fastcgi_pass   127.0.0.1:9001;&nbsp; fastcgi_read_timeout 300;&nbsp; fastcgi_index  index.php;&nbsp; fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&nbsp; #include        fastcgi_params;&nbsp; include        fastcgi.conf; &nbsp; fastcgi_param  HTTPS on;&nbsp; &nbsp; &nbsp; &nbsp; #这个一定要加上，否则访问https时会出现报错：The plain HTTP request was sent to HTTPS port        }    } ##end server\r\n</p>\r\n<p>\r\n	[root@dev-new-test1 vhosts]# lsof -i:8090COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEnginx   24373   root  170u  IPv4 849747      0t0  TCP *:8090 (LISTEN)nginx   25897 nobody  170u  IPv4 849747      0t0  TCP *:8090 (LISTEN)nginx   25898 nobody  170u  IPv4 849747      0t0  TCP *:8090 (LISTEN)\r\n</p>\r\n<p>\r\n	最后在浏览器里访问https://testwww.huanqiu.com就能通过192.168.1.8服务器反向代理到192.168.1.150上的8090端口上了~\r\n</p>\r\n<p>\r\n	****************************************************************************************下面顺便附上一个测试的nginx代理配置（http和https）\r\n</p>\r\n<p>\r\n	[root@linux-node1 vhosts]# cat testhuanqiu.com   upstream 8802 {&nbsp; &nbsp;server 192.168.1.150:8802 max_fails=3 fail_timeout=30s;    }  upstream 8803 {&nbsp; &nbsp;server 192.168.1.150:8803&nbsp;max_fails=3 fail_timeout=30s;    }  upstream 8804 {&nbsp; &nbsp;server 192.168.1.150:8804&nbsp;max_fails=3 fail_timeout=30s;    }  upstream 8805 {&nbsp; server 192.168.1.150:8805&nbsp;max_fails=3 fail_timeout=30s;    }\r\n</p>\r\n<p>\r\n	server {&nbsp; listen 80;&nbsp; server_name  test10erp.fangfull.com;       location  /     {&nbsp; proxy_store off;&nbsp; proxy_redirect  off;&nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; proxy_set_header X-Real-IP $remote_addr;&nbsp; proxy_set_header Host $http_host;&nbsp; proxy_pass http://8802;        }    }\r\n</p>\r\n<p>\r\n	server {&nbsp; listen 80;&nbsp; server_name  test10www.fangfull.com;       location  /     {&nbsp; proxy_store off;&nbsp; proxy_redirect  off;&nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&nbsp; proxy_set_header X-Real-IP $remote_addr;&nbsp; proxy_set_header Host $http_host;&nbsp; proxy_pass http://8803;        }    }\r\n</p>\r\n<p>\r\n	server {&nbsp; listen 443;&nbsp; server_name  test10fanghu.xqshijie.com;&nbsp; ssl on;\r\n</p>\r\n<p>\r\n	### SSL cert files ###  &nbsp; ssl_certificate      ssl/xqshijie.cer;  &nbsp; ssl_certificate_key  ssl/xqshijie.key; &nbsp; ssl_session_timeout  5m;\r\n</p>\r\n<p>\r\n	location  /     {&nbsp; proxy_pass  https://8804;  &nbsp; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;  &nbsp; proxy_set_header Host $host;  &nbsp; proxy_set_header X-Real-IP $remote_addr;  &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &nbsp; proxy_set_header X-Forwarded-Proto https;  &nbsp; proxy_redirect     off;        }    }\r\n</p>\r\n<p>\r\n	server {&nbsp; listen 443;&nbsp; server_name  test10www.xqshijie.com;&nbsp; ssl on;\r\n</p>\r\n<p>\r\n	### SSL cert files ###  &nbsp; ssl_certificate      ssl/xqshijie.cer;  &nbsp; ssl_certificate_key  ssl/xqshijie.key; &nbsp; ssl_session_timeout  5m;\r\n</p>\r\n<p>\r\n	location  /     {&nbsp; proxy_pass  https://8805;  &nbsp; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;  &nbsp; proxy_set_header Host $host;  &nbsp; proxy_set_header X-Real-IP $remote_addr;  &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &nbsp; proxy_set_header X-Forwarded-Proto https;  &nbsp; proxy_redirect     off;        }    }****************************************************************************************\r\n</p>\r\n<p>\r\n	上面的情况是：nginx代理层和后端服务器上都有ssl证书。如果是nginx+tomcat+https在本机部署（即没有代理层），可以参考：https://pan.baidu.com/s/1jHPPMK2 &nbsp; &nbsp; &nbsp; 提取密码：j7s4\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('a46e2605-fe12-421a-adcc-aa9c7a93259b','Mysql连接错误：Lost connection to Mysql server at &#39;','Mysql连接错误：Lost connection to Mysql server at &#39;waiting for initial communication packet&#39;','<p>\r\n	在远程连接mysql的时候，连接不上，出现如下报错：Lost connection to MySQL server at \'waiting for initial communication packet\', system error: 0截图如下：\r\n</p>\r\n<p>\r\n	原因分析：mysql开启了DNS的反向解析功能，这样mysql对连接的客户端会进行DNS主机名查找。mysql处理客户端解析过程：1）当mysql的client连过来的时候，服务器会主动去查client的域名。2）首先查找 /etc/hosts 文件，搜索域名和IP的对应关系。3）如果hosts文件没有，则查找DNS设置，进行DNS反向解析，直到timeout连接失败。mysql的DNS反向解析：1）mysql接收到连接请求后，获得的是客户端的ip，为了更好的匹配mysql.user里的权限记录（某些是用hostname定义的）。2）如果mysql服务器设置了dns服务器，并且客户端ip在dns上并没有相应的hostname，那么这个过程很慢，导致连接等待。\r\n</p>\r\n<p>\r\n	解决方案：1）把client的ip写在mysql服务器的/etc/hosts文件里，随便给个名字做主机映射即可。2）在my.cnf配置文件中的[mysqld]区域添加skip-name-resolve，即跳过mysql连接的DNS反向解析功能，这样能很好地提高mysql性能。在这种情况下，就只能使用MySQL授权表中的IP来连接mysql服务了。对于第一种方法显然比较笨，也不实用！强烈推荐第二种方法，添加skip-name-resolve选项可以禁用dns解析，这样的话，就不能在mysql的授权表中使用主机名了，只能使用IP。--------------------------------------------------------------------------------------------------------------另外：如果在my.cnf文件中配置了bind-address地址绑定的地址（说明别的机器远程只能通过这个绑定的本机地址来连接mysql），可以将其注释掉。例如：bind-address = 127.0.0.1 &nbsp; &nbsp; &nbsp; //说明只能在本机连接mysql，并且通过-h 127.0.0.1或localhost，在远程是无法连接这个mysql的！--------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	my.cnf配置的几个参数：skip-name-resolve &nbsp; &nbsp; &nbsp; &nbsp; 跳过DNS反向解析过程.（这样就不能使用主机名连接mysql了，只能使用ip连接）skip-grant-tables &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跳过授权表（当mysql登陆密码忘记时的解决办法）skip-networking &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跳过TCP/IP连接skip-host-cache &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 禁用主机名缓存;要想清除主机名缓存，执行FLUSH HOSTS语句或执行mysqladmin flush-hosts命令\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('a6aa7897-f076-4d8f-8008-c8562024a7f9','Mysql读写分离方案－MySQL Proxy环境部署记录','Mysql读写分离方案－MySQL Proxy环境部署记录','<p>\r\n	Mysql的读写分离可以使用MySQL Proxy和Amoeba实现，其实也可以使用MySQL-MMM实现读写分离的自动切换。MySQL Proxy有一项强大功能是实现\"读写分离\"，基本原理是让主数据库处理写方面事务，让从库处理SELECT查询；Amoeba for MySQL是一款优秀的中间件软件，同样可以实现读写分离，负载均衡等功能。下面重点说下Mysql Proxy:\r\n</p>\r\n<p>\r\n	MySQL Proxy处于客户端应用程序和MySQL服务器之间，通过截断、改变并转发客户端和后端数据库之间的通信来实现其功能。代理服务器是和TCP/IP协议打交道，\r\n</p>\r\n<p>\r\n	而要理解MySQL Proxy的工作机制，同样要清楚MySQL客户端和服务器之间的通信协议，MySQL Protocol 包括认证和查询两个基本过程：\r\n</p>\r\n<p>\r\n	.................................\r\n</p>\r\n<p>\r\n	认证过程包括：\r\n</p>\r\n<p>\r\n	1）客户端向服务器发起连接请求\r\n</p>\r\n<p>\r\n	2）服务器向客户端发送握手信息\r\n</p>\r\n<p>\r\n	3）客户端向服务器发送认证请求\r\n</p>\r\n<p>\r\n	4）服务器向客户端发送认证结果\r\n</p>\r\n<p>\r\n	................................\r\n</p>\r\n<p>\r\n	如果认证通过，则进入查询过程：\r\n</p>\r\n<p>\r\n	1）客户端向服务器发起查询请求\r\n</p>\r\n<p>\r\n	2）服务器向客户端返回查询结果\r\n</p>\r\n<p>\r\n	当然，这只是一个粗略的描述，每个过程中发送的包都是有固定格式的。MySQL Proxy要做的，就是介入协议的各个过程。首先MySQL Proxy以服务器的身份接受客户端请求，\r\n</p>\r\n<p>\r\n	根据配置对这些请求进行分析处理，然后以客户端的身份转发给相应的后端数据库服务器，再接受服务器的信息，返回给客户端。所以MySQL Proxy需要同时实现客户端和服务\r\n</p>\r\n<p>\r\n	器的协议。由于要对客户端发送过来的SQL语句进行分析，还需要包含一个SQL解析器。可以说MySQL Proxy相当于一个轻量级的MySQL了，实际上，MySQL Proxy的admin server\r\n</p>\r\n<p>\r\n	是可以接受SQL来查询状态信息的。\r\n</p>\r\n<p>\r\n	MySQL Proxy通过lua 脚本来控制连接转发的机制。主要的函数都是配合MySQL Protocol各个过程的，这一点从函数名上就能看出来：\r\n</p>\r\n<p>\r\n	connect_server()\r\n</p>\r\n<p>\r\n	read_handshake()\r\n</p>\r\n<p>\r\n	read_auth()\r\n</p>\r\n<p>\r\n	read_auth_result()\r\n</p>\r\n<p>\r\n	read_query()\r\n</p>\r\n<p>\r\n	read_query_result()\r\n</p>\r\n<p>\r\n	至于为什么采用lua 脚本语言，大概是因为MySQL Proxy中采用了wormhole 存储引擎 的关系吧，这个虫洞存储引擎很有意思，数据的存储格式就是一段lua脚本。\r\n</p>\r\n<p>\r\n	Mysql Proxy的原理图\r\n</p>\r\n<p>\r\n	顺便贴下Mysql Proxy的工作拓扑图\r\n</p>\r\n<p>\r\n	部署MySQL Proxy实现读写分离并提高并发负载的操作记录\r\n</p>\r\n<p>\r\n	0）机器环境\r\n</p>\r\n<p>\r\n	ip地址              角色         主机名\r\n</p>\r\n<p>\r\n	182.48.115.237     master      master-node\r\n</p>\r\n<p>\r\n	182.48.115.236     slave1      slave-node1\r\n</p>\r\n<p>\r\n	182.48.115.238     slave2      slave-node2\r\n</p>\r\n<p>\r\n	182.48.115.233     proxy       proxy-node\r\n</p>\r\n<p>\r\n	四台机器都关闭防火墙和selinux\r\n</p>\r\n<p>\r\n	绑定hosts设置（四台机器都要操作）\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /etc/hosts\r\n</p>\r\n<p>\r\n	......\r\n</p>\r\n<p>\r\n	182.48.115.237   master-node\r\n</p>\r\n<p>\r\n	182.48.115.236   slave-node1\r\n</p>\r\n<p>\r\n	182.48.115.238   slave-node2\r\n</p>\r\n<p>\r\n	182.48.115.233   proxy-node\r\n</p>\r\n<p>\r\n	1）Mysql主从复制部署（在三台mysql节点机上部署，本案例是一主两从架构）\r\n</p>\r\n<p>\r\n	mysql安装参考：http://www.cnblogs.com/kevingrace/p/6109679.html\r\n</p>\r\n<p>\r\n	mysql主从部署参考：http://www.cnblogs.com/kevingrace/p/6256603.html\r\n</p>\r\n<p>\r\n	2）在proxy机器上安装mysql-proxy\r\n</p>\r\n<p>\r\n	1）安装mysql-proxy\r\n</p>\r\n<p>\r\n	mysql proxy实现读写分离是有lua脚本实现的\r\n</p>\r\n<p>\r\n	下载地址1：https://downloads.mysql.com/archives/proxy/#downloads\r\n</p>\r\n<p>\r\n	下载地址2: http://ftp.ntu.edu.tw/pub/MySQL/Downloads/MySQL-Proxy/\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# wget http://ftp.ntu.edu.tw/pub/MySQL/Downloads/MySQL-Proxy/mysql-proxy-0.8.5-linux-el6-x86-64bit.tar.gz\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# tar -zvxf mysql-proxy-0.8.5-linux-el6-x86-64bit.tar.gz\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# mv mysql-proxy-0.8.5-linux-el6-x86-64bit /usr/local/mysql-proxy\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# useradd -r mysql-proxy\r\n</p>\r\n<p>\r\n	2）提供服务脚本\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# vim /etc/init.d/mysql-proxy\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	# mysql-proxy This script starts and stops the mysql-proxy daemon\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	# chkconfig: - 78 30\r\n</p>\r\n<p>\r\n	# processname: mysql-proxy\r\n</p>\r\n<p>\r\n	# description: mysql-proxy is a proxy daemon for mysql\r\n</p>\r\n<p>\r\n	# Source function library.\r\n</p>\r\n<p>\r\n	. /etc/rc.d/init.d/functions\r\n</p>\r\n<p>\r\n	prog=\"/usr/local/mysql-proxy/bin/mysql-proxy\"\r\n</p>\r\n<p>\r\n	# Source networking configuration.\r\n</p>\r\n<p>\r\n	if [ -f /etc/sysconfig/network ]; then\r\n</p>\r\n<p>\r\n	. /etc/sysconfig/network\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	# Check that networking is up.\r\n</p>\r\n<p>\r\n	[ ${NETWORKING} = \"no\" ] &amp;&amp; exit 0\r\n</p>\r\n<p>\r\n	# Set default mysql-proxy configuration.\r\n</p>\r\n<p>\r\n	ADMIN_USER=\"admin\"\r\n</p>\r\n<p>\r\n	ADMIN_PASSWD=\"admin\"\r\n</p>\r\n<p>\r\n	ADMIN_LUA_SCRIPT=\"/usr/local/mysql-proxy/share/doc/mysql-proxy/admin.lua\"\r\n</p>\r\n<p>\r\n	PROXY_OPTIONS=\"--daemon\"\r\n</p>\r\n<p>\r\n	PROXY_PID=/var/run/mysql-proxy.pid\r\n</p>\r\n<p>\r\n	PROXY_USER=\"mysql-proxy\"\r\n</p>\r\n<p>\r\n	# Source mysql-proxy configuration.\r\n</p>\r\n<p>\r\n	if [ -f /etc/sysconfig/mysql-proxy ]; then\r\n</p>\r\n<p>\r\n	. /etc/sysconfig/mysql-proxy\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	RETVAL=0\r\n</p>\r\n<p>\r\n	start() {\r\n</p>\r\n<p>\r\n	echo -n $\"Starting $prog: \"\r\n</p>\r\n<p>\r\n	daemon $prog $PROXY_OPTIONS --pid-file=$PROXY_PID --proxy-address=\"$PROXY_ADDRESS\" --user=$PROXY_USER --admin-username=\"$ADMIN_USER\" --admin-lua-script=\"$ADMIN_LUA_SCRIPT\" --admin-password=\"$ADMIN_PASSWORD\"\r\n</p>\r\n<p>\r\n	RETVAL=$?\r\n</p>\r\n<p>\r\n	echo\r\n</p>\r\n<p>\r\n	if [ $RETVAL -eq 0 ]; then\r\n</p>\r\n<p>\r\n	touch /var/lock/subsys/mysql-proxy\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	stop() {\r\n</p>\r\n<p>\r\n	echo -n $\"Stopping $prog: \"\r\n</p>\r\n<p>\r\n	killproc -p $PROXY_PID -d 3 $prog\r\n</p>\r\n<p>\r\n	RETVAL=$?\r\n</p>\r\n<p>\r\n	echo\r\n</p>\r\n<p>\r\n	if [ $RETVAL -eq 0 ]; then\r\n</p>\r\n<p>\r\n	rm -f /var/lock/subsys/mysql-proxy\r\n</p>\r\n<p>\r\n	rm -f $PROXY_PID\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	# See how we were called.\r\n</p>\r\n<p>\r\n	case \"$1\" in\r\n</p>\r\n<p>\r\n	start)\r\n</p>\r\n<p>\r\n	start\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	stop)\r\n</p>\r\n<p>\r\n	stop\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	restart)\r\n</p>\r\n<p>\r\n	stop\r\n</p>\r\n<p>\r\n	start\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	condrestart|try-restart)\r\n</p>\r\n<p>\r\n	if status -p $PROXY_PIDFILE $prog &gt;&amp;/dev/null; then\r\n</p>\r\n<p>\r\n	stop\r\n</p>\r\n<p>\r\n	start\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	status)\r\n</p>\r\n<p>\r\n	status -p $PROXY_PID $prog\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	*)\r\n</p>\r\n<p>\r\n	echo \"Usage: $0 {start|stop|restart|reload|status|condrestart|try-restart}\"\r\n</p>\r\n<p>\r\n	RETVAL=1\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	esac\r\n</p>\r\n<p>\r\n	exit $RETVAL\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# chmod 755 /etc/init.d/mysql-proxy\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# chkconfig --add mysql-proxy\r\n</p>\r\n<p>\r\n	3）为服务脚本提供配置文件\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# vim /etc/sysconfig/mysql-proxy\r\n</p>\r\n<p>\r\n	# Options for mysql-proxy\r\n</p>\r\n<p>\r\n	ADMIN_USER=\"admin\"\r\n</p>\r\n<p>\r\n	ADMIN_PASSWORD=\"admin\"\r\n</p>\r\n<p>\r\n	ADMIN_ADDRESS=\"\"\r\n</p>\r\n<p>\r\n	ADMIN_LUA_SCRIPT=\"/usr/local/mysql-proxy/share/doc/mysql-proxy/admin.lua\"\r\n</p>\r\n<p>\r\n	PROXY_ADDRESS=\"\"\r\n</p>\r\n<p>\r\n	PROXY_USER=\"mysql-proxy\"\r\n</p>\r\n<p>\r\n	PROXY_OPTIONS=\"--daemon --log-level=info --log-use-syslog --plugins=proxy --plugins=admin --proxy-backend-addresses=182.48.115.237:3306 --proxy-read-only-backend-addresses=182.48.115.236:3306\r\n</p>\r\n<p>\r\n	--proxy-read-only-backend-addresses=182.48.115.238:3306 --proxy-lua-script=/usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua\"\r\n</p>\r\n<p>\r\n	配置参数解释：\r\n</p>\r\n<p>\r\n	--daemon：以守护进程模式启动mysql-proxy\r\n</p>\r\n<p>\r\n	--proxy-backend-addresses：后端可读写的mysql服务器的地址和端口\r\n</p>\r\n<p>\r\n	--proxy-read-only-backend-addresses：后端只读mysql服务器的地址和端口\r\n</p>\r\n<p>\r\n	--proxy-lua-script：完成mysql代理功能的Lua脚本\r\n</p>\r\n<p>\r\n	4）提供admin.lua文件\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# vim /usr/local/mysql-proxy/share/doc/mysql-proxy/admin.lua\r\n</p>\r\n<p>\r\n	--[[ $%BEGINLICENSE%$\r\n</p>\r\n<p>\r\n	Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	This program is free software; you can redistribute it and/or\r\n</p>\r\n<p>\r\n	modify it under the terms of the GNU General Public License as\r\n</p>\r\n<p>\r\n	published by the Free Software Foundation; version 2 of the\r\n</p>\r\n<p>\r\n	License.\r\n</p>\r\n<p>\r\n	This program is distributed in the hope that it will be useful,\r\n</p>\r\n<p>\r\n	but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n</p>\r\n<p>\r\n	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n</p>\r\n<p>\r\n	GNU General Public License for more details.\r\n</p>\r\n<p>\r\n	You should have received a copy of the GNU General Public License\r\n</p>\r\n<p>\r\n	along with this program; if not, write to the Free Software\r\n</p>\r\n<p>\r\n	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\r\n</p>\r\n<p>\r\n	02110-1301  USA\r\n</p>\r\n<p>\r\n	$%ENDLICENSE%$ --]]\r\n</p>\r\n<p>\r\n	function set_error(errmsg)\r\n</p>\r\n<p>\r\n	proxy.response = {\r\n</p>\r\n<p>\r\n	type = proxy.MYSQLD_PACKET_ERR,\r\n</p>\r\n<p>\r\n	errmsg = errmsg or \"error\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	function read_query(packet)\r\n</p>\r\n<p>\r\n	if packet:byte() ~= proxy.COM_QUERY then\r\n</p>\r\n<p>\r\n	set_error(\"[admin] we only handle text-based queries (COM_QUERY)\")\r\n</p>\r\n<p>\r\n	return proxy.PROXY_SEND_RESULT\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	local query = packet:sub(2)\r\n</p>\r\n<p>\r\n	local rows = { }\r\n</p>\r\n<p>\r\n	local fields = { }\r\n</p>\r\n<p>\r\n	if query:lower() == \"select * from backends\" then\r\n</p>\r\n<p>\r\n	fields = {\r\n</p>\r\n<p>\r\n	{ name = \"backend_ndx\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_LONG },\r\n</p>\r\n<p>\r\n	{ name = \"address\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	{ name = \"state\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	{ name = \"type\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	{ name = \"uuid\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	{ name = \"connected_clients\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_LONG },\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	for i = 1, #proxy.global.backends do\r\n</p>\r\n<p>\r\n	local states = {\r\n</p>\r\n<p>\r\n	\"unknown\",\r\n</p>\r\n<p>\r\n	\"up\",\r\n</p>\r\n<p>\r\n	\"down\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	local types = {\r\n</p>\r\n<p>\r\n	\"unknown\",\r\n</p>\r\n<p>\r\n	\"rw\",\r\n</p>\r\n<p>\r\n	\"ro\"\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	local b = proxy.global.backends[i]\r\n</p>\r\n<p>\r\n	rows[#rows + 1] = {\r\n</p>\r\n<p>\r\n	i,\r\n</p>\r\n<p>\r\n	b.dst.name,          -- configured backend address\r\n</p>\r\n<p>\r\n	states[b.state + 1], -- the C-id is pushed down starting at 0\r\n</p>\r\n<p>\r\n	types[b.type + 1],   -- the C-id is pushed down starting at 0\r\n</p>\r\n<p>\r\n	b.uuid,              -- the MySQL Server\'s UUID if it is managed\r\n</p>\r\n<p>\r\n	b.connected_clients  -- currently connected clients\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	elseif query:lower() == \"select * from help\" then\r\n</p>\r\n<p>\r\n	fields = {\r\n</p>\r\n<p>\r\n	{ name = \"command\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	{ name = \"description\",\r\n</p>\r\n<p>\r\n	type = proxy.MYSQL_TYPE_STRING },\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	rows[#rows + 1] = { \"SELECT * FROM help\", \"shows this help\" }\r\n</p>\r\n<p>\r\n	rows[#rows + 1] = { \"SELECT * FROM backends\", \"lists the backends and their state\" }\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	set_error(\"use \'SELECT * FROM help\' to see the supported commands\")\r\n</p>\r\n<p>\r\n	return proxy.PROXY_SEND_RESULT\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	proxy.response = {\r\n</p>\r\n<p>\r\n	type = proxy.MYSQLD_PACKET_OK,\r\n</p>\r\n<p>\r\n	resultset = {\r\n</p>\r\n<p>\r\n	fields = fields,\r\n</p>\r\n<p>\r\n	rows = rows\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	return proxy.PROXY_SEND_RESULT\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	5）为了测试更明显，编辑rw-splitting.lua文件中的其中2个数值：\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# vim /usr/local/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	if not proxy.global.config.rwsplit then\r\n</p>\r\n<p>\r\n	proxy.global.config.rwsplit = {\r\n</p>\r\n<p>\r\n	min_idle_connections = 1,        //修改这个值，默认为4\r\n</p>\r\n<p>\r\n	max_idle_connections = 1,        //修改这个值，默认为8\r\n</p>\r\n<p>\r\n	is_debug = false\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	end\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	注意：\r\n</p>\r\n<p>\r\n	mysql-proxy会检测客户端连接，当连接没有超过min_idle_connections预设值时, 不会进行读写分离, 即查询操作会发生到Master上。\r\n</p>\r\n<p>\r\n	6）启动mysql-proxy\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# service mysql-proxy start\r\n</p>\r\n<p>\r\n	Starting /usr/local/mysql-proxy/bin/mysql-proxy:           [  OK  ]\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# service mysql-proxy status\r\n</p>\r\n<p>\r\n	mysql-proxy (pid  4655) is running...\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# netstat -tunlp\r\n</p>\r\n<p>\r\n	Active Internet connections (only servers)\r\n</p>\r\n<p>\r\n	Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name\r\n</p>\r\n<p>\r\n	tcp        0      0 0.0.0.0:4041                0.0.0.0:*                   LISTEN      4655/mysql-proxy\r\n</p>\r\n<p>\r\n	tcp        0      0 0.0.0.0:3306                0.0.0.0:*                   LISTEN      4655/mysql-proxy\r\n</p>\r\n<p>\r\n	7）连接测试（在任意一台远程客户机上测试连接）\r\n</p>\r\n<p>\r\n	[root@slave-node2 ~]# mysql -uadmin -padmin -h182.48.115.233 --port=4041\r\n</p>\r\n<p>\r\n	Warning: Using a password on the command line interface can be insecure.\r\n</p>\r\n<p>\r\n	Welcome to the MySQL monitor.  Commands end with ; or \\g.\r\n</p>\r\n<p>\r\n	Your MySQL connection id is 1\r\n</p>\r\n<p>\r\n	Server version: 5.0.99-agent-admin\r\n</p>\r\n<p>\r\n	Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	Oracle is a registered trademark of Oracle Corporation and/or its\r\n</p>\r\n<p>\r\n	affiliates. Other names may be trademarks of their respective\r\n</p>\r\n<p>\r\n	owners.\r\n</p>\r\n<p>\r\n	Type \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT * FROM backends;\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	| backend_ndx | address             | state   | type | uuid | connected_clients |\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	|           1 | 182.48.115.237:3306 | unknown | rw   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	|           2 | 182.48.115.236:3306 | unknown | ro   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	|           3 | 182.48.115.238:3306 | unknown | ro   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）读写分离测试\r\n</p>\r\n<p>\r\n	1）在master-node数据库上创建proxy用户，从服务器也会同步这个操作。\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT ALL ON *.* TO \'wang\'@\'182.48.115.%\' IDENTIFIED BY \'123456\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	2）proxy-node机器上使用创建的proxy用户登陆数据库，进行数据操作\r\n</p>\r\n<p>\r\n	[root@proxy-node ~]# mysql -uwang -h182.48.115.233 -p123456\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	mysql&gt; create database huanqiutest;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiutest;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table haha( id int(5), name varchar(10));\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.19 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into haha values(1,\"zhangbao\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into haha values(11,\"shibo\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from haha;\r\n</p>\r\n<p>\r\n	+------+----------+\r\n</p>\r\n<p>\r\n	| id   | name     |\r\n</p>\r\n<p>\r\n	+------+----------+\r\n</p>\r\n<p>\r\n	|    1 | zhangbao |\r\n</p>\r\n<p>\r\n	|   11 | shibo    |\r\n</p>\r\n<p>\r\n	+------+----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	注意下面两点：\r\n</p>\r\n<p>\r\n	-&gt; 发现使用proxy用户登陆数据库写入的数据只写入master主库，然后再同步到slave从库。如果将从库的slave同步功能关闭，则从库就无法更新数据。\r\n</p>\r\n<p>\r\n	-&gt; 登陆从库服务器关闭slave同步功能（stop slave），这时再登陆proxy-noed机器肯定会查询不出数据（能看到表，但是查询不出数据）\r\n</p>\r\n<p>\r\n	-&gt; 以上两点真正实现了读写分离的效果！\r\n</p>\r\n<p>\r\n	3）查看状态，在proxy-node机器上操作，可以看到状态全部为up：\r\n</p>\r\n<p>\r\n	[root@proxy-node bin]# mysql -uadmin -padmin -h182.48.115.233 --port=4041\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	mysql&gt; SELECT * FROM backends;\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	| backend_ndx | address             | state   | type | uuid | connected_clients |\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	|           1 | 182.48.115.237:3306 | up      | rw   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	|           2 | 182.48.115.236:3306 | up      | ro   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	|           3 | 182.48.115.238:3306 | up      | ro   | NULL |                 0 |\r\n</p>\r\n<p>\r\n	+-------------+---------------------+---------+------+------+-------------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	读写分离，延迟是个大问题，要确保主从同步这一环节不要有延迟。---------------mysql主从同步延迟原理----------------－&gt; mysql主从同步原理主库针对读写操作，顺序写 binlog，从库单线程去主库读\"写操作的binlog\",从库取到 binlog在本地原样执行(随机写),来保证主从数据逻辑上一致.mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生 binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步问题来了，slave的 slave_sql_running线程将主库的 DDL和DML操作在 slave实施。DML，DDL的IO操作是随即的，不能顺序的，成本高很多，还有可能slave上的其他查询产生 lock，由于 slave_sql_running也是单线程的，所以 一个 DDL卡住了，需求需求执行一段时间，那么所有之后的DDL会等待这个 DDL执行完才会继续执行，这就导致了延迟.由于master可以并发，Slave_sql_running线程却不可以，所以主库执行 DDL需求一段时间，在slave执行相同的DDL时，就产生了延迟.\r\n</p>\r\n<p>\r\n	-&gt; 主从同步延迟产生原因当主库的TPS并发较高时，产生的DDL数量超过Slave一个 sql线程所能承受的范围，那么延迟就产生了，当然还有就是可能与 slave的大型 query语句产生了锁等待首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高次要原因：读写 binlog带来的性能影响，网络传输延迟\r\n</p>\r\n<p>\r\n	-&gt; &nbsp;mysql主从同步加速1）sync_binlog在slave端设置为02）–logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。3）直接禁用slave端的binlog4）slave端，如果使用的存储引擎是innodb，innodb_flush_log_at_trx_commit =2\r\n</p>\r\n<p>\r\n	再有就是进行分库分表处理，这样减少数据量的复制同步操作\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5');
INSERT INTO `article` VALUES ('a975e623-6824-4f4e-a2e8-f366ae0ac77f','Python之路- 异步IO\\数据库\\队列\\缓存','Python之路- 异步IO\\数据库\\队列\\缓存','<p>\r\n	本节内容1、Gevent协程 2、 Select\\Poll\\Epoll异步IO与事件驱动 3、Python连接Mysql数据库操作 4、RabbitMQ队列 5、Redis\\Memcached缓存 6、Paramiko SSH 7、Twsited网络框架\r\n</p>\r\n<p>\r\n	引子\r\n</p>\r\n<p>\r\n	到目前为止，我们已经学了网络并发编程的2个套路， 多进程，多线程，这哥俩的优势和劣势都非常的明显，我们一起来回顾下\r\n</p>\r\n<p>\r\n	协程\r\n</p>\r\n<p>\r\n	协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。\r\n</p>\r\n<p>\r\n	协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：\r\n</p>\r\n<p>\r\n	协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	协程的好处：\r\n</p>\r\n<p>\r\n	无需线程上下文切换的开销\r\n</p>\r\n<p>\r\n	无需原子操作锁定及同步的开销\r\n</p>\r\n<p>\r\n	\"原子操作(atomic operation)是不需要synchronized\"，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。\r\n</p>\r\n<p>\r\n	方便切换控制流，简化编程模型\r\n</p>\r\n<p>\r\n	高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	缺点：\r\n</p>\r\n<p>\r\n	无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。\r\n</p>\r\n<p>\r\n	进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序\r\n</p>\r\n<p>\r\n	使用yield实现协程操作例子\r\n</p>\r\n<p>\r\n	import time\r\n</p>\r\n<p>\r\n	import queue\r\n</p>\r\n<p>\r\n	def consumer(name):\r\n</p>\r\n<p>\r\n	print(\"---&gt;starting eating baozi...\")\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	new_baozi = yield\r\n</p>\r\n<p>\r\n	print(\"[%s] is eating baozi %s\" % (name,new_baozi))\r\n</p>\r\n<p>\r\n	#time.sleep(1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def producer():\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	r = con.__next__()\r\n</p>\r\n<p>\r\n	r = con2.__next__()\r\n</p>\r\n<p>\r\n	n = 0\r\n</p>\r\n<p>\r\n	while n &lt; 5:\r\n</p>\r\n<p>\r\n	n +=1\r\n</p>\r\n<p>\r\n	con.send(n)\r\n</p>\r\n<p>\r\n	con2.send(n)\r\n</p>\r\n<p>\r\n	print(\"\\033[32;1m[producer]\\033[0m is making baozi %s\" %n )\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	con = consumer(\"c1\")\r\n</p>\r\n<p>\r\n	con2 = consumer(\"c2\")\r\n</p>\r\n<p>\r\n	p = producer()\r\n</p>\r\n<p>\r\n	看楼上的例子，我问你这算不算做是协程呢？你说，我他妈哪知道呀，你前面说了一堆废话，但是并没告诉我协程的标准形态呀，我腚眼一想，觉得你说也对，那好，我们先给协程一个标准定义，即符合什么条件就能称之为协程：\r\n</p>\r\n<p>\r\n	必须在只有一个单线程里实现并发\r\n</p>\r\n<p>\r\n	修改共享数据不需加锁\r\n</p>\r\n<p>\r\n	用户程序里自己保存多个控制流的上下文栈\r\n</p>\r\n<p>\r\n	一个协程遇到IO操作自动切换到其它协程\r\n</p>\r\n<p>\r\n	基于上面这4点定义，我们刚才用yield实现的程并不能算是合格的线程，因为它有一点功能没实现，哪一点呢？\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Greenlet\r\n</p>\r\n<p>\r\n	greenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	from greenlet import greenlet\r\n</p>\r\n<p>\r\n	def test1():\r\n</p>\r\n<p>\r\n	print(12)\r\n</p>\r\n<p>\r\n	gr2.switch()\r\n</p>\r\n<p>\r\n	print(34)\r\n</p>\r\n<p>\r\n	gr2.switch()\r\n</p>\r\n<p>\r\n	def test2():\r\n</p>\r\n<p>\r\n	print(56)\r\n</p>\r\n<p>\r\n	gr1.switch()\r\n</p>\r\n<p>\r\n	print(78)\r\n</p>\r\n<p>\r\n	gr1 = greenlet(test1)\r\n</p>\r\n<p>\r\n	gr2 = greenlet(test2)\r\n</p>\r\n<p>\r\n	gr1.switch()\r\n</p>\r\n<p>\r\n	感觉确实用着比generator还简单了呢，但好像还没有解决一个问题，就是遇到IO操作，自动切换，对不对？\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Gevent\r\n</p>\r\n<p>\r\n	Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。\r\n</p>\r\n<p>\r\n	import gevent\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def func1():\r\n</p>\r\n<p>\r\n	print(\'\\033[31;1m李闯在跟海涛搞...\\033[0m\')\r\n</p>\r\n<p>\r\n	gevent.sleep(2)\r\n</p>\r\n<p>\r\n	print(\'\\033[31;1m李闯又回去跟继续跟海涛搞...\\033[0m\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def func2():\r\n</p>\r\n<p>\r\n	print(\'\\033[32;1m李闯切换到了跟海龙搞...\\033[0m\')\r\n</p>\r\n<p>\r\n	gevent.sleep(1)\r\n</p>\r\n<p>\r\n	print(\'\\033[32;1m李闯搞完了海涛，回来继续跟海龙搞...\\033[0m\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	gevent.joinall([\r\n</p>\r\n<p>\r\n	gevent.spawn(func1),\r\n</p>\r\n<p>\r\n	gevent.spawn(func2),\r\n</p>\r\n<p>\r\n	#gevent.spawn(func3),\r\n</p>\r\n<p>\r\n	])\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	输出：\r\n</p>\r\n<p>\r\n	李闯在跟海涛搞...李闯切换到了跟海龙搞...李闯搞完了海涛，回来继续跟海龙搞...李闯又回去跟继续跟海涛搞...\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	同步与异步的性能区别\r\n</p>\r\n<p>\r\n	import gevent\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def task(pid):\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	Some non-deterministic task\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	gevent.sleep(0.5)\r\n</p>\r\n<p>\r\n	print(\'Task %s done\' % pid)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def synchronous():\r\n</p>\r\n<p>\r\n	for i in range(1,10):\r\n</p>\r\n<p>\r\n	task(i)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def asynchronous():\r\n</p>\r\n<p>\r\n	threads = [gevent.spawn(task, i) for i in range(10)]\r\n</p>\r\n<p>\r\n	gevent.joinall(threads)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\'Synchronous:\')\r\n</p>\r\n<p>\r\n	synchronous()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\'Asynchronous:\')\r\n</p>\r\n<p>\r\n	asynchronous()\r\n</p>\r\n<p>\r\n	上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall&nbsp;函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。\r\n</p>\r\n<p>\r\n	遇到IO阻塞时会自动切换任务\r\n</p>\r\n<p>\r\n	from gevent import monkey; monkey.patch_all()\r\n</p>\r\n<p>\r\n	import gevent\r\n</p>\r\n<p>\r\n	from  urllib.request import urlopen\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def f(url):\r\n</p>\r\n<p>\r\n	print(\'GET: %s\' % url)\r\n</p>\r\n<p>\r\n	resp = urlopen(url)\r\n</p>\r\n<p>\r\n	data = resp.read()\r\n</p>\r\n<p>\r\n	print(\'%d bytes received from %s.\' % (len(data), url))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	gevent.joinall([\r\n</p>\r\n<p>\r\n	gevent.spawn(f, \'https://www.python.org/\'),\r\n</p>\r\n<p>\r\n	gevent.spawn(f, \'https://www.yahoo.com/\'),\r\n</p>\r\n<p>\r\n	gevent.spawn(f, \'https://github.com/\'),\r\n</p>\r\n<p>\r\n	])\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	通过gevent实现单线程下的多socket并发\r\n</p>\r\n<p>\r\n	server side\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	import time\r\n</p>\r\n<p>\r\n	import gevent\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from gevent import socket,monkey\r\n</p>\r\n<p>\r\n	monkey.patch_all()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def server(port):\r\n</p>\r\n<p>\r\n	s = socket.socket()\r\n</p>\r\n<p>\r\n	s.bind((\'0.0.0.0\', port))\r\n</p>\r\n<p>\r\n	s.listen(500)\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	cli, addr = s.accept()\r\n</p>\r\n<p>\r\n	gevent.spawn(handle_request, cli)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def handle_request(conn):\r\n</p>\r\n<p>\r\n	try:\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	data = conn.recv(1024)\r\n</p>\r\n<p>\r\n	print(\"recv:\", data)\r\n</p>\r\n<p>\r\n	conn.send(data)\r\n</p>\r\n<p>\r\n	if not data:\r\n</p>\r\n<p>\r\n	conn.shutdown(socket.SHUT_WR)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	except Exception as  ex:\r\n</p>\r\n<p>\r\n	print(ex)\r\n</p>\r\n<p>\r\n	finally:\r\n</p>\r\n<p>\r\n	conn.close()\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	server(8001)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client side\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	HOST = \'localhost\'    # The remote host\r\n</p>\r\n<p>\r\n	PORT = 8001           # The same port as used by the server\r\n</p>\r\n<p>\r\n	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n</p>\r\n<p>\r\n	s.connect((HOST, PORT))\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	msg = bytes(input(\"&gt;&gt;:\"),encoding=\"utf8\")\r\n</p>\r\n<p>\r\n	s.sendall(msg)\r\n</p>\r\n<p>\r\n	data = s.recv(1024)\r\n</p>\r\n<p>\r\n	#print(data)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\'Received\', repr(data))\r\n</p>\r\n<p>\r\n	s.close()\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	import threading\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def sock_conn():\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client = socket.socket()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	client.connect((\"localhost\",8001))\r\n</p>\r\n<p>\r\n	count = 0\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	#msg = input(\"&gt;&gt;:\").strip()\r\n</p>\r\n<p>\r\n	#if len(msg) == 0:continue\r\n</p>\r\n<p>\r\n	client.send( (\"hello %s\" %count).encode(\"utf-8\"))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	data = client.recv(1024)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\"[%s]recv from server:\" % threading.get_ident(),data.decode()) #结果\r\n</p>\r\n<p>\r\n	count +=1\r\n</p>\r\n<p>\r\n	client.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for i in range(100):\r\n</p>\r\n<p>\r\n	t = threading.Thread(target=sock_conn)\r\n</p>\r\n<p>\r\n	t.start()\r\n</p>\r\n<p>\r\n	并发100个sock连接\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	论事件驱动与异步IO\r\n</p>\r\n<p>\r\n	通常，我们写服务器处理模型的程序时，有以下几种模型：\r\n</p>\r\n<p>\r\n	（1）每收到一个请求，创建一个新的进程，来处理该请求；\r\n</p>\r\n<p>\r\n	（2）每收到一个请求，创建一个新的线程，来处理该请求；\r\n</p>\r\n<p>\r\n	（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求\r\n</p>\r\n<p>\r\n	上面的几种方式，各有千秋，\r\n</p>\r\n<p>\r\n	第（1）中方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。\r\n</p>\r\n<p>\r\n	第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。\r\n</p>\r\n<p>\r\n	第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。\r\n</p>\r\n<p>\r\n	综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	看图说话讲事件驱动模型\r\n</p>\r\n<p>\r\n	在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：1. CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？2. 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；3. 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；所以，该方式是非常不好的。方式二：就是事件驱动模型目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：1. 有一个事件（消息）队列；2. 鼠标按下时，往这个队列中增加一个点击事件（消息）；3. 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；4. 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。\r\n</p>\r\n<p>\r\n	让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。\r\n</p>\r\n<p>\r\n	在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。\r\n</p>\r\n<p>\r\n	在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。\r\n</p>\r\n<p>\r\n	当我们面对如下的环境时，事件驱动模型通常是一个好的选择：\r\n</p>\r\n<p>\r\n	程序中有许多任务，而且…\r\n</p>\r\n<p>\r\n	任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…\r\n</p>\r\n<p>\r\n	在等待事件到来时，某些任务会阻塞。\r\n</p>\r\n<p>\r\n	当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。\r\n</p>\r\n<p>\r\n	网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	此处要提出一个问题，就是，上面的事件驱动模型中，只要一遇到IO就注册一个事件，然后主程序就可以继续干其它的事情了，只到io处理完毕后，继续恢复之前中断的任务，这本质上是怎么实现的呢？哈哈，下面我们就来一起揭开这神秘的面纱。。。。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Select\\Poll\\Epoll异步IO\r\n</p>\r\n<p>\r\n	http://www.cnblogs.com/alex3714/p/4372426.html\r\n</p>\r\n<p>\r\n	番外篇 http://www.cnblogs.com/alex3714/articles/5876749.html\r\n</p>\r\n<p>\r\n	select 多并发socket 例子\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	__author__ = \'Alex Li\'\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	import select\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	import queue\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server = socket.socket()\r\n</p>\r\n<p>\r\n	server.setblocking(0)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server_addr = (\'localhost\',10000)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\'starting up on %s port %s\' % server_addr)\r\n</p>\r\n<p>\r\n	server.bind(server_addr)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	server.listen(5)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	inputs = [server, ] #自己也要监测呀,因为server本身也是个fd\r\n</p>\r\n<p>\r\n	outputs = []\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	message_queues = {}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	print(\"waiting for next event...\")\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	readable, writeable, exeptional = select.select(inputs,outputs,inputs) #如果没有任何fd就绪,那程序就会一直阻塞在这里\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for s in readable: #每个s就是一个socket\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if s is server: #别忘记,上面我们server自己也当做一个fd放在了inputs列表里,传给了select,如果这个s是server,代表server这个fd就绪了,\r\n</p>\r\n<p>\r\n	#就是有活动了, 什么情况下它才有活动? 当然 是有新连接进来的时候 呀\r\n</p>\r\n<p>\r\n	#新连接进来了,接受这个连接\r\n</p>\r\n<p>\r\n	conn, client_addr = s.accept()\r\n</p>\r\n<p>\r\n	print(\"new connection from\",client_addr)\r\n</p>\r\n<p>\r\n	conn.setblocking(0)\r\n</p>\r\n<p>\r\n	inputs.append(conn) #为了不阻塞整个程序,我们不会立刻在这里开始接收客户端发来的数据, 把它放到inputs里, 下一次loop时,这个新连接\r\n</p>\r\n<p>\r\n	#就会被交给select去监听,如果这个连接的客户端发来了数据 ,那这个连接的fd在server端就会变成就续的,select就会把这个连接返回,返回到\r\n</p>\r\n<p>\r\n	#readable 列表里,然后你就可以loop readable列表,取出这个连接,开始接收数据了, 下面就是这么干 的\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	message_queues[conn] = queue.Queue() #接收到客户端的数据后,不立刻返回 ,暂存在队列里,以后发送\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	else: #s不是server的话,那就只能是一个 与客户端建立的连接的fd了\r\n</p>\r\n<p>\r\n	#客户端的数据过来了,在这接收\r\n</p>\r\n<p>\r\n	data = s.recv(1024)\r\n</p>\r\n<p>\r\n	if data:\r\n</p>\r\n<p>\r\n	print(\"收到来自[%s]的数据:\" % s.getpeername()[0], data)\r\n</p>\r\n<p>\r\n	message_queues[s].put(data) #收到的数据先放到queue里,一会返回给客户端\r\n</p>\r\n<p>\r\n	if s not  in outputs:\r\n</p>\r\n<p>\r\n	outputs.append(s) #为了不影响处理与其它客户端的连接 , 这里不立刻返回数据给客户端\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	else:#如果收不到data代表什么呢? 代表客户端断开了呀\r\n</p>\r\n<p>\r\n	print(\"客户端断开了\",s)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if s in outputs:\r\n</p>\r\n<p>\r\n	outputs.remove(s) #清理已断开的连接\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	inputs.remove(s) #清理已断开的连接\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	del message_queues[s] ##清理已断开的连接\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for s in writeable:\r\n</p>\r\n<p>\r\n	try :\r\n</p>\r\n<p>\r\n	next_msg = message_queues[s].get_nowait()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	except queue.Empty:\r\n</p>\r\n<p>\r\n	print(\"client [%s]\" %s.getpeername()[0], \"queue is empty..\")\r\n</p>\r\n<p>\r\n	outputs.remove(s)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	else:\r\n</p>\r\n<p>\r\n	print(\"sending msg to [%s]\"%s.getpeername()[0], next_msg)\r\n</p>\r\n<p>\r\n	s.send(next_msg.upper())\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for s in exeptional:\r\n</p>\r\n<p>\r\n	print(\"handling exception for \",s.getpeername())\r\n</p>\r\n<p>\r\n	inputs.remove(s)\r\n</p>\r\n<p>\r\n	if s in outputs:\r\n</p>\r\n<p>\r\n	outputs.remove(s)\r\n</p>\r\n<p>\r\n	s.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	del message_queues[s]\r\n</p>\r\n<p>\r\n	select socket server\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	__author__ = \'Alex Li\'\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	messages = [ b\'This is the message. \',\r\n</p>\r\n<p>\r\n	b\'It will be sent \',\r\n</p>\r\n<p>\r\n	b\'in parts.\',\r\n</p>\r\n<p>\r\n	]\r\n</p>\r\n<p>\r\n	server_address = (\'localhost\', 10000)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Create a TCP/IP socket\r\n</p>\r\n<p>\r\n	socks = [ socket.socket(socket.AF_INET, socket.SOCK_STREAM),\r\n</p>\r\n<p>\r\n	socket.socket(socket.AF_INET, socket.SOCK_STREAM),\r\n</p>\r\n<p>\r\n	]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Connect the socket to the port where the server is listening\r\n</p>\r\n<p>\r\n	print(\'connecting to %s port %s\' % server_address)\r\n</p>\r\n<p>\r\n	for s in socks:\r\n</p>\r\n<p>\r\n	s.connect(server_address)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for message in messages:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Send messages on both sockets\r\n</p>\r\n<p>\r\n	for s in socks:\r\n</p>\r\n<p>\r\n	print(\'%s: sending \"%s\"\' % (s.getsockname(), message) )\r\n</p>\r\n<p>\r\n	s.send(message)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Read responses on both sockets\r\n</p>\r\n<p>\r\n	for s in socks:\r\n</p>\r\n<p>\r\n	data = s.recv(1024)\r\n</p>\r\n<p>\r\n	print( \'%s: received \"%s\"\' % (s.getsockname(), data) )\r\n</p>\r\n<p>\r\n	if not data:\r\n</p>\r\n<p>\r\n	print(sys.stderr, \'closing socket\', s.getsockname() )\r\n</p>\r\n<p>\r\n	select socket client\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	selectors模块\r\n</p>\r\n<p>\r\n	This module allows high-level and efficient I/O multiplexing, built upon the&nbsp;select&nbsp;module primitives. Users are encouraged to use this module instead, unless they want precise control over the OS-level primitives used.\r\n</p>\r\n<p>\r\n	import selectors\r\n</p>\r\n<p>\r\n	import socket\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sel = selectors.DefaultSelector()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def accept(sock, mask):\r\n</p>\r\n<p>\r\n	conn, addr = sock.accept()  # Should be ready\r\n</p>\r\n<p>\r\n	print(\'accepted\', conn, \'from\', addr)\r\n</p>\r\n<p>\r\n	conn.setblocking(False)\r\n</p>\r\n<p>\r\n	sel.register(conn, selectors.EVENT_READ, read)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def read(conn, mask):\r\n</p>\r\n<p>\r\n	data = conn.recv(1000)  # Should be ready\r\n</p>\r\n<p>\r\n	if data:\r\n</p>\r\n<p>\r\n	print(\'echoing\', repr(data), \'to\', conn)\r\n</p>\r\n<p>\r\n	conn.send(data)  # Hope it won\'t block\r\n</p>\r\n<p>\r\n	else:\r\n</p>\r\n<p>\r\n	print(\'closing\', conn)\r\n</p>\r\n<p>\r\n	sel.unregister(conn)\r\n</p>\r\n<p>\r\n	conn.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	sock = socket.socket()\r\n</p>\r\n<p>\r\n	sock.bind((\'localhost\', 10000))\r\n</p>\r\n<p>\r\n	sock.listen(100)\r\n</p>\r\n<p>\r\n	sock.setblocking(False)\r\n</p>\r\n<p>\r\n	sel.register(sock, selectors.EVENT_READ, accept)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	while True:\r\n</p>\r\n<p>\r\n	events = sel.select()\r\n</p>\r\n<p>\r\n	for key, mask in events:\r\n</p>\r\n<p>\r\n	callback = key.data\r\n</p>\r\n<p>\r\n	callback(key.fileobj, mask)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	数据库操作与Paramiko模块\r\n</p>\r\n<p>\r\n	http://www.cnblogs.com/wupeiqi/articles/5095821.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	RabbitMQ队列\r\n</p>\r\n<p>\r\n	安装&nbsp;http://www.rabbitmq.com/install-standalone-mac.html\r\n</p>\r\n<p>\r\n	安装python rabbitMQ module\r\n</p>\r\n<p>\r\n	pip install pika\r\n</p>\r\n<p>\r\n	or\r\n</p>\r\n<p>\r\n	easy_install pika\r\n</p>\r\n<p>\r\n	or\r\n</p>\r\n<p>\r\n	源码\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	https://pypi.python.org/pypi/pika\r\n</p>\r\n<p>\r\n	实现最简单的队列通信\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	send端\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#声明queue\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'hello\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#n RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange.\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=\'hello\',\r\n</p>\r\n<p>\r\n	body=\'Hello World!\')\r\n</p>\r\n<p>\r\n	print(\" [x] Sent \'Hello World!\'\")\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	receive端\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	__author__ = \'Alex Li\'\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#You may ask why we declare the queue again ‒ we have already declared it in our previous code.\r\n</p>\r\n<p>\r\n	# We could avoid that if we were sure that the queue already exists. For example if send.py program\r\n</p>\r\n<p>\r\n	#was run before. But we\'re not yet sure which program to run first. In such cases it\'s a good\r\n</p>\r\n<p>\r\n	# practice to repeat declaring the queue in both programs.\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'hello\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] Received %r\" % body)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=\'hello\',\r\n</p>\r\n<p>\r\n	no_ack=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for messages. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Work Queues\r\n</p>\r\n<p>\r\n	在这种模式下，RabbitMQ会默认把p发的消息依次分发给各个消费者(c),跟负载均衡差不多\r\n</p>\r\n<p>\r\n	消息提供者代码\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import time\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# 声明queue\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'task_queue\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# n RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange.\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	message = \' \'.join(sys.argv[1:]) or \"Hello World! %s\" % time.time()\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=\'task_queue\',\r\n</p>\r\n<p>\r\n	body=message,\r\n</p>\r\n<p>\r\n	properties=pika.BasicProperties(\r\n</p>\r\n<p>\r\n	delivery_mode=2,  # make message persistent\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	print(\" [x] Sent %r\" % message)\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	消费者代码\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	import pika, time\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] Received %r\" % body)\r\n</p>\r\n<p>\r\n	time.sleep(20)\r\n</p>\r\n<p>\r\n	print(\" [x] Done\")\r\n</p>\r\n<p>\r\n	print(\"method.delivery_tag\",method.delivery_tag)\r\n</p>\r\n<p>\r\n	ch.basic_ack(delivery_tag=method.delivery_tag)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=\'task_queue\',\r\n</p>\r\n<p>\r\n	no_ack=True\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for messages. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	此时，先启动消息生产者，然后再分别启动3个消费者，通过生产者多发送几条消息，你会发现，这几条消息会被依次分配到各个消费者身上\r\n</p>\r\n<p>\r\n	Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code once RabbitMQ delivers message to the customer it immediately removes it from memory. In this case, if you kill a worker we will lose the message it was just processing. We\'ll also lose all the messages that were dispatched to this particular worker but were not yet handled.\r\n</p>\r\n<p>\r\n	But we don\'t want to lose any tasks. If a worker dies, we\'d like the task to be delivered to another worker.\r\n</p>\r\n<p>\r\n	In order to make sure a message is never lost, RabbitMQ supports message&nbsp;acknowledgments. An ack(nowledgement) is sent back from the consumer to tell RabbitMQ that a particular message had been received, processed and that RabbitMQ is free to delete it.\r\n</p>\r\n<p>\r\n	If a consumer dies (its channel is closed, connection is closed, or TCP connection is lost) without sending an ack, RabbitMQ will understand that a message wasn\'t processed fully and will re-queue it. If there are other consumers online at the same time, it will then quickly redeliver it to another consumer. That way you can be sure that no message is lost, even if the workers occasionally die.\r\n</p>\r\n<p>\r\n	There aren\'t any message timeouts; RabbitMQ will redeliver the message when the consumer dies. It\'s fine even if processing a message takes a very, very long time.\r\n</p>\r\n<p>\r\n	Message acknowledgments are turned on by default. In previous examples we explicitly turned them off via the&nbsp;no_ack=True&nbsp;flag. It\'s time to remove this flag and send a proper acknowledgment from the worker, once we\'re done with a task.\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print \" [x] Received %r\" % (body,)\r\n</p>\r\n<p>\r\n	time.sleep( body.count(\'.\') )\r\n</p>\r\n<p>\r\n	print \" [x] Done\"\r\n</p>\r\n<p>\r\n	ch.basic_ack(delivery_tag = method.delivery_tag)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=\'hello\')\r\n</p>\r\n<p>\r\n	Using this code we can be sure that even if you kill a worker using CTRL+C while it was processing a message, nothing will be lost. Soon after the worker dies all unacknowledged messages will be redelivered\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	消息持久化\r\n</p>\r\n<p>\r\n	We have learned how to make sure that even if the consumer dies, the task isn\'t lost(by default, if wanna disable &nbsp;use no_ack=True). But our tasks will still be lost if RabbitMQ server stops.\r\n</p>\r\n<p>\r\n	When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. Two things are required to make sure that messages aren\'t lost: we need to mark both the queue and messages as durable.\r\n</p>\r\n<p>\r\n	First, we need to make sure that RabbitMQ will never lose our queue. In order to do so, we need to declare it as&nbsp;durable:\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'hello\', durable=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Although this command is correct by itself, it won\'t work in our setup. That\'s because we\'ve already defined a queue called&nbsp;hello&nbsp;which is not durable. RabbitMQ doesn\'t allow you to redefine an existing queue with different parameters and will return an error to any program that tries to do that. But there is a quick workaround - let\'s declare a queue with different name, for exampletask_queue:\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'task_queue\', durable=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	This&nbsp;queue_declare&nbsp;change needs to be applied to both the producer and consumer code.\r\n</p>\r\n<p>\r\n	At that point we\'re sure that the&nbsp;task_queue&nbsp;queue won\'t be lost even if RabbitMQ restarts. Now we need to mark our messages as persistent - by supplying a&nbsp;delivery_mode&nbsp;property with a value&nbsp;2.\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=\"task_queue\",\r\n</p>\r\n<p>\r\n	body=message,\r\n</p>\r\n<p>\r\n	properties=pika.BasicProperties(\r\n</p>\r\n<p>\r\n	delivery_mode = 2, # make message persistent\r\n</p>\r\n<p>\r\n	))\r\n</p>\r\n<p>\r\n	消息公平分发\r\n</p>\r\n<p>\r\n	如果Rabbit只管按顺序把消息发到各个消费者身上，不考虑消费者负载的话，很可能出现，一个机器配置不高的消费者那里堆积了很多消息处理不完，同时配置高的消费者却一直很轻松。为解决此问题，可以在各个消费者端，配置perfetch=1,意思就是告诉RabbitMQ在我这个消费者当前消息还没处理完的时候就不要再给我发新消息了。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_qos(prefetch_count=1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	带消息持久化+公平分发的完整代码\r\n</p>\r\n<p>\r\n	生产者端\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'task_queue\', durable=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	message = \' \'.join(sys.argv[1:]) or \"Hello World!\"\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=\'task_queue\',\r\n</p>\r\n<p>\r\n	body=message,\r\n</p>\r\n<p>\r\n	properties=pika.BasicProperties(\r\n</p>\r\n<p>\r\n	delivery_mode = 2, # make message persistent\r\n</p>\r\n<p>\r\n	))\r\n</p>\r\n<p>\r\n	print(\" [x] Sent %r\" % message)\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	消费者端\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import time\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'task_queue\', durable=True)\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for messages. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] Received %r\" % body)\r\n</p>\r\n<p>\r\n	time.sleep(body.count(b\'.\'))\r\n</p>\r\n<p>\r\n	print(\" [x] Done\")\r\n</p>\r\n<p>\r\n	ch.basic_ack(delivery_tag = method.delivery_tag)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_qos(prefetch_count=1)\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=\'task_queue\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Publish\\Subscribe(消息发布\\订阅)\r\n</p>\r\n<p>\r\n	之前的例子都基本都是1对1的消息发送和接收，即消息只能发送到指定的queue里，但有些时候你想让你的消息被所有的Queue收到，类似广播的效果，这时候就要用到exchange了，\r\n</p>\r\n<p>\r\n	An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the&nbsp;exchange type.\r\n</p>\r\n<p>\r\n	Exchange在定义的时候是有类型的，以决定到底是哪些Queue符合条件，可以接收消息\r\n</p>\r\n<p>\r\n	fanout:&nbsp;所有bind到此exchange的queue都可以接收消息direct:&nbsp;通过routingKey和exchange决定的那个唯一的queue可以接收消息topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息　　&nbsp;表达式符号说明：#代表一个或多个字符，*代表任何字符&nbsp; &nbsp; &nbsp; 例：#.a会匹配a.a，aa.a，aaa.a等&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *.a会匹配a.a，b.a，c.a等&nbsp; &nbsp; &nbsp;注：使用RoutingKey为#，Exchange Type为topic的时候相当于使用fanout\r\n</p>\r\n<p>\r\n	headers: 通过headers 来决定把消息发给哪些queue\r\n</p>\r\n<p>\r\n	消息publisher\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'logs\',\r\n</p>\r\n<p>\r\n	type=\'fanout\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	message = \' \'.join(sys.argv[1:]) or \"info: Hello World!\"\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'logs\',\r\n</p>\r\n<p>\r\n	routing_key=\'\',\r\n</p>\r\n<p>\r\n	body=message)\r\n</p>\r\n<p>\r\n	print(\" [x] Sent %r\" % message)\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	消息subscriber\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	__author__ = \'Alex Li\'\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'logs\',\r\n</p>\r\n<p>\r\n	type=\'fanout\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	result = channel.queue_declare(exclusive=True) #不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除\r\n</p>\r\n<p>\r\n	queue_name = result.method.queue\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.queue_bind(exchange=\'logs\',\r\n</p>\r\n<p>\r\n	queue=queue_name)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for logs. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] %r\" % body)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=queue_name,\r\n</p>\r\n<p>\r\n	no_ack=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	有选择的接收消息(exchange type=direct)\r\n</p>\r\n<p>\r\n	RabbitMQ还支持根据关键字发送，即：队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。\r\n</p>\r\n<p>\r\n	publisher\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'direct_logs\',\r\n</p>\r\n<p>\r\n	type=\'direct\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	severity = sys.argv[1] if len(sys.argv) &gt; 1 else \'info\'\r\n</p>\r\n<p>\r\n	message = \' \'.join(sys.argv[2:]) or \'Hello World!\'\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'direct_logs\',\r\n</p>\r\n<p>\r\n	routing_key=severity,\r\n</p>\r\n<p>\r\n	body=message)\r\n</p>\r\n<p>\r\n	print(\" [x] Sent %r:%r\" % (severity, message))\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	subscriber\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'direct_logs\',\r\n</p>\r\n<p>\r\n	type=\'direct\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	result = channel.queue_declare(exclusive=True)\r\n</p>\r\n<p>\r\n	queue_name = result.method.queue\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	severities = sys.argv[1:]\r\n</p>\r\n<p>\r\n	if not severities:\r\n</p>\r\n<p>\r\n	sys.stderr.write(\"Usage: %s [info] [warning] [error]\\n\" % sys.argv[0])\r\n</p>\r\n<p>\r\n	sys.exit(1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for severity in severities:\r\n</p>\r\n<p>\r\n	channel.queue_bind(exchange=\'direct_logs\',\r\n</p>\r\n<p>\r\n	queue=queue_name,\r\n</p>\r\n<p>\r\n	routing_key=severity)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for logs. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] %r:%r\" % (method.routing_key, body))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=queue_name,\r\n</p>\r\n<p>\r\n	no_ack=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	更细致的消息过滤\r\n</p>\r\n<p>\r\n	Although using the&nbsp;direct&nbsp;exchange improved our system, it still has limitations - it can\'t do routing based on multiple criteria.\r\n</p>\r\n<p>\r\n	In our logging system we might want to subscribe to not only logs based on severity, but also based on the source which emitted the log. You might know this concept from the&nbsp;syslog&nbsp;unix tool, which routes logs based on both severity (info/warn/crit...) and facility (auth/cron/kern...).\r\n</p>\r\n<p>\r\n	That would give us a lot of flexibility - we may want to listen to just critical errors coming from \'cron\' but also all logs from \'kern\'.\r\n</p>\r\n<p>\r\n	publisher\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'topic_logs\',\r\n</p>\r\n<p>\r\n	type=\'topic\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else \'anonymous.info\'\r\n</p>\r\n<p>\r\n	message = \' \'.join(sys.argv[2:]) or \'Hello World!\'\r\n</p>\r\n<p>\r\n	channel.basic_publish(exchange=\'topic_logs\',\r\n</p>\r\n<p>\r\n	routing_key=routing_key,\r\n</p>\r\n<p>\r\n	body=message)\r\n</p>\r\n<p>\r\n	print(\" [x] Sent %r:%r\" % (routing_key, message))\r\n</p>\r\n<p>\r\n	connection.close()\r\n</p>\r\n<p>\r\n	subscriber\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.exchange_declare(exchange=\'topic_logs\',\r\n</p>\r\n<p>\r\n	type=\'topic\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	result = channel.queue_declare(exclusive=True)\r\n</p>\r\n<p>\r\n	queue_name = result.method.queue\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	binding_keys = sys.argv[1:]\r\n</p>\r\n<p>\r\n	if not binding_keys:\r\n</p>\r\n<p>\r\n	sys.stderr.write(\"Usage: %s [binding_key]...\\n\" % sys.argv[0])\r\n</p>\r\n<p>\r\n	sys.exit(1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for binding_key in binding_keys:\r\n</p>\r\n<p>\r\n	channel.queue_bind(exchange=\'topic_logs\',\r\n</p>\r\n<p>\r\n	queue=queue_name,\r\n</p>\r\n<p>\r\n	routing_key=binding_key)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\' [*] Waiting for logs. To exit press CTRL+C\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def callback(ch, method, properties, body):\r\n</p>\r\n<p>\r\n	print(\" [x] %r:%r\" % (method.routing_key, body))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_consume(callback,\r\n</p>\r\n<p>\r\n	queue=queue_name,\r\n</p>\r\n<p>\r\n	no_ack=True)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	To receive all the logs run:\r\n</p>\r\n<p>\r\n	python receive_logs_topic.py \"#\"\r\n</p>\r\n<p>\r\n	To receive all logs from the facility \"kern\":\r\n</p>\r\n<p>\r\n	python receive_logs_topic.py \"kern.*\"\r\n</p>\r\n<p>\r\n	Or if you want to hear only about \"critical\" logs:\r\n</p>\r\n<p>\r\n	python receive_logs_topic.py \"*.critical\"\r\n</p>\r\n<p>\r\n	You can create multiple bindings:\r\n</p>\r\n<p>\r\n	python receive_logs_topic.py \"kern.*\" \"*.critical\"\r\n</p>\r\n<p>\r\n	And to emit a log with a routing key \"kern.critical\" type:\r\n</p>\r\n<p>\r\n	python emit_log_topic.py \"kern.critical\" \"A critical kernel error\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Remote procedure call (RPC)\r\n</p>\r\n<p>\r\n	To illustrate how an RPC service could be used we\'re going to create a simple client class. It\'s going to expose a method named&nbsp;call&nbsp;which sends an RPC request and blocks until the answer is received:\r\n</p>\r\n<p>\r\n	fibonacci_rpc = FibonacciRpcClient()\r\n</p>\r\n<p>\r\n	result = fibonacci_rpc.call(4)\r\n</p>\r\n<p>\r\n	print(\"fib(4) is %r\" % result)\r\n</p>\r\n<p>\r\n	RPC server\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	__author__ = \'Alex Li\'\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import time\r\n</p>\r\n<p>\r\n	connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel = connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.queue_declare(queue=\'rpc_queue\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def fib(n):\r\n</p>\r\n<p>\r\n	if n == 0:\r\n</p>\r\n<p>\r\n	return 0\r\n</p>\r\n<p>\r\n	elif n == 1:\r\n</p>\r\n<p>\r\n	return 1\r\n</p>\r\n<p>\r\n	else:\r\n</p>\r\n<p>\r\n	return fib(n-1) + fib(n-2)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def on_request(ch, method, props, body):\r\n</p>\r\n<p>\r\n	n = int(body)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\" [.] fib(%s)\" % n)\r\n</p>\r\n<p>\r\n	response = fib(n)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ch.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=props.reply_to,\r\n</p>\r\n<p>\r\n	properties=pika.BasicProperties(correlation_id = \\\r\n</p>\r\n<p>\r\n	props.correlation_id),\r\n</p>\r\n<p>\r\n	body=str(response))\r\n</p>\r\n<p>\r\n	ch.basic_ack(delivery_tag = method.delivery_tag)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	channel.basic_qos(prefetch_count=1)\r\n</p>\r\n<p>\r\n	channel.basic_consume(on_request, queue=\'rpc_queue\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\" [x] Awaiting RPC requests\")\r\n</p>\r\n<p>\r\n	channel.start_consuming()\r\n</p>\r\n<p>\r\n	RPC client\r\n</p>\r\n<p>\r\n	import pika\r\n</p>\r\n<p>\r\n	import uuid\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class FibonacciRpcClient(object):\r\n</p>\r\n<p>\r\n	def __init__(self):\r\n</p>\r\n<p>\r\n	self.connection = pika.BlockingConnection(pika.ConnectionParameters(\r\n</p>\r\n<p>\r\n	host=\'localhost\'))\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	self.channel = self.connection.channel()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	result = self.channel.queue_declare(exclusive=True)\r\n</p>\r\n<p>\r\n	self.callback_queue = result.method.queue\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	self.channel.basic_consume(self.on_response, no_ack=True,\r\n</p>\r\n<p>\r\n	queue=self.callback_queue)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def on_response(self, ch, method, props, body):\r\n</p>\r\n<p>\r\n	if self.corr_id == props.correlation_id:\r\n</p>\r\n<p>\r\n	self.response = body\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def call(self, n):\r\n</p>\r\n<p>\r\n	self.response = None\r\n</p>\r\n<p>\r\n	self.corr_id = str(uuid.uuid4())\r\n</p>\r\n<p>\r\n	self.channel.basic_publish(exchange=\'\',\r\n</p>\r\n<p>\r\n	routing_key=\'rpc_queue\',\r\n</p>\r\n<p>\r\n	properties=pika.BasicProperties(\r\n</p>\r\n<p>\r\n	reply_to = self.callback_queue,\r\n</p>\r\n<p>\r\n	correlation_id = self.corr_id,\r\n</p>\r\n<p>\r\n	),\r\n</p>\r\n<p>\r\n	body=str(n))\r\n</p>\r\n<p>\r\n	while self.response is None:\r\n</p>\r\n<p>\r\n	self.connection.process_data_events()\r\n</p>\r\n<p>\r\n	return int(self.response)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	fibonacci_rpc = FibonacciRpcClient()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print(\" [x] Requesting fib(30)\")\r\n</p>\r\n<p>\r\n	response = fibonacci_rpc.call(30)\r\n</p>\r\n<p>\r\n	print(\" [.] Got %r\" % response)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Memcached &amp; Redis使用\r\n</p>\r\n<p>\r\n	memcached\r\n</p>\r\n<p>\r\n	http://www.cnblogs.com/wupeiqi/articles/5132791.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	redis 使用\r\n</p>\r\n<p>\r\n	http://www.cnblogs.com/alex3714/articles/6217453.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Twsited异步网络框架\r\n</p>\r\n<p>\r\n	Twisted是一个事件驱动的网络框架，其中包含了诸多功能，例如：网络协议、线程、数据库管理、网络操作、电子邮件等。\r\n</p>\r\n<p>\r\n	事件驱动\r\n</p>\r\n<p>\r\n	简而言之，事件驱动分为二个部分：第一，注册事件；第二，触发事件。\r\n</p>\r\n<p>\r\n	自定义事件驱动框架，命名为：“弑君者”：\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# event_drive.py\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	event_list = []\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def run():\r\n</p>\r\n<p>\r\n	for event in event_list:\r\n</p>\r\n<p>\r\n	obj = event()\r\n</p>\r\n<p>\r\n	obj.execute()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class BaseHandler(object):\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	用户必须继承该类，从而规范所有类的方法（类似于接口的功能）\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	def execute(self):\r\n</p>\r\n<p>\r\n	raise Exception(\'you must overwrite execute\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	最牛逼的事件驱动框架\r\n</p>\r\n<p>\r\n	程序员使用“弑君者框架”：\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from source import event_drive\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class MyHandler(event_drive.BaseHandler):\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def execute(self):\r\n</p>\r\n<p>\r\n	print \'event-drive execute MyHandler\'\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	event_drive.event_list.append(MyHandler)\r\n</p>\r\n<p>\r\n	event_drive.run()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Protocols\r\n</p>\r\n<p>\r\n	Protocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：\r\n</p>\r\n<p>\r\n	makeConnection               在transport对象和服务器之间建立一条连接\r\n</p>\r\n<p>\r\n	connectionMade               连接建立起来后调用\r\n</p>\r\n<p>\r\n	dataReceived                 接收数据时调用\r\n</p>\r\n<p>\r\n	connectionLost               关闭连接时调用\r\n</p>\r\n<p>\r\n	Transports\r\n</p>\r\n<p>\r\n	Transports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：\r\n</p>\r\n<p>\r\n	write                   以非阻塞的方式按顺序依次将数据写到物理连接上\r\n</p>\r\n<p>\r\n	writeSequence           将一个字符串列表写到物理连接上\r\n</p>\r\n<p>\r\n	loseConnection          将所有挂起的数据写入，然后关闭连接\r\n</p>\r\n<p>\r\n	getPeer                 取得连接中对端的地址信息\r\n</p>\r\n<p>\r\n	getHost                 取得连接中本端的地址信息\r\n</p>\r\n<p>\r\n	将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	EchoServer\r\n</p>\r\n<p>\r\n	from twisted.internet import protocol\r\n</p>\r\n<p>\r\n	from twisted.internet import reactor\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class Echo(protocol.Protocol):\r\n</p>\r\n<p>\r\n	def dataReceived(self, data):\r\n</p>\r\n<p>\r\n	self.transport.write(data)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def main():\r\n</p>\r\n<p>\r\n	factory = protocol.ServerFactory()\r\n</p>\r\n<p>\r\n	factory.protocol = Echo\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	reactor.listenTCP(1234,factory)\r\n</p>\r\n<p>\r\n	reactor.run()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	main()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	EchoClient\r\n</p>\r\n<p>\r\n	from twisted.internet import reactor, protocol\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# a client protocol\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class EchoClient(protocol.Protocol):\r\n</p>\r\n<p>\r\n	\"\"\"Once connected, send a message, then print the result.\"\"\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def connectionMade(self):\r\n</p>\r\n<p>\r\n	self.transport.write(\"hello alex!\")\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def dataReceived(self, data):\r\n</p>\r\n<p>\r\n	\"As soon as any data is received, write it back.\"\r\n</p>\r\n<p>\r\n	print \"Server said:\", data\r\n</p>\r\n<p>\r\n	self.transport.loseConnection()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def connectionLost(self, reason):\r\n</p>\r\n<p>\r\n	print \"connection lost\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class EchoFactory(protocol.ClientFactory):\r\n</p>\r\n<p>\r\n	protocol = EchoClient\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def clientConnectionFailed(self, connector, reason):\r\n</p>\r\n<p>\r\n	print \"Connection failed - goodbye!\"\r\n</p>\r\n<p>\r\n	reactor.stop()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def clientConnectionLost(self, connector, reason):\r\n</p>\r\n<p>\r\n	print \"Connection lost - goodbye!\"\r\n</p>\r\n<p>\r\n	reactor.stop()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# this connects the protocol to a server running on port 8000\r\n</p>\r\n<p>\r\n	def main():\r\n</p>\r\n<p>\r\n	f = EchoFactory()\r\n</p>\r\n<p>\r\n	reactor.connectTCP(\"localhost\", 1234, f)\r\n</p>\r\n<p>\r\n	reactor.run()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# this only runs if the module was *not* imported\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	main()\r\n</p>\r\n<p>\r\n	运行服务器端脚本将启动一个TCP服务器，监听端口1234上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。\r\n</p>\r\n<p>\r\n	一个传送文件的例子\r\n</p>\r\n<p>\r\n	server side\r\n</p>\r\n<p>\r\n	#_*_coding:utf-8_*_\r\n</p>\r\n<p>\r\n	# This is the Twisted Fast Poetry Server, version 1.0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	import optparse, os\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from twisted.internet.protocol import ServerFactory, Protocol\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def parse_args():\r\n</p>\r\n<p>\r\n	usage = \"\"\"usage: %prog [options] poetry-file\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	This is the Fast Poetry Server, Twisted edition.\r\n</p>\r\n<p>\r\n	Run it like this:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	python fastpoetry.py\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	If you are in the base directory of the twisted-intro package,\r\n</p>\r\n<p>\r\n	you could run it like this:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	python twisted-server-1/fastpoetry.py poetry/ecstasy.txt\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	to serve up John Donne\'s Ecstasy, which I know you want to do.\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	parser = optparse.OptionParser(usage)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	help = \"The port to listen on. Default to a random available port.\"\r\n</p>\r\n<p>\r\n	parser.add_option(\'--port\', type=\'int\', help=help)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	help = \"The interface to listen on. Default is localhost.\"\r\n</p>\r\n<p>\r\n	parser.add_option(\'--iface\', help=help, default=\'localhost\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	options, args = parser.parse_args()\r\n</p>\r\n<p>\r\n	print(\"--arg:\",options,args)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if len(args) != 1:\r\n</p>\r\n<p>\r\n	parser.error(\'Provide exactly one poetry file.\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	poetry_file = args[0]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if not os.path.exists(args[0]):\r\n</p>\r\n<p>\r\n	parser.error(\'No such file: %s\' % poetry_file)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	return options, poetry_file\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class PoetryProtocol(Protocol):\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def connectionMade(self):\r\n</p>\r\n<p>\r\n	self.transport.write(self.factory.poem)\r\n</p>\r\n<p>\r\n	self.transport.loseConnection()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class PoetryFactory(ServerFactory):\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	protocol = PoetryProtocol\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def __init__(self, poem):\r\n</p>\r\n<p>\r\n	self.poem = poem\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def main():\r\n</p>\r\n<p>\r\n	options, poetry_file = parse_args()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	poem = open(poetry_file).read()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	factory = PoetryFactory(poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from twisted.internet import reactor\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	port = reactor.listenTCP(options.port or 9000, factory,\r\n</p>\r\n<p>\r\n	interface=options.iface)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	print \'Serving %s on %s.\' % (poetry_file, port.getHost())\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	reactor.run()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	main()\r\n</p>\r\n<p>\r\n	client side\r\n</p>\r\n<p>\r\n	# This is the Twisted Get Poetry Now! client, version 3.0.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# NOTE: This should not be used as the basis for production code.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	import optparse\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from twisted.internet.protocol import Protocol, ClientFactory\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def parse_args():\r\n</p>\r\n<p>\r\n	usage = \"\"\"usage: %prog [options] [hostname]:port ...\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	This is the Get Poetry Now! client, Twisted version 3.0\r\n</p>\r\n<p>\r\n	Run it like this:\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	python get-poetry-1.py port1 port2 port3 ...\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	parser = optparse.OptionParser(usage)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	_, addresses = parser.parse_args()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if not addresses:\r\n</p>\r\n<p>\r\n	print parser.format_help()\r\n</p>\r\n<p>\r\n	parser.exit()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def parse_address(addr):\r\n</p>\r\n<p>\r\n	if \':\' not in addr:\r\n</p>\r\n<p>\r\n	host = \'127.0.0.1\'\r\n</p>\r\n<p>\r\n	port = addr\r\n</p>\r\n<p>\r\n	else:\r\n</p>\r\n<p>\r\n	host, port = addr.split(\':\', 1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if not port.isdigit():\r\n</p>\r\n<p>\r\n	parser.error(\'Ports must be integers.\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	return host, int(port)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	return map(parse_address, addresses)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class PoetryProtocol(Protocol):\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	poem = \'\'\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def dataReceived(self, data):\r\n</p>\r\n<p>\r\n	self.poem += data\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def connectionLost(self, reason):\r\n</p>\r\n<p>\r\n	self.poemReceived(self.poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def poemReceived(self, poem):\r\n</p>\r\n<p>\r\n	self.factory.poem_finished(poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class PoetryClientFactory(ClientFactory):\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	protocol = PoetryProtocol\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def __init__(self, callback):\r\n</p>\r\n<p>\r\n	self.callback = callback\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def poem_finished(self, poem):\r\n</p>\r\n<p>\r\n	self.callback(poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def get_poetry(host, port, callback):\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	Download a poem from the given host and port and invoke\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	callback(poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	when the poem is complete.\r\n</p>\r\n<p>\r\n	\"\"\"\r\n</p>\r\n<p>\r\n	from twisted.internet import reactor\r\n</p>\r\n<p>\r\n	factory = PoetryClientFactory(callback)\r\n</p>\r\n<p>\r\n	reactor.connectTCP(host, port, factory)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def poetry_main():\r\n</p>\r\n<p>\r\n	addresses = parse_args()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from twisted.internet import reactor\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	poems = []\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	def got_poem(poem):\r\n</p>\r\n<p>\r\n	poems.append(poem)\r\n</p>\r\n<p>\r\n	if len(poems) == len(addresses):\r\n</p>\r\n<p>\r\n	reactor.stop()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for address in addresses:\r\n</p>\r\n<p>\r\n	host, port = address\r\n</p>\r\n<p>\r\n	get_poetry(host, port, got_poem)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	reactor.run()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	for poem in poems:\r\n</p>\r\n<p>\r\n	print poem\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	poetry_main()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Twisted深入\r\n</p>\r\n<p>\r\n	http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/\r\n</p>\r\n<p>\r\n	http://blog.csdn.net/hanhuili/article/details/9389433\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	SqlAlchemy ORM\r\n</p>\r\n<p>\r\n	SQLAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简言之便是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果\r\n</p>\r\n<p>\r\n	Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如：\r\n</p>\r\n<p>\r\n	MySQL-Python\r\n</p>\r\n<p>\r\n	mysql+mysqldb://:@[:]/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	pymysql\r\n</p>\r\n<p>\r\n	mysql+pymysql://:@/[?]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MySQL-Connector\r\n</p>\r\n<p>\r\n	mysql+mysqlconnector://:@[:]/\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	cx_Oracle\r\n</p>\r\n<p>\r\n	oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	更多详见：http://docs.sqlalchemy.org/en/latest/dialects/index.html\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	步骤一：\r\n</p>\r\n<p>\r\n	使用 Engine/ConnectionPooling/Dialect 进行数据库操作，Engine使用ConnectionPooling连接数据库，然后再通过Dialect执行SQL语句。\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from sqlalchemy import create_engine\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	engine = create_engine(\"mysql+mysqldb://root:123@127.0.0.1:3306/s11\", max_overflow=5)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	engine.execute(\r\n</p>\r\n<p>\r\n	\"INSERT INTO ts_test (a, b) VALUES (\'2\', \'v1\')\"\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	engine.execute(\r\n</p>\r\n<p>\r\n	\"INSERT INTO ts_test (a, b) VALUES (%s, %s)\",\r\n</p>\r\n<p>\r\n	((555, \"v1\"),(666, \"v1\"),)\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	engine.execute(\r\n</p>\r\n<p>\r\n	\"INSERT INTO ts_test (a, b) VALUES (%(id)s, %(name)s)\",\r\n</p>\r\n<p>\r\n	id=999, name=\"v1\"\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	result = engine.execute(\'select * from ts_test\')\r\n</p>\r\n<p>\r\n	result.fetchall()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	步骤二：\r\n</p>\r\n<p>\r\n	使用 Schema Type/SQL Expression Language/Engine/ConnectionPooling/Dialect 进行数据库操作。Engine使用Schema Type创建一个特定的结构对象，之后通过SQL Expression Language将该对象转换成SQL语句，然后通过&nbsp;ConnectionPooling 连接数据库，再然后通过&nbsp;Dialect 执行SQL，并获取结果。\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, ForeignKey\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	metadata = MetaData()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	user = Table(\'user\', metadata,\r\n</p>\r\n<p>\r\n	Column(\'id\', Integer, primary_key=True),\r\n</p>\r\n<p>\r\n	Column(\'name\', String(20)),\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	color = Table(\'color\', metadata,\r\n</p>\r\n<p>\r\n	Column(\'id\', Integer, primary_key=True),\r\n</p>\r\n<p>\r\n	Column(\'name\', String(20)),\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	engine = create_engine(\"mysql+mysqldb://root@localhost:3306/test\", max_overflow=5)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	metadata.create_all(engine)\r\n</p>\r\n<p>\r\n	增删改查\r\n</p>\r\n<p>\r\n	#!/usr/bin/env python\r\n</p>\r\n<p>\r\n	# -*- coding:utf-8 -*-\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, ForeignKey\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	metadata = MetaData()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	user = Table(\'user\', metadata,\r\n</p>\r\n<p>\r\n	Column(\'id\', Integer, primary_key=True),\r\n</p>\r\n<p>\r\n	Column(\'name\', String(20)),\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	color = Table(\'color\', metadata,\r\n</p>\r\n<p>\r\n	Column(\'id\', Integer, primary_key=True),\r\n</p>\r\n<p>\r\n	Column(\'name\', String(20)),\r\n</p>\r\n<p>\r\n	)\r\n</p>\r\n<p>\r\n	engine = create_engine(\"mysql+mysqldb://root:123@127.0.0.1:3306/s11\", max_overflow=5)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	conn = engine.connect()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# 创建SQL语句，INSERT INTO \"user\" (id, name) VALUES (:id, :name)\r\n</p>\r\n<p>\r\n	conn.execute(user.insert(),{\'id\':7,\'name\':\'seven\'})\r\n</p>\r\n<p>\r\n	conn.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# sql = user.insert().values(id=123, name=\'wu\')\r\n</p>\r\n<p>\r\n	# conn.execute(sql)\r\n</p>\r\n<p>\r\n	# conn.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# sql = user.delete().where(user.c.id &gt; 1)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# sql = user.update().values(fullname=user.c.name)\r\n</p>\r\n<p>\r\n	# sql = user.update().where(user.c.name == \'jack\').values(name=\'ed\')\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# sql = select([user, ])\r\n</p>\r\n<p>\r\n	# sql = select([user.c.id, ])\r\n</p>\r\n<p>\r\n	# sql = select([user.c.name, color.c.name]).where(user.c.id==color.c.id)\r\n</p>\r\n<p>\r\n	# sql = select([user.c.name]).order_by(user.c.name)\r\n</p>\r\n<p>\r\n	# sql = select([user]).group_by(user.c.name)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# result = conn.execute(sql)\r\n</p>\r\n<p>\r\n	# print result.fetchall()\r\n</p>\r\n<p>\r\n	# conn.close()\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	一个简单的完整例子\r\n</p>\r\n<p>\r\n	from sqlalchemy import create_engine\r\n</p>\r\n<p>\r\n	from sqlalchemy.ext.declarative import declarative_base\r\n</p>\r\n<p>\r\n	from sqlalchemy import Column, Integer, String\r\n</p>\r\n<p>\r\n	from  sqlalchemy.orm import sessionmaker\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Base = declarative_base() #生成一个SqlORM 基类\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	engine = create_engine(\"mysql+mysqldb://root@localhost:3306/test\",echo=False)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	class Host(Base):\r\n</p>\r\n<p>\r\n	__tablename__ = \'hosts\'\r\n</p>\r\n<p>\r\n	id = Column(Integer,primary_key=True,autoincrement=True)\r\n</p>\r\n<p>\r\n	hostname = Column(String(64),unique=True,nullable=False)\r\n</p>\r\n<p>\r\n	ip_addr = Column(String(128),unique=True,nullable=False)\r\n</p>\r\n<p>\r\n	port = Column(Integer,default=22)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Base.metadata.create_all(engine) #创建所有表结构\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if __name__ == \'__main__\':\r\n</p>\r\n<p>\r\n	SessionCls = sessionmaker(bind=engine) #创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例\r\n</p>\r\n<p>\r\n	session = SessionCls()\r\n</p>\r\n<p>\r\n	#h1 = Host(hostname=\'localhost\',ip_addr=\'127.0.0.1\')\r\n</p>\r\n<p>\r\n	#h2 = Host(hostname=\'ubuntu\',ip_addr=\'192.168.2.243\',port=20000)\r\n</p>\r\n<p>\r\n	#h3 = Host(hostname=\'ubuntu2\',ip_addr=\'192.168.2.244\',port=20000)\r\n</p>\r\n<p>\r\n	#session.add(h3)\r\n</p>\r\n<p>\r\n	#session.add_all\r\n','2017-08-01 14:14:22',2,7,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('ae755cad-5608-4bcb-85fe-a94df6ace095','MySQL存储引擎之Myisam和Innodb总结性梳理','MySQL存储引擎之Myisam和Innodb总结性梳理','<p>\r\n	Mysql有两种存储引擎：InnoDB与Myisam，下表是两种引擎的简单对比\r\n</p>\r\n<p>\r\n	MyISAM InnoDB 构成上的区别：每个MyISAM在磁盘上存储成三个文件。第一个 文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩 展名为.MYD (MYData)。索引文件的扩 展名是.MYI (MYIndex)。\r\n</p>\r\n<p>\r\n	基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB&nbsp;表的 大小只受限于操作系统文件的大小，一般为&nbsp;2GB\r\n</p>\r\n<p>\r\n	事务处理上方面:\r\n</p>\r\n<p>\r\n	MyISAM类型的表强调的是性能，其执行数 度比InnoDB类型更快，但是不提供事务支持\r\n</p>\r\n<p>\r\n	InnoDB提供事务支持事务，外部键等高级 数据库功能\r\n</p>\r\n<p>\r\n	SELECT\r\n</p>\r\n<p>\r\n	UPDATE\r\n</p>\r\n<p>\r\n	INSERT\r\n</p>\r\n<p>\r\n	Delete\r\n</p>\r\n<p>\r\n	如果执行大量的SELECT，MyISAM是更好的选择\r\n</p>\r\n<p>\r\n	1.如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表2.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除。3.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用\r\n</p>\r\n<p>\r\n	对AUTO_INCREMENT的 操作\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	每表一个AUTO_INCREMEN列的内部处理。MyISAM为INSERT和UPDATE操 作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不 能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列， 可以出现重使用从序列顶部删除的值的情况）。AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置\r\n</p>\r\n<p>\r\n	对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但 是在MyISAM表中，可以和其他字段一起建立联 合索引\r\n</p>\r\n<p>\r\n	更好和更快的auto_increment处理\r\n</p>\r\n<p>\r\n	如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数 器的计数器，它被用在为该列赋新值。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	自动增长计数 器仅被存储在主内存中，而不是存在磁盘上\r\n</p>\r\n<p>\r\n	关于该计算器 的算法实现，请参考\r\n</p>\r\n<p>\r\n	AUTO_INCREMENT列 在InnoDB里 如何工作\r\n</p>\r\n<p>\r\n	表的具体行数\r\n</p>\r\n<p>\r\n	select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含&nbsp;where条件时，两种表的操作是一样的\r\n</p>\r\n<p>\r\n	InnoDB&nbsp;中不 保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行\r\n</p>\r\n<p>\r\n	锁\r\n</p>\r\n<p>\r\n	表锁\r\n</p>\r\n<p>\r\n	提供行锁(locking on row level)，提供与&nbsp;Oracle&nbsp;类型一致的不加锁读取(non-locking read inSELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执 行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MySQL存储引擎MyISAM与InnoDB如何选择MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。两种存储引擎的大致区别表现在：1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用3）InnoDB支持外键，MyISAM不支持4）从MySQL5.5.5以后，InnoDB是默认引擎5）InnoDB不支持FULLTEXT类型的索引6）InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like \'%lee%\'\r\n</p>\r\n<p>\r\n	关于MyISAM与InnoDB选择使用：MYISAM和INNODB是Mysql数据库提供的两种存储引擎。两者的优劣可谓是各有千秋。INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MYISAM不支持。MYISAM的性能更优，占用的存储空间少。所以，选择何种存储引擎，视具体应用而定：1）如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。2）如果你的应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。 有人说MYISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。 现在一般都是选用innodb了，主要是myisam的全表锁，读写串行问题，并发效率锁表，效率低myisam对于读写密集型应用一般是不会去选用的。\r\n</p>\r\n<p>\r\n	关于Mysql数据库默认的存储引擎：MyISAM和InnoDB是MySQL的两种存储引擎。如果是默认安装，那就应该是InnoDB，你可以在my.cnf文件中找到default-storage-engine=INNODB；当然你可以在建表时指定相应的存储引擎。通过show create table xx 可以看见相应信息。\r\n</p>\r\n<p>\r\n	Mysql中InnoDB和MyISAM的比较1）MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。MyISAM表格可以被压缩，而且它们支持全文搜索。不支持事务，而且也不支持外键。如果事物回滚将造成不完全回滚，不具有原子性。在进行updata时进行表锁，并发量相对较小。如果执行大量的SELECT，MyISAM是更好的选择。MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小MyISAM缓存在内存的是索引，不是数据。而InnoDB缓存在内存的是数据，相对来说，服务器内存越大，InnoDB发挥的优势越大。\r\n</p>\r\n<p>\r\n	优点：查询数据相对较快，适合大量的select，可以全文索引。缺点：不支持事务，不支持外键，并发量较小，不适合大量update\r\n</p>\r\n<p>\r\n	2）InnoDB：（参数说明：Mysql存储引擎之Innodb重要参数说明）这种类型是事务安全的。.它与BDB类型具有相同的特性,它们还支持外键。InnoDB表格速度很快。具有比BDB还丰富的特性,因此如果需要一个事务安全的存储引擎，建议使用它。在update时表进行行锁，并发量相对较大。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。优点：支持事务，支持外键，并发量较大，适合大量update缺点：查询数据相对较快，不适合大量的select对于支持事物的InnoDB类型的表，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。\r\n</p>\r\n<p>\r\n	基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('ae8ab1a5-2c73-490b-9ed3-e6b71e61deef','Mysql备份系列（3）--innobackupex备份mysql大数据(全量+增量）操作记录','Mysql备份系列（3）--innobackupex备份mysql大数据(全量+增量）操作记录','<p>\r\n	在日常的linux运维工作中，大数据量备份与还原，始终是个难点。关于mysql的备份和恢复，比较传统的是用mysqldump工具，今天这里推荐另一个备份工具innobackupex。innobackupex和mysqldump都可以对mysql进行热备份的，mysqldump对mysql的innodb的备份可以使用single-transaction参数来开启一个事务，利用innodb的mvcc来不进行锁表进行热备份，mysqldump备份是逻辑备份，备份出来的文件是sql语句，所以备份和恢复的时候很慢，但是备份和恢复时候很清楚。当MYSQL数据超过10G时，用mysqldump来导出备份就比较慢了，此种情况下用innobackupex这个工具就比mysqldump要快很多。利用它对mysql做全量和增量备份，仅仅依据本人实战操作做一记录，如有误述，敬请指出~\r\n</p>\r\n<p>\r\n	一、innobackupex的介绍\r\n</p>\r\n<p>\r\n	Xtrabackup是由percona开发的一个开源软件，是使用perl语言完成的脚本工具，能够非常快速地备份与恢复mysql数据库，且支持在线热备份（备份时不影响数据读写），此工具调用xtrabackup和tar4ibd工具，实现很多对性能要求并不高的任务和备份逻辑，可以说它是innodb热备工具ibbackup的一个开源替代品。\r\n</p>\r\n<p>\r\n	Xtrabackup中包含两个工具：\r\n</p>\r\n<p>\r\n	1）xtrabackup ：只能用于热备份innodb,xtradb两种数据引擎表的工具，不能备份其他表。\r\n</p>\r\n<p>\r\n	2）innobackupex：是一个对xtrabackup封装的perl脚本，提供了用于myisam(会锁表)和innodb引擎，及混合使用引擎备份的能力。主要是为了方便同时备份InnoDB和MyISAM引擎的表，但在处理myisam时需要加一个读锁。并且加入了一些使用的选项。如slave-info可以记录备份恢 复后，作为slave需要的一些信息，根据这些信息，可以很方便的利用备份来重做slave。innobackupex比xtarbackup有更强的功能，它整合了xtrabackup和其他的一些功能，它不但可以全量备份/恢复，还可以基于时间的增量备份与恢复。innobackupex同时支持innodb,myisam。\r\n</p>\r\n<p>\r\n	Xtrabackup可以做什么\r\n</p>\r\n<p>\r\n	1）在线(热)备份整个库的InnoDB, XtraDB表\r\n</p>\r\n<p>\r\n	2）在xtrabackup的上一次整库备份基础上做增量备份（innodb only）\r\n</p>\r\n<p>\r\n	3）以流的形式产生备份，可以直接保存到远程机器上（本机硬盘空间不足时很有用）\r\n</p>\r\n<p>\r\n	MySQL数据库本身提供的工具并不支持真正的增量备份，二进制日志恢复是point-in-time(时间点)的恢复而不是增量备份。Xtrabackup工具支持对InnoDB存储引擎的增量备份，\r\n</p>\r\n<p>\r\n	工作原理如下：\r\n</p>\r\n<p>\r\n	1）首先完成一个完全备份，并记录下此时检查点的LSN(Log Sequence Number)。\r\n</p>\r\n<p>\r\n	2）在进程增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，如果是，则备份该页，同时记录当前检查点的LSN。首先，在logfile中找到并记录最后一个checkpoint(“last checkpoint LSN”)，然后开始从LSN的位置开始拷贝InnoDB的logfile到xtrabackup_logfile；接着，开始拷贝全部的数据文件.ibd；在拷贝全部数据文件结束之后，才停止拷贝logfile。因为logfile里面记录全部的数据修改情况，所以，即时在备份过程中数据文件被修改过了，恢复时仍然能够通过解析xtrabackup_logfile保持数据的一致。\r\n</p>\r\n<p>\r\n	innobackupex备份mysql数据的流程innobackupex首先调用xtrabackup来备份innodb数据文件，当xtrabackup完成后，innobackupex就查看文件xtrabackup_suspended ；然后执行“FLUSH TABLES WITH READ LOCK”来备份其他的文件。\r\n</p>\r\n<p>\r\n	innobackupex恢复mysql数据的流程innobackupex首先读取my.cnf，查看变量(datadir,innodb_data_home_dir,innodb_data_file_path,innodb_log_group_home_dir)对应的目录是存在，确定相关目录存在后，然后先copy myisam表和索引，然后在copy innodb的表、索引和日志。\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------------------------------------------下面详细说下innobackupex备份和恢复的工作原理：\r\n</p>\r\n<p>\r\n	（1）备份的工作原理&nbsp; &nbsp; &nbsp; &nbsp;如果在程序启动阶段未指定模式，innobackupex将会默认以备份模式启动。&nbsp; &nbsp; &nbsp; &nbsp;默认情况下，此脚本以--suspend-at-end选项启动xtrabackup，然后xtrabackup程序开始拷贝InnoDB数据文件。当xtrabackup程序执行结束，innobackupex将会发现xtrabackup创建了xtrabackup_suspended_2文件，然后执行FLUSH TABLES WITH READ LOCK，此语句对所有的数据库表加读锁。然后开始拷贝其他类型的文件。&nbsp; &nbsp; &nbsp; &nbsp;如果--ibbackup未指定，innobackupex将会自行尝试确定使用的xtrabackup的binary。其确定binary的逻辑如下：首先判断备份目录中xtrabackup_binary文件是否存在，如果存在，此脚本将会依据此文件确定使用的xtrabackup binary。否则，脚本将会尝试连接database server，通过server版本确定binary。如果连接无法建立，xtrabackup将会失败，需要自行指定binary文件。&nbsp; &nbsp; &nbsp; &nbsp;在binary被确定后，将会检查到数据库server的连接是否可以建立。其执行逻辑是：建立连接、执行query、关闭连接。若一切正常，xtrabackup将以子进程的方式启动。&nbsp; &nbsp; &nbsp; &nbsp;FLUSH TABLES WITH READ LOCK是为了备份MyISAM和其他非InnoDB类型的表，此语句在xtrabackup已经备份InnoDB数据和日志文件后执行。在这之后，将会备份 .frm, .MRG, .MYD, .MYI, .TRG, .TRN, .ARM, .ARZ, .CSM, .CSV, .par, and .opt 类型的文件。&nbsp; &nbsp; &nbsp; &nbsp;当所有上述文件备份完成后，innobackupex脚本将会恢复xtrabackup的执行，等待其备份上述逻辑执行过程中生成的事务日志文件。接下来，表被解锁，slave被启动，到server的连接被关闭。接下来，脚本会删掉xtrabackup_suspended_2文件，允许xtrabackup进程退出。&nbsp;\r\n</p>\r\n<p>\r\n	（2）恢复的工作原理&nbsp; &nbsp; &nbsp; &nbsp;为了恢复一个备份，innobackupex需要以--copy-back选项启动。&nbsp; &nbsp; &nbsp; &nbsp;innobackupex将会首先通过my.cnf文件读取如下变量：datadir, innodb_data_home_dir, innodb_data_file_path, innodb_log_group_home_dir，并确定这些目录存在。&nbsp; &nbsp; &nbsp; &nbsp;接下来，此脚本将会首先拷贝MyISAM表、索引文件、其他类型的文件（如：.frm, .MRG, .MYD, .MYI, .TRG, .TRN, .ARM, .ARZ, .CSM, .CSV, par and .opt files），接下来拷贝InnoDB表数据文件，最后拷贝日志文件。拷贝执行时将会保留文件属性，在使用备份文件启动MySQL前，可能需要更改文件的owener（如从拷贝文件的user更改到mysql用户）。---------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	二、innobackupex针对mysql数据库的备份环境部署\r\n</p>\r\n<p>\r\n	1）源码安装Xtrabackup，将源码包下载到/usr/local/src下源码包下载\r\n</p>\r\n<p>\r\n	&nbsp;[root@test-huanqiu ~]# cd /usr/local/src\r\n</p>\r\n<p>\r\n	先安装依赖包\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]#&nbsp;yum -y install cmake gcc gcc-c++ libaio libaio-devel automake autoconf bzr bison libtool &nbsp;zlib-devel libgcrypt-devel &nbsp;libcurl-devel &nbsp;crypt* &nbsp;libgcrypt* python-sphinx openssl &nbsp; imake libxml2-devel expat-devel &nbsp; ncurses5-devel ncurses-devle &nbsp; vim-common &nbsp;libgpg-error-devel &nbsp; libidn-devel perl-DBI &nbsp;perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL&nbsp;\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# wget http://www.percona.com/downloads/XtraBackup/XtraBackup-2.1.9/source/percona-xtrabackup-2.1.9.tar.gz\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# tar -zvxf percona-xtrabackup-2.1.9.tar.gz\r\n</p>\r\n<p>\r\n	[root@test-huanqiu src]# cd percona-xtrabackup-2.1.9\r\n</p>\r\n<p>\r\n	[root@test-huanqiu percona-xtrabackup-2.1.9]# ./utils/build.sh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //执行该安装脚本，会出现下面信息Build an xtrabackup binary against the specified InnoDB flavor.\r\n</p>\r\n<p>\r\n	Usage: build.sh CODEBASEwhere CODEBASE can be one of the following values or aliases:  innodb51         | plugin                build against InnoDB plugin in MySQL 5.1  innodb55         | 5.5                   build against InnoDB in MySQL 5.5  innodb56         | 5.6,xtradb56,         build against InnoDB in MySQL 5.6                   | mariadb100,galera56  xtradb51         | xtradb,mariadb51      build against Percona Server with XtraDB 5.1                   | mariadb52,mariadb53  xtradb55         | galera55,mariadb55    build against Percona Server with XtraDB 5.5根据上面提示和你使用的存储引擎及版本，选择相应的参数即可。因为我用的是MySQL 5.6版本，所以执行如下语句安装：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu percona-xtrabackup-2.1.9]# ./utils/build.sh innodb56以上语句执行成功后，表示安装完成。最后，把生成的二进制文件拷贝到一个自定义目录下（本例中为/home/mysql/admin/bin/percona-xtrabackup-2.1.9），并把该目录放到环境变量PATH中。\r\n</p>\r\n<p>\r\n	[root@test-huanqiu&nbsp; percona-xtrabackup-2.1.9]# mkdir -p /home/mysql/admin/bin/percona-xtrabackup-2.1.9/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu&nbsp; percona-xtrabackup-2.1.9]# cp ./innobackupex /home/mysql/admin/bin/percona-xtrabackup-2.1.9/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu&nbsp; percona-xtrabackup-2.1.9]# cp ./src/xtrabackup_56 ./src/xbstream&nbsp;&nbsp;/home/mysql/admin/bin/percona-xtrabackup-2.1.9/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu&nbsp; percona-xtrabackup-2.1.9]# vim /etc/profile.......export PATH=$PATH:/home/mysql/admin/bin/percona-xtrabackup-2.1.9/\r\n</p>\r\n<p>\r\n	[root@test-huanqiu&nbsp; percona-xtrabackup-2.1.9]# source /etc/profile\r\n</p>\r\n<p>\r\n	测试下innobackupex是否正常使用\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  percona-xtrabackup-2.1.9]# innobackupex --help--------------------------------------------------------------------------------------------------------------------------------------------可能报错1\r\n</p>\r\n<p>\r\n	Can\'t locate Time/HiRes.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at /home/mysql/admin/bin/percona-xtrabackup-2.1.9/innobackupex line 23.BEGIN failed--compilation aborted at /home/mysql/admin/bin/percona-xtrabackup-2.1.9/innobackupex line 23.\r\n</p>\r\n<p>\r\n	解决方案：.pm实际上是Perl的包，只需安装perl-Time-HiRes即可：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  percona-xtrabackup-2.1.9]# yum install -y perl-Time-HiRes\r\n</p>\r\n<p>\r\n	可能报错2Can\'t locate DBI.pm in @INC (@INC contains: /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/site_perl/5.8.8 /usr/lib/perl5/site_perl /usr/lib64/perl5/vendor_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/vendor_perl/5.8.8 /usr/lib/perl5/vendor_perl /usr/lib64/perl5/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/5.8.8 .) at /usr/local/webserver/mysql5.1.57/bin/mysqlhotcopy line 25.  BEGIN failed--compilation aborted at /usr/local/webserver/mysql5.1.57/bin/mysqlhotcopy line 25.  报错原因：系统没有按安装DBI组件。DBI(Database Interface)是perl连接数据库的接口。其是perl连接数据库的最优秀方法，他支持包括Orcal,Sybase,mysql,db2等绝大多数的数据库。\r\n</p>\r\n<p>\r\n	解决办法：安装DBI组件（Can\'t locate DBI.pm in @INC-mysql接口）或者单独装DBI、Data-ShowTable、DBD-mysql 三个组件\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  percona-xtrabackup-2.1.9]# yum -y install perl-DBD-MySQL\r\n</p>\r\n<p>\r\n	接着使用innobackupex命令测试是否正常\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  percona-xtrabackup-2.1.9]#  innobackupex --helpOptions:    --apply-log        Prepare a backup in BACKUP-DIR by applying the transaction log file        named \"xtrabackup_logfile\" located in the same directory. Also,        create new transaction logs. The InnoDB configuration is read from        the file \"backup-my.cnf\".\r\n</p>\r\n<p>\r\n	--compact        Create a compact backup with all secondary index pages omitted. This        option is passed directly to xtrabackup. See xtrabackup        documentation for details.\r\n</p>\r\n<p>\r\n	--compress        This option instructs xtrabackup to compress backup copies of InnoDB        data files. It is passed directly to the xtrabackup child process.        Try \'xtrabackup --help\' for more details.............-------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）全量备份和恢复----------------&gt;全量备份操作&lt;----------------执行下面语句进行全备：mysql的安装目录是/usr/local/mysqlmysql的配置文件路径/usr/local/mysql/my.cnfmysql的密码是123456全量备份后的数据存放目录是/backup/mysql/data&nbsp;\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# mkdir -p /backup/mysql/data&nbsp;\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 /backup/mysql/data\r\n</p>\r\n<p>\r\n	InnoDB Backup Utility v1.5.1-xtrabackup; Copyright 2003, 2009 Innobase Oyand Percona LLC and/or its affiliates 2009-2013.  All Rights Reserved....................161201 00:07:15  innobackupex: Connecting to MySQL server with DSN \'dbi:mysql:;mysql_read_default_file=/usr/local/mysql/my.cnf;mysql_read_default_group=xtrabackup\' as \'root\'  (using password: YES).161201 00:07:15  innobackupex: Connected to MySQL server161201 00:07:15  innobackupex: Executing a version check against the server...161201 00:07:15  innobackupex: Done...................161201 00:07:19  innobackupex: Connection to database server closed161201 00:07:19  innobackupex: completed OK!\r\n</p>\r\n<p>\r\n	出现上面的信息，表示备份已经ok。\r\n</p>\r\n<p>\r\n	上面执行的备份语句会将mysql数据文件（即由my.cnf里的变量datadir指定）拷贝至备份目录下（/backup/mysql/data）注意：如果不指定--defaults-file，默认值为/etc/my.cnf。备份成功后，将在备份目录下创建一个时间戳目录（本例创建的目录为/backup/mysql/data/2016-12-01_00-07-15），在该目录下存放备份文件。\r\n</p>\r\n<p>\r\n	查看备份数据：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# ll  /backup/mysql/data total 4drwxr-xr-x. 6 root root 4096 Dec  1 00:07 2016-12-01_00-07-15\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# ll  /backup/mysql/data/2016-12-01_00-07-15/total 12324-rw-r--r--. 1 root root      357 Dec  1 00:07 backup-my.cnfdrwx------. 2 root root     4096 Dec  1 00:07 huanqiu-rw-r-----. 1 root root 12582912 Dec  1 00:07 ibdata1drwx------. 2 root root     4096 Dec  1 00:07 mysqldrwxr-xr-x. 2 root root     4096 Dec  1 00:07 performance_schemadrwxr-xr-x. 2 root root     4096 Dec  1 00:07 test-rw-r--r--. 1 root root       13 Dec  1 00:07 xtrabackup_binary-rw-r--r--. 1 root root       24 Dec  1 00:07 xtrabackup_binlog_info-rw-r-----. 1 root root       89 Dec  1 00:07 xtrabackup_checkpoints-rw-r-----. 1 root root     2560 Dec  1 00:07 xtrabackup_logfile\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------------------------------可能报错1：161130 05:56:48  innobackupex: Connecting to MySQL server with DSN \'dbi:mysql:;mysql_read_default_file=/usr/local/mysql/my.cnf;mysql_read_default_group=xtrabackup\' as \'root\'  (using password: YES).innobackupex: Error: Failed to connect to MySQL server as DBD::mysql module is not installed at /home/mysql/admin/bin/percona-xtrabackup-2.1.9/innobackupex line 2956.\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  ~]# yum -y install perl-DBD-MySQL.x86_64  ......Package perl-DBD-MySQL-4.013-3.el6.x86_64 already installed and latest version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//发现本机已经安装了\r\n</p>\r\n<p>\r\n	[root@test-huanqiu  ~]# rpm -qa|grep perl-DBD-MySQLperl-DBD-MySQL-4.013-3.el6.x86_64\r\n</p>\r\n<p>\r\n	发现本机已经安装了最新版的perl-DBD-MYSQL了，但是仍然报出上面的错误！！莫慌~~继续下面的操作进行问题的解决\r\n</p>\r\n<p>\r\n	查看mysql.so依赖的lib库\r\n</p>\r\n<p>\r\n	&nbsp;[root@test-huanqiu  ~]# ldd /usr/lib64/perl5/auto/DBD/mysql/mysql.so  linux-vdso.so.1 =&gt;  (0x00007ffd291fc000)  libmysqlclient.so.16 =&gt; not found &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //这一项为通过检查，缺失libmysqlclient.so.16库导致  libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f78ff9de000)  libcrypt.so.1 =&gt; /lib64/libcrypt.so.1 (0x00007f78ff7a7000)  libnsl.so.1 =&gt; /lib64/libnsl.so.1 (0x00007f78ff58e000)  libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f78ff309000)  libssl.so.10 =&gt; /usr/lib64/libssl.so.10 (0x00007f78ff09d000)  libcrypto.so.10 =&gt; /usr/lib64/libcrypto.so.10 (0x00007f78fecb9000)  libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f78fe924000)  libfreebl3.so =&gt; /lib64/libfreebl3.so (0x00007f78fe721000)  libgssapi_krb5.so.2 =&gt; /lib64/libgssapi_krb5.so.2 (0x00007f78fe4dd000)  libkrb5.so.3 =&gt; /lib64/libkrb5.so.3 (0x00007f78fe1f5000)  libcom_err.so.2 =&gt; /lib64/libcom_err.so.2 (0x00007f78fdff1000)  libk5crypto.so.3 =&gt; /lib64/libk5crypto.so.3 (0x00007f78fddc5000)  libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f78fdbc0000)  /lib64/ld-linux-x86-64.so.2 (0x00007f78ffe1d000)  libkrb5support.so.0 =&gt; /lib64/libkrb5support.so.0 (0x00007f78fd9b5000)  libkeyutils.so.1 =&gt; /lib64/libkeyutils.so.1 (0x00007f78fd7b2000)  libresolv.so.2 =&gt; /lib64/libresolv.so.2 (0x00007f78fd597000)  libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f78fd37a000)  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f78fd15a000)\r\n</p>\r\n<p>\r\n	以上结果说明缺少libmysqlclient.so.16这个二进制包，找个官方原版的mysql的libmysqlclient.so.16替换了即可！[root@test-huanqiu~]# find / -name libmysqlclient.so.16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //查看本机并没有libmysqlclient.so.16库文件\r\n</p>\r\n<p>\r\n	查看mysql/lib下的libmysqlclinet.so库文件\r\n</p>\r\n<p>\r\n	[root@test-huanqiu~]# ll /usr/local/mysql/lib/total 234596-rw-r--r--. 1 mysql mysql  19520800 Nov 29 12:27 libmysqlclient.alrwxrwxrwx. 1 mysql mysql        16 Nov 29 12:34 libmysqlclient_r.a -&gt; libmysqlclient.alrwxrwxrwx. 1 mysql mysql        17 Nov 29 12:34 libmysqlclient_r.so -&gt; libmysqlclient.solrwxrwxrwx. 1 mysql mysql        20 Nov 29 12:34 libmysqlclient_r.so.18 -&gt; libmysqlclient.so.18lrwxrwxrwx. 1 mysql mysql        24 Nov 29 12:34 libmysqlclient_r.so.18.1.0 -&gt; libmysqlclient.so.18.1.0lrwxrwxrwx. 1 mysql mysql        20 Nov 29 12:34 libmysqlclient.so -&gt; libmysqlclient.so.18lrwxrwxrwx. 1 mysql mysql        24 Nov 29 12:34 libmysqlclient.so.18 -&gt; libmysqlclient.so.18.1.0-rwxr-xr-x. 1 mysql mysql   8858235 Nov 29 12:27 libmysqlclient.so.18.1.0-rw-r--r--. 1 mysql mysql 211822074 Nov 29 12:34 libmysqld.a-rw-r--r--. 1 mysql mysql     14270 Nov 29 12:27 libmysqlservices.adrwxr-xr-x. 3 mysql mysql      4096 Nov 29 12:34 plugin\r\n</p>\r\n<p>\r\n	将mysql/lib/libmysqlclient.so.18.1.0库文件拷贝到/lib64下，拷贝后命名为libmysqlclient.so.16[root@test-huanqiu~]# cp /usr/local/mysql/lib/libmysqlclient.so.18.1.0 /lib64/libmysqlclient.so.16\r\n</p>\r\n<p>\r\n	[root@test-huanqiu~]# cat /etc/ld.so.confinclude ld.so.conf.d/*.conf/usr/local/mysql/lib/ /lib64/[root@test-huanqiu~]# ldconfig\r\n</p>\r\n<p>\r\n	最后卸载perl-DBD-MySQL，并重新安装perl-DBD-MySQL[root@test-huanqiu~]# rpm -qa|grep perl-DBD-MySQLperl-DBD-MySQL-4.013-3.el6.x86_64[root@test-huanqiu~]# rpm -e --nodeps perl-DBD-MySQL   [root@test-huanqiu~]# rpm -qa|grep perl-DBD-MySQL[root@test-huanqiu~]# yum -y install perl-DBD-MySQL\r\n</p>\r\n<p>\r\n	待重新安装后，再次重新检查mysql.so依赖的lib库，发现已经都通过了\r\n</p>\r\n<p>\r\n	[root@test-huanqiu~]# ldd /usr/lib64/perl5/auto/DBD/mysql/mysql.so  linux-vdso.so.1 =&gt;  (0x00007ffe3669b000)  libmysqlclient.so.16 =&gt; /usr/lib64/mysql/libmysqlclient.so.16 (0x00007f4af5c25000)  libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f4af5a0f000)  libcrypt.so.1 =&gt; /lib64/libcrypt.so.1 (0x00007f4af57d7000)  libnsl.so.1 =&gt; /lib64/libnsl.so.1 (0x00007f4af55be000)  libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f4af533a000)  libssl.so.10 =&gt; /usr/lib64/libssl.so.10 (0x00007f4af50cd000)  libcrypto.so.10 =&gt; /usr/lib64/libcrypto.so.10 (0x00007f4af4ce9000)  libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4af4955000)  libfreebl3.so =&gt; /lib64/libfreebl3.so (0x00007f4af4751000)  libgssapi_krb5.so.2 =&gt; /lib64/libgssapi_krb5.so.2 (0x00007f4af450d000)  libkrb5.so.3 =&gt; /lib64/libkrb5.so.3 (0x00007f4af4226000)  libcom_err.so.2 =&gt; /lib64/libcom_err.so.2 (0x00007f4af4021000)  libk5crypto.so.3 =&gt; /lib64/libk5crypto.so.3 (0x00007f4af3df5000)  libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f4af3bf1000)  /lib64/ld-linux-x86-64.so.2 (0x00007f4af61d1000)  libkrb5support.so.0 =&gt; /lib64/libkrb5support.so.0 (0x00007f4af39e5000)  libkeyutils.so.1 =&gt; /lib64/libkeyutils.so.1 (0x00007f4af37e2000)  libresolv.so.2 =&gt; /lib64/libresolv.so.2 (0x00007f4af35c8000)  libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f4af33aa000)  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f4af318b000)\r\n</p>\r\n<p>\r\n	可能报错2sh: xtrabackup_56: command not foundinnobackupex: Error: no \'mysqld\' group in MySQL options at /home/mysql/admin/bin/percona-xtrabackup-2.1.9/innobackupex line 4350.\r\n</p>\r\n<p>\r\n	有可能是percona-xtrabackup编译安装后，在编译目录的src下存在xtrabackup_innodb56，只需要其更名为xtrabackup_56，然后拷贝到上面的/home/mysql/admin/bin/percona-xtrabackup-2.1.9/下即可！----------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	还可以在远程进行全量备份，命令如下：\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 --host=127.0.0.1 --parallel=2 --throttle=200 /backup/mysql/data 2&gt;/backup/mysql/data/bak.log 1&gt;/backup/mysql/data/`data +%Y-%m-%d_%H-%M%S`参数解释：--user=root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 备份操作用户名，一般都是root用户  --password=root123 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;数据库密码--host=127.0.0.1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;主机ip，本地可以不加（适用于远程备份）。注意要提前在mysql中授予连接的权限，最好备份前先测试用命令中的用户名、密码和host能否正常连接mysql。--parallel=2 --throttle=200 &nbsp; &nbsp; &nbsp;并行个数，根据主机配置选择合适的，默认是1个，多个可以加快备份速度。/backup/mysql/data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;备份存放的目录2&gt;/backup/mysql/data/bak.log &nbsp; &nbsp; &nbsp; 备份日志，将备份过程中的输出信息重定向到bak.log\r\n</p>\r\n<p>\r\n	这种备份跟上面相比，备份成功后，不会自动在备份目录下创建一个时间戳目录，需要如上命令中自己定义。\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# cd /backup/mysql/data/[root@test-huanqiu data]# lldrwxr-xr-x. 6 root root     4096 Dec  1 03:18 2016-12-01_03-18-37-rw-r--r--. 1 root root     5148 Dec  1 03:18 bak.log[root@test-huanqiu data]# cat bak.log &nbsp; &nbsp; &nbsp; &nbsp; //备份信息都记录在这个日志里，如果备份失败，可以到这里日志里查询\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	----------------&gt;全量备份后的恢复操作&lt;----------------\r\n</p>\r\n<p>\r\n	比如在上面进行全量备份后，由于误操作将数据库中的huanqiu库删除了。[root@test-huanqiu ~]# mysql -p123456.......mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || huanqiu            || mysql              || performance_schema || test               |+--------------------+5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changedmysql&gt; show tables;+-------------------------+| Tables_in_huanqiu       |+-------------------------+| card_agent_file         || product_sale_management |+-------------------------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database huanqiu;Query OK, 2 rows affected (0.12 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || test               |+--------------------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	现在进行恢复数据操作注意：恢复之前1）要先关闭数据库2）要删除数据文件和日志文件（也可以mv移到别的地方，只要确保清空mysql数据存放目录就行）[root@test-huanqiu ~]# ps -ef|grep mysqlroot      2442 21929  0 00:25 pts/2    00:00:00 grep mysqlroot     28279     1  0 Nov29 ?        00:00:00 /bin/sh /usr/local/mysql//bin/mysqld_safe --datadir=/data/mysql/data --pid-file=/data/mysql/data/mysql.pidmysql    29059 28279  0 Nov29 ?        00:09:07 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql/ --datadir=/data/mysql/data --plugin-dir=/usr/local/mysql//lib/plugin --user=mysql --log-error=/data/mysql/data/mysql-error.log --pid-file=/data/mysql/data/mysql.pid --socket=/usr/local/mysql/var/mysql.sock --port=3306\r\n</p>\r\n<p>\r\n	由上面可查出mysql的数据和日志存放目录是/data/mysql/data[root@test-huanqiu ~]# /etc/init.d/mysql stopShutting down MySQL.. SUCCESS! [root@test-huanqiu ~]# rm -rf /data/mysql/data/*[root@test-huanqiu ~]# ls /data/mysql/data[root@test-huanqiu ~]#\r\n</p>\r\n<p>\r\n	查看备份数据[root@[root@test-huanqiu ~]# ls /backup/mysql/data/2016-12-01_00-07-15\r\n</p>\r\n<p>\r\n	恢复数据[root@[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 --use-memory=4G --apply-log /backup/mysql/data/2016-12-01_00-07-15[root@[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456  --copy-back /backup/mysql/data/2016-12-01_00-07-15........innobackupex: Copying \'/backup/mysql/data/2016-12-01_00-07-15/ib_logfile2\' to \'/data/mysql/data/ib_logfile2\'innobackupex: Copying \'/backup/mysql/data/2016-12-01_00-07-15/ib_logfile0\' to \'/data/mysql/data/ib_logfile0\'innobackupex: Finished copying back files.\r\n</p>\r\n<p>\r\n	161201 00:31:33  innobackupex: completed OK!出现上面的信息，说明数据恢复成功了！！\r\n</p>\r\n<p>\r\n	从上面的恢复操作可以看出，执行恢复分为两个步骤：1）第一步恢复步骤是应用日志（apply-log），为了加快速度，一般建议设置--use-memory（如果系统内存充足，可以使用加大内存进行备份&nbsp;），这个步骤完成之后，目录/backup/mysql/data/2016-12-01_00-07-15下的备份文件已经准备就绪。2）第二步恢复步骤是拷贝文件（copy-back），即把备份文件拷贝至原数据目录下。恢复完成之后，一定要记得检查数据目录的所有者和权限是否正确。\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# ll /data/mysql/data/total 110608drwxr-xr-x. 2 root root     4096 Dec  1 00:31 huanqiu-rw-r--r--. 1 root root 12582912 Dec  1 00:31 ibdata1-rw-r--r--. 1 root root 33554432 Dec  1 00:31 ib_logfile0-rw-r--r--. 1 root root 33554432 Dec  1 00:31 ib_logfile1-rw-r--r--. 1 root root 33554432 Dec  1 00:31 ib_logfile2drwxr-xr-x. 2 root root     4096 Dec  1 00:31 mysqldrwxr-xr-x. 2 root root     4096 Dec  1 00:31 performance_schemadrwxr-xr-x. 2 root root     4096 Dec  1 00:31 test[root@test-huanqiu ~]# chown -R mysql.mysql /data/mysql/data/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //将数据目录的权限修改为mysql:mysql [root@test-huanqiu ~]# ll /data/mysql/data/total 110608drwxr-xr-x. 2 mysql mysql     4096 Dec  1 00:31 huanqiu-rw-r--r--. 1 mysql mysql 12582912 Dec  1 00:31 ibdata1-rw-r--r--. 1 mysql mysql 33554432 Dec  1 00:31 ib_logfile0-rw-r--r--. 1 mysql mysql 33554432 Dec  1 00:31 ib_logfile1-rw-r--r--. 1 mysql mysql 33554432 Dec  1 00:31 ib_logfile2drwxr-xr-x. 2 mysql mysql     4096 Dec  1 00:31 mysqldrwxr-xr-x. 2 mysql mysql     4096 Dec  1 00:31 performance_schemadrwxr-xr-x. 2 mysql mysql     4096 Dec  1 00:31 test-------------------------------------------------------------------------------------------------------------------------------------------可能报错：sh: xtrabackup: command not foundinnobackupex: Error: no \'mysqld\' group in MySQL options at /home/mysql/admin/bin/percona-xtrabackup-2.1.9/innobackupex line 4350.\r\n</p>\r\n<p>\r\n	解决：将xtrabackup_56复制成xtrabackup即可[root@test-huanqiu percona-xtrabackup-2.1.9]# lsinnobackupex  xbstream  xtrabackup_56[root@test-huanqiu percona-xtrabackup-2.1.9]# cp xtrabackup_56 xtrabackup[root@test-huanqiu percona-xtrabackup-2.1.9]# lsinnobackupex  xbstream  xtrabackup  xtrabackup_56-------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	最后，启动mysql，查看数据是否恢复回来了[root@test-huanqiu ~]# /etc/init.d/mysql startStarting MySQL.. SUCCESS! [root@test-huanqiu ~]# mysql -p123456........mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || huanqiu            || mysql              || performance_schema || test               |+--------------------+5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changedmysql&gt; show tables;+-------------------------+| Tables_in_huanqiu       |+-------------------------+| card_agent_file         || product_sale_management |+-------------------------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	3）增量备份和恢复----------------&gt;增量备份操作&lt;----------------特别注意：innobackupex 增量备份仅针对InnoDB这类支持事务的引擎，对于MyISAM等引擎，则仍然是全备。\r\n</p>\r\n<p>\r\n	增量备份需要基于全量备份先假设我们已经有了一个全量备份（如上面的/backup/mysql/data/2016-12-01_00-07-15），我们需要在该全量备份的基础上做第一次增量备份。[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf  --user=root --password=123456 --incremental-basedir=/backup/mysql/data/2016-12-01_00-07-15 --incremental /backup/mysql/data 其中：--incremental-basedir &nbsp; &nbsp; 指向全量备份目录--incremental &nbsp; &nbsp; &nbsp; 指向增量备份的目录上面语句执行成功之后，会在--incremental执行的目录下创建一个时间戳子目录（本例中为：/backup/mysql/data/2016-12-01_01-12-22），在该目录下存放着增量备份的所有文件。[root@test-huanqiu ~]# ll /backup/mysql/data/total 8drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//全量备份目录drwxr-xr-x. 6 root root 4096 Dec  1 01:12 2016-12-01_01-12-22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//增量备份目录\r\n</p>\r\n<p>\r\n	在备份目录下，有一个文件xtrabackup_checkpoints记录着备份信息，其中可以查出1）全量备份的信息如下：[root@test-huanqiu 2016-12-01_00-07-15]# pwd/backup/mysql/data/2016-12-01_00-07-15[root@test-huanqiu 2016-12-01_00-07-15]# cat xtrabackup_checkpoints backup_type = full-preparedfrom_lsn = 0to_lsn = 1631561last_lsn = 1631561compact = 0\r\n</p>\r\n<p>\r\n	2）基于以上全量备份的增量备份的信息如下：[root@test-huanqiu 2016-12-01_01-12-22]# pwd/backup/mysql/data/2016-12-01_01-12-22[root@test-huanqiu 2016-12-01_01-12-22]# cat xtrabackup_checkpoints backup_type = incrementalfrom_lsn = 1631561to_lsn = 1631776last_lsn = 1631776compact = 0\r\n</p>\r\n<p>\r\n	从上面可以看出，增量备份的from_lsn正好等于全备的to_lsn。那么，我们是否可以在增量备份的基础上再做增量备份呢？答案是肯定的，只要把--incremental-basedir执行上一次增量备份的目录即可，如下所示：[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf  --user=root --password=123456 --incremental-basedir=/backup/mysql/data/2016-12-01_01-12-22 --incremental /backup/mysql/data [root@test-huanqiu data]# lltotal 12drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//全量备份目录drwxr-xr-x. 6 root root 4096 Dec  1 01:12 2016-12-01_01-12-22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//增量备份目录1drwxr-xr-x. 6 root root 4096 Dec  1 01:23 2016-12-01_01-23-23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //增量备份目录2\r\n</p>\r\n<p>\r\n	它的xtrabackup_checkpoints记录着备份信息如下：[root@test-huanqiu 2016-12-01_01-23-23]# pwd/backup/mysql/data/2016-12-01_01-23-23[root@test-huanqiu 2016-12-01_01-23-23]# cat xtrabackup_checkpoints backup_type = incrementalfrom_lsn = 1631776to_lsn = 1638220last_lsn = 1638220compact = 0\r\n</p>\r\n<p>\r\n	可以看到，第二次增量备份的from_lsn是从上一次增量备份的to_lsn开始的。\r\n</p>\r\n<p>\r\n	----------------&gt;增量备份后的恢复操作&lt;----------------增量备份的恢复要比全量备份复杂很多，增量备份与全量备份有着一些不同，尤其要注意的是：1)需要在每个备份(包括完全和各个增量备份)上，将已经提交的事务进行“重放”。“重放”之后，所有的备份数据将合并到完全备份上。2)基于所有的备份将未提交的事务进行“回滚”。于是，操作就变成了：不能回滚，因为有可能第一次备份时候没提交，在增量中已经成功提交\r\n</p>\r\n<p>\r\n	第一步是在所有备份目录下重做已提交的日志（注意备份目录路径要跟全路径）1）innobackupex --apply-log --redo-only BASE-DIR  2）innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-1  3）innobackupex --apply-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-2 其中：BASE-DIR   是指全量备份的目录INCREMENTAL-DIR-1    是指第一次增量备份的目录INCREMENTAL-DIR-2    是指第二次增量备份的目录，以此类推。这里要注意的是：1）最后一步的增量备份并没有--redo-only选项！回滚进行崩溃恢复过程2）可以使用--use_memory提高性能。以上语句执行成功之后，最终数据在BASE-DIR（即全量目录）下，其实增量备份就是把增量目录下的数据，整合到全变量目录下，然后在进行，全数据量的还原。\r\n</p>\r\n<p>\r\n	第一步完成之后，我们开始下面关键的第二步，即拷贝文件，进行全部还原！注意：必须先停止mysql数据库，然后清空数据库目录(这里是指/data/mysql/data)下的文件。\r\n</p>\r\n<p>\r\n	4）innobackupex --copy-back BASE-DIR 同样地，拷贝结束之后，记得检查下数据目录(这里指/data/mysql/data)的权限是否正确(修改成mysql:mysql)，然后再重启mysql。\r\n</p>\r\n<p>\r\n	接下来进行案例说明：假设我们已经有了一个全量备份2016-12-01_00-07-15删除在上面测试创建的两个增量备份[root@test-huanqiu ~]# cd /backup/mysql/data/[root@test-huanqiu data]# lltotal 12drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15drwxr-xr-x. 6 root root 4096 Dec  1 01:12 2016-12-01_01-12-22drwxr-xr-x. 6 root root 4096 Dec  1 01:23 2016-12-01_01-23-23[root@test-huanqiu data]# rm -rf 2016-12-01_01-12-22/[root@test-huanqiu data]# rm -rf 2016-12-01_01-23-23/[root@test-huanqiu data]# lltotal 4drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15\r\n</p>\r\n<p>\r\n	假设在全量备份后，mysql数据库中又有新数据写入[root@test-huanqiu ~]# mysql -p123456.........mysql&gt; create database ceshi;Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use ceshi;Database changedmysql&gt; create table test1(     -&gt; id int3,    -&gt; name varchar(20)    -&gt; );Query OK, 0 rows affected (0.07 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into test1 values(1,\"wangshibo\");Query OK, 1 row affected, 1 warning (0.03 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from test1;+------+-----------+| id   | name      |+------+-----------+|    1 | wangshibo |+------+-----------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || ceshi              || huanqiu            || mysql              || performance_schema || test               |+--------------------+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	然后进行一次增量备份：[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 --incremental-basedir=/backup/mysql/data/2016-12-01_00-07-15 --incremental /backup/mysql/data[root@test-huanqiu ~]# ll /backup/mysql/data/total 8drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15 &nbsp; &nbsp; &nbsp; &nbsp;//全量备份目录drwxr-xr-x. 7 root root 4096 Dec  1 03:41 2016-12-01_03-41-41 &nbsp; &nbsp; &nbsp; &nbsp;//增量备份目录\r\n</p>\r\n<p>\r\n	接着再在mysql数据库中写入新数据mysql&gt; insert into test1 values(2,\"guohuihui\");Query OK, 1 row affected, 1 warning (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into test1 values(3,\"wuxiang\");Query OK, 1 row affected, 1 warning (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into test1 values(4,\"liumengnan\");Query OK, 1 row affected, 1 warning (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from test1;+------+------------+| id   | name       |+------+------------+|    1 | wangshibo  ||    2 | guohuihui  ||    3 | wuxiang    ||    4 | liumengnan |+------+------------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	接着在增量的基础上再进行一次增量备份[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 --incremental-basedir=/backup/mysql/data/2016-12-01_03-41-41 --incremental /backup/mysql/data [root@test-huanqiu ~]# ll /backup/mysql/data/total 12drwxr-xr-x. 6 root root 4096 Dec  1 00:27 2016-12-01_00-07-15 &nbsp; &nbsp; &nbsp; //全量备份目录drwxr-xr-x. 7 root root 4096 Dec  1 02:24 2016-12-01_02-24-11 &nbsp; &nbsp; &nbsp; //增量备份目录1drwxr-xr-x. 7 root root 4096 Dec  1 03:42 2016-12-01_03-42-43 &nbsp; &nbsp; &nbsp; //增量备份目录2\r\n</p>\r\n<p>\r\n	现在删除数据库huanqiu、ceshimysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || ceshi              || huanqiu            || mysql              || performance_schema || test               |+--------------------+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database huanqiu;Query OK, 2 rows affected (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; drop database ceshi;Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || test               |+--------------------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	接下来就开始进行数据恢复操作：\r\n</p>\r\n<p>\r\n	先恢复应用日志（注意最后一个不需要加--redo-only参数）[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 &nbsp;--apply-log --redo-only /backup/mysql/data/2016-12-01_00-07-15[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 &nbsp;--apply-log --redo-only /backup/mysql/data/2016-12-01_00-07-15 --incremental-dir=/backup/mysql/data/2016-12-01_02-24-11[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 &nbsp;--apply-log &nbsp;/backup/mysql/data/2016-12-01_00-07-15 --incremental-dir=/backup/mysql/data/2016-12-01_03-42-43\r\n</p>\r\n<p>\r\n	到此，恢复数据工作还没有结束！还有最重要的一个环节，就是把增量目录下的数据整合到全量备份目录下，然后再进行一次全量还原。停止mysql数据库，并清空数据目录[root@test-huanqiu ~]# /etc/init.d/mysql stop[root@test-huanqiu ~]# rm -rf /data/mysql/data/*\r\n</p>\r\n<p>\r\n	最后拷贝文件，并验证数据目录的权限[root@test-huanqiu ~]# innobackupex --defaults-file=/usr/local/mysql/my.cnf --user=root --password=123456 --copy-back /backup/mysql/data/2016-12-01_00-07-15\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# chown -R mysql.mysql /data/mysql/data/*[root@test-huanqiu ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	最后，检查下数据是否恢复[root@test-huanqiu ~]# mysql -p123456........mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || ceshi || huanqiu || mysql || performance_schema || test |+--------------------+6 rows in set (0.00 sec)mysql&gt; select * from ceshi.test1;+------+------------+| id | name |+------+------------+| 1 | wangshibo || 2 | guohuihui || 3 | wuxiang || 4 | liumengnan |+------+------------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	另外注意：上面在做备份的时候，将备份目录和增量目录都放在了同一个目录路径下，其实推荐放在不同的路径下，方便管理！比如：/backup/mysql/data/full           存放全量备份目录/backup/mysql/data/daily1         存放第一次增量备份目录/backup/mysql/data/daily2         存放第二次增量目录以此类推\r\n</p>\r\n<p>\r\n	在恢复的时候，注意命令中的路径要跟对！\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------------------innobackupex 常用参数说明--defaults-file同xtrabackup的--defaults-file参数\r\n</p>\r\n<p>\r\n	--apply-log对xtrabackup的--prepare参数的封装\r\n</p>\r\n<p>\r\n	--copy-back做数据恢复时将备份数据文件拷贝到MySQL服务器的datadir ；\r\n</p>\r\n<p>\r\n	--remote-host=HOSTNAME通过ssh将备份数据存储到进程服务器上；\r\n</p>\r\n<p>\r\n	--stream=[tar]备 份文件输出格式, tar时使用tar4ibd , 该文件可在XtarBackup binary文件中获得.如果备份时有指定--stream=tar, 则tar4ibd文件所处目录一定要在$PATH中(因为使用的是tar4ibd去压缩, 在XtraBackup的binary包中可获得该文件)。在 使用参数stream=tar备份的时候，你的xtrabackup_logfile可能会临时放在/tmp目录下，如果你备份的时候并发写入较大的话 xtrabackup_logfile可能会很大(5G+)，很可能会撑满你的/tmp目录，可以通过参数--tmpdir指定目录来解决这个问题。\r\n</p>\r\n<p>\r\n	--tmpdir=DIRECTORY当有指定--remote-host or --stream时, 事务日志临时存储的目录, 默认采用MySQL配置文件中所指定的临时目录tmpdir\r\n</p>\r\n<p>\r\n	--redo-only --apply-log组,强制备份日志时只redo ,跳过rollback。这在做增量备份时非常必要。\r\n</p>\r\n<p>\r\n	--use-memory=#该参数在prepare的时候使用，控制prepare时innodb实例使用的内存量\r\n</p>\r\n<p>\r\n	--throttle=IOS同xtrabackup的--throttle参数\r\n</p>\r\n<p>\r\n	--sleep=是给ibbackup使用的，指定每备份1M数据，过程停止拷贝多少毫秒，也是为了在备份时尽量减小对正常业务的影响，具体可以查看ibbackup的手册 ；\r\n</p>\r\n<p>\r\n	--compress[=LEVEL]对备份数据迚行压缩，仅支持ibbackup，xtrabackup还没有实现；\r\n</p>\r\n<p>\r\n	--include=REGEXP对 xtrabackup参数--tables的封装，也支持ibbackup。备份包含的库表，例如：--include=\"test.*\"，意思是要备份 test库中所有的表。如果需要全备份，则省略这个参数；如果需要备份test库下的2个表：test1和test2,则写 成：--include=\"test.test1|test.test2\"。也可以使用通配符，如：--include=\"test.test*\"。\r\n</p>\r\n<p>\r\n	--databases=LIST列出需要备份的databases，如果没有指定该参数，所有包含MyISAM和InnoDB表的database都会被备份；\r\n</p>\r\n<p>\r\n	--uncompress解压备份的数据文件，支持ibbackup，xtrabackup还没有实现该功能；\r\n</p>\r\n<p>\r\n	--slave-info,备 份从库, 加上--slave-info备份目录下会多生成一个xtrabackup_slave_info 文件, 这里会保存主日志文件以及偏移, 文件内容类似于:CHANGE MASTER TO MASTER_LOG_FILE=\'\', MASTER_LOG_POS=0\r\n</p>\r\n<p>\r\n	--socket=SOCKET指定mysql.sock所在位置，以便备份进程登录mysql.\r\n</p>\r\n<p>\r\n	三、innobackupex全量、增量备份脚本\r\n</p>\r\n<p>\r\n	可以根据自己线上数据库情况，编写全量和增量备份脚本，然后结合crontab设置计划执行。比如：每周日的1:00进行全量备份，每周1-6的1:00进行增量备份。还可以在脚本里编写邮件通知信息（可以用mail或sendemail）\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('b7551b01-91a7-4f90-b162-a857abc951b1','mysql主从同步(5)-同步延迟状态考量（seconds_behind_master和pt-hea','mysql主从同步(5)-同步延迟状态考量（seconds_behind_master和pt-heartbea）','<p>\r\n	一般情况下，我们是通过\"show slave status \\G;\"提供的Seconds_Behind_Master值来衡量mysql主从同步的延迟情况。具体说明见：mysql主从同步(4)-Slave延迟状态监控，这种方法在大多数情况下确实是可行的。但是经验告诉我，仅仅依靠Seconds_Behind_Master的值来监测主从同步数据是否延迟是绝对不可靠的！！！\r\n</p>\r\n<p>\r\n	曾经遇到过的一个坑：Mysql主从环境部署后，刚开始主从数据同步是没问题的，也是通过监控Seconds_Behind_Master的值来判断同步是否延迟。但是运行一段时间后，突然有一天发现，主库上写入新数据后，从库并没有按时同步过来！！于是，立刻在从库上执行\"show slave status \\G;\"发现Seconds_Behind_Master为0 ，并且Slave_IO_Running和Slave_SQL_Running线程状态都是YES，也就是说从库到主库的连接还在，没有断开！但是主库上的变更数据就是长时间无法同步到从库上。如果没有人为干预，直到一个小时以后，从库才会自动重新连接主库，进而才继续同步主库的变更。发生这种情况时，通过一般的正常监控方式是不会发现从库有数据延迟。由此可见，仅仅通过Seconds_Behind_Master=0来判断同步是否延迟显然是不够滴.........\r\n</p>\r\n<p>\r\n	发现这个问题以后，我们人工干预的操作只是需要在从库上执行下面两步重新复制就能解决此问题：mysql&gt; stop slave; mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	重新执行复制后，要尽快修改slave_net_timeout这个参数\r\n</p>\r\n<p>\r\n	之所以要等1小时才能重新同步，是因为slave_net_timeout这个参数默认的就是3600s，它是设置在多少秒没收到主库传来的Binary Logs events之后,从库认为网络超时,Slave IO线程会重新连接主库。\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'slave_net_timeout\';\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name     | Value |\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	| slave_net_timeout | 3600  |\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	如果在部署mysql主从同步的时候，没有在从库这边设置好slave_net_timeout这个参数，遇到上面的情况，它就会按照默认的3600s（一小时）采取自动重新连接主库，然后才能继续同步主库的变更。这个参数不能设置太大，太大会造成数据库延迟或者主备库直接的链接异常不能及时发现；但是设置太小又会造成主库没有数据更新时频繁重连。至于slave_net_timeout这个参数究竟设置多少，要根据自己的mysql主库数据更新的频繁程度：主库数据更新频繁的，就将这个参数值设小点，更新不频繁就设大点。一般这个参数设置5s、10s、15s、20s、30s等等。\r\n</p>\r\n<p>\r\n	设置方法：直接登陆从库的mysql在线修改：\r\n</p>\r\n<p>\r\n	mysql&gt; set global slave_net_timeout = 5;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected, 1 warning (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show variables like \'slave_net_timeout\';\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	| Variable_name     | Value |\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	| slave_net_timeout | 5     |\r\n</p>\r\n<p>\r\n	+-------------------+-------+\r\n</p>\r\n<p>\r\n	1 row in set (0.01 sec)\r\n</p>\r\n<p>\r\n	或者在从库的myc.nf里添加：[root@slave-server ~]# cat /usr/local/mysql/my.cnf....[mysqld].....slave_net_timeout = 5[root@slave-server ~]# /etc/init.d/mysql restart\r\n</p>\r\n<p>\r\n	因此，将这个参数设置恰当后，遇到上面问题的时候，从库就会按照设定的时间去主动重新连接主库同步数据，就不需要人工干预。\r\n</p>\r\n<p>\r\n	当然，上述场景是非常特殊的，一般出现的概率比较小，但是作为运维人员，我们非常有必要搞清楚该怎么应对这种情况。这就需要我们要更加深入的吃透MySQL replication重试机制。\r\n</p>\r\n<p>\r\n	接下来基于mysql主从复制原理来分析这一现象MySQL的Replication是区别其他数据库很关键的地方，也是可扩展性和高可用的基础。它本身已经非常智能化，只需要我们调用Change Master指定Binlog 文件名和偏移位置就可以搭建从主库到备库的复制关系。MySQL复制线程会自动将目前复制位置记录下来，在主备复制中断的时候自动连上主库，并从上次中断的位置重新开始复制。这些操作都是全自动化的，不需要人为的干预。这给了我们运维人员带来了很多便利，同时也隐藏了很多细节。要真正的理解前面问题的真相以及怎么解决这个问题，我们还是需要真正的理解MySQL复制的原理。\r\n</p>\r\n<p>\r\n	1）Mysql主从复制的动作是“推”还是“拉”MySQL的复制是“推”的，而不是“拉”的。“拉”是指MySQL的备库不断的循环询问主库是否有数据更新，这种方式资源消耗多，并且效率低。“推”是指MySQL的主库在自己有数据更新的时候推送这个变更给备库，这种方式只有在数据有变更的时候才会发生交互，资源消耗少。显而易见，“推”的方式更加符合程序运行的节能原则。\r\n</p>\r\n<p>\r\n	那么MySQL具体是怎么“推”的列呢？实际上备库在向主库申请数据变更记录的时候，需要指定从主库Binlog的哪个文件(MASTER_LOG_FILE)的具体多少个字节偏移位置(MASTER_LOG_POS)。对应的,主库会启动一个Binlog dump的线程，将变更的记录从这个位置开始一条一条的发给备库。备库一直监听主库过来的变更，接收到一条，才会在本地应用这个数据变更。\r\n</p>\r\n<p>\r\n	2）原因解析从上面的分析，我们可以大致猜到为什么 show slave status 显示一切正常，但是实际上主库的变更都无法同步到备库上来：出现问题的时候，Binlog dump程序被kill掉了。而备库作为监听的一方，它一直没有收到任何变更，它会认为主库上长时间没有任何变更，导致没有变更数据推送过来。备库是无法判断主库上对应的Binlog dump线程到底是意外终止了，还是长时间没有任何数据变更的。所以，对这两种情况来说，备库都显示为正常。\r\n</p>\r\n<p>\r\n	所以该问题的关键在于：主库Binlog dump线程kill的消息由于网络堵塞或者其他原因无法发送到备库，而备库却认为主库上的数据给有变更，因为双方数据产生了差异。而备库只能在默认的3600s后主动地重新去连接主库，届时它才会发现主库的数据有变动了，才会自动同步过来，这是需要等待很长时间。\r\n</p>\r\n<p>\r\n	3）问题避免基于上面的分析，可以知道MySQL在这种情况下确实无法避免，那么有哪些办法可以避开：&nbsp; &nbsp;1--被动处理：修改延迟的监控方法，发现问题及时处理。&nbsp; &nbsp;2--主动预防：正确设置--master-retry-count ，--master-connect-retry ，--slave-net-timeout 复制重试参数。\r\n</p>\r\n<p>\r\n	1--被动处理&nbsp; &nbsp;MySQL的延迟监控大部分直接采集show slave status中的Seconds_Behind_Master 。&nbsp; &nbsp;那么像上面说的这种情况下， Seconds_Behind_Master就无法用来真实的衡量主备之间的复制延迟了。&nbsp; &nbsp;推荐使用Percona提供的监控方案（参考：mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理）\r\n</p>\r\n<p>\r\n	2--主动预防&nbsp; &nbsp;除了手动在从库上stop slave和start slave重新执行复制后，还需要指定三个参数，用于复制线程重连主库，分别是&nbsp; &nbsp;master-retry-count：连接重试的次数。&nbsp; &nbsp;master-connect-retry：连接失败后等待的秒数&nbsp; &nbsp;slave-net-timeout：上面已介绍&nbsp; &nbsp;其中 master-connect-retry 和 master-retry-count 需要在 Change Master 搭建主备复制时指定，而 slave-net-timeout 是一个全局变量，可以在 MySQL 运行时在线设置。&nbsp; &nbsp;不过要注意的是：master-connect-retry和master-retry-count参数在Mysql5.6版本里就被去除了，所以Mysql5.6版本及更高版本就只设置slave-net-timeout参数即可。\r\n</p>\r\n<p>\r\n	具体的重试策略为：&nbsp; 备库过了slave-net-timeout秒还没有收到主库来的数据，它就会开始第一次重试。然后每过 master-connect-retry 秒，备库会再次尝试重连主库。直到重试了 master-retry-count 次，它才会放弃重试。如果重 &nbsp; 试的过程中，连上了主库，那么它认为当前主库是好的，又会开始 slave-net-timeout 秒的等待。\r\n</p>\r\n<p>\r\n	slave-net-timeout 的默认值是3600 秒， master-connect-retry默认为60秒， master-retry-count默认为86400次。&nbsp; 也就是说，如果主库一个小时都没有任何数据变更发送过来，备库才会尝试重连主库。&nbsp; 这就是为什么我遇到场景下，一个小时后，备库才会重连主库，继续同步数据变更的原因。&nbsp; 这样的话，如果你的主库上变更比较频繁，可以考虑将slave-net-timeout设置的小一点，避免主库 Binlog dump 线程 终止了，无法将最新的更新推送过来。&nbsp; 当然 slave-net-timeout 设置的过小也有问题，这样会导致如果主库的变更确实比较少的时候，备库频繁的重新连接主库，造成资源浪费。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('bc31c768-9a4d-4ae6-94e6-c6c407c66373','Mysql之binlog日志说明及利用binlog日志恢复数据操作记录','Mysql之binlog日志说明及利用binlog日志恢复数据操作记录','<p>\r\n	众所周知，binlog日志对于mysql数据库来说是十分重要的。在数据丢失的紧急情况下，我们往往会想到用binlog日志功能进行数据恢复（定时全备份+binlog日志恢复增量数据部分），化险为夷！\r\n</p>\r\n<p>\r\n	废话不多说，下面是梳理的binlog日志操作解说：\r\n</p>\r\n<p>\r\n	一、初步了解binlogMySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。----------------------------------------------------------------------------------------------------------------------------------------------DDL----Data Definition Language 数据库定义语言 主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。\r\n</p>\r\n<p>\r\n	DML----Data Manipulation Language 数据操纵语言主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言----------------------------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	mysqlbinlog常见的选项有以下几个：--start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地计算机的时间--stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地计算机的时间  取值和上述一样--start-position：从二进制日志中读取指定position 事件位置作为开始。--stop-position：从二进制日志中读取指定position 事件位置作为事件截至\r\n</p>\r\n<p>\r\n	*********************************************************************\r\n</p>\r\n<p>\r\n	一般来说开启binlog日志大概会有1%的性能损耗。binlog日志有两个最重要的使用场景: 1）MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。 2）自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。binlog日志包括两类文件：1）二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件2）二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句select)语句事件。\r\n</p>\r\n<p>\r\n	二、开启binlog日志：1）编辑打开mysql配置文件/etc/mys.cnf[root@vm-002 ~]# vim /etc/my.cnf在[mysqld] 区块添加 log-bin=mysql-bin  确认是打开状态(mysql-bin 是日志的基本名或前缀名)；\r\n</p>\r\n<p>\r\n	2）重启mysqld服务使配置生效[root@vm-002 ~]# /etc/init.d/mysqld stop[root@vm-002 ~]# /etc/init.d/mysqld restartStopping mysqld:                                           [  OK  ]Starting mysqld:                                           [  OK  ]\r\n</p>\r\n<p>\r\n	3）查看binlog日志是否开启mysql&gt; show variables like \'log_%\'; +---------------------------------+---------------------+| Variable_name                   | Value               |+---------------------------------+---------------------+| log_bin                         | ON                  || log_bin_trust_function_creators | OFF                 || log_bin_trust_routine_creators  | OFF                 || log_error                       | /var/log/mysqld.log || log_output                      | FILE                || log_queries_not_using_indexes   | OFF                 || log_slave_updates               | OFF                 || log_slow_queries                | OFF                 || log_warnings                    | 1                   |+---------------------------------+---------------------+9 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	三、常用的binlog日志操作命令1）查看所有binlog日志列表mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       149 || mysql-bin.000002 |      4102 |+------------------+-----------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）查看master状态，即最后(最新)一个binlog日志的编号名称，及其最后一个操作事件pos结束点(Position)值mysql&gt; show master status;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000002 |     4102 |              |                  |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）flush刷新log日志，自此刻开始产生一个新编号的binlog日志文件mysql&gt; flush logs;  Query OK, 0 rows affected (0.13 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show master logs; +------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       149 || mysql-bin.000002 |      4145 || mysql-bin.000003 |       106 |+------------------+-----------+3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	注意：每当mysqld服务重启时，会自动执行此命令，刷新binlog日志；在mysqldump备份数据时加 -F 选项也会刷新binlog日志；\r\n</p>\r\n<p>\r\n	4）重置(清空)所有binlog日志mysql&gt; reset master;Query OK, 0 rows affected (0.12 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show master logs; +------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       106 |+------------------+-----------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	四、查看binlog日志内容，常用有两种方式：1）使用mysqlbinlog自带查看命令法：注意：--&gt;binlog是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的mysqlbinlog命令查看--&gt;binlog日志与数据库文件在同目录中--&gt;在MySQL5.5以下版本使用mysqlbinlog命令时如果报错，就加上 “--no-defaults”选项\r\n</p>\r\n<p>\r\n	查看mysql的数据存放目录，从下面结果可知是/var/lib//mysql[root@vm-002 ~]# ps -ef|grep mysqlroot      9791     1  0 21:18 pts/0    00:00:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --socket=/var/lib/mysql/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysqlmysql     9896  9791  0 21:18 pts/0    00:00:00 /usr/libexec/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=mysql --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sockroot      9916  9699  0 21:18 pts/0    00:00:00 mysql -px xxxxroot      9919  9715  0 21:23 pts/1    00:00:00 grep --color mysql\r\n</p>\r\n<p>\r\n	[root@vm-002 ~]# cd /var/lib/mysql/[root@vm-002 mysql]# lsibdata1  ib_logfile0  ib_logfile1  mysql  mysql-bin.000001  mysql-bin.000002  mysql-bin.index  mysql.sock  ops  test\r\n</p>\r\n<p>\r\n	使用mysqlbinlog命令查看binlog日志内容，下面截取其中的一个片段分析：[root@vm-002 mysql]# mysqlbinlog mysql-bin.000002..............# at 624#160925 21:29:53 server id 1  end_log_pos 796 	Query	thread_id=3	exec_time=0	error_code=0SET TIMESTAMP=1474810193/*!*/;insert into member(`name`,`sex`,`age`,`classid`) values(\'wangshibo\',\'m\',27,\'cls1\'),(\'guohuihui\',\'w\',27,\'cls2\') &nbsp; &nbsp; &nbsp; &nbsp;#执行的sql语句/*!*/;# at 796#160925 21:29:53 server id 1  end_log_pos 823 	Xid = 17 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#执行的时间.............\r\n</p>\r\n<p>\r\n	解释：server id 1 ：    数据库主机的服务号；end_log_pos 796： sql结束时的pos节点thread_id=11：    线程号\r\n</p>\r\n<p>\r\n	2）上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息下面介绍一种更为方便的查询命令：命令格式：mysql&gt; show binlog events [IN \'log_name\'] [FROM pos] [LIMIT [offset,] row_count];参数解释：IN \'log_name\'   ：指定要查询的binlog文件名(不指定就是第一个binlog文件)FROM pos        ：指定从哪个pos起始点开始查起(不指定就是从整个文件首个pos点开始算)LIMIT [offset,] ：偏移量(不指定就是0)row_count       ：查询总条数(不指定就是所有行)\r\n</p>\r\n<p>\r\n	mysql&gt; show master logs;+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |       125 || mysql-bin.000002 |       823 |+------------------+-----------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show binlog events in \'mysql-bin.000002\'\\G;*************************** 1. row ***************************   Log_name: mysql-bin.000002        Pos: 4 Event_type: Format_desc  Server_id: 1End_log_pos: 106       Info: Server ver: 5.1.73-log, Binlog ver: 4*************************** 2. row ***************************   Log_name: mysql-bin.000002        Pos: 106 Event_type: Query  Server_id: 1End_log_pos: 188       Info: use `ops`; drop table customers*************************** 3. row ***************************   Log_name: mysql-bin.000002        Pos: 188 Event_type: Query  Server_id: 1End_log_pos: 529       Info: use `ops`; CREATE TABLE IF NOT EXISTS `member` (`id` int(10) unsigned NOT NULL AUTO_INCREMENT,`name` varchar(16) NOT NULL,`sex` enum(\'m\',\'w\') NOT NULL DEFAULT \'m\',`age` tinyint(3) unsigned NOT NULL,`classid` char(6) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8*************************** 4. row ***************************   Log_name: mysql-bin.000002        Pos: 529 Event_type: Query  Server_id: 1End_log_pos: 596       Info: BEGIN*************************** 5. row ***************************   Log_name: mysql-bin.000002        Pos: 596 Event_type: Intvar  Server_id: 1End_log_pos: 624       Info: INSERT_ID=1*************************** 6. row ***************************   Log_name: mysql-bin.000002        Pos: 624 Event_type: Query  Server_id: 1End_log_pos: 796       Info: use `ops`; insert into member(`name`,`sex`,`age`,`classid`) values(\'wangshibo\',\'m\',27,\'cls1\'),(\'guohuihui\',\'w\',27,\'cls2\')*************************** 7. row ***************************   Log_name: mysql-bin.000002        Pos: 796 Event_type: Xid  Server_id: 1End_log_pos: 823       Info: COMMIT /* xid=17 */7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	ERROR: No query specified\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	上面这条语句可以将指定的binlog日志文件，分成有效事件行的方式返回，并可使用limit指定pos点的起始偏移，查询条数！如下操作示例：a）查询第一个(最早)的binlog日志：mysql&gt; show binlog events\\G;\r\n</p>\r\n<p>\r\n	b）指定查询 mysql-bin.000002这个文件：mysql&gt; show binlog events in \'mysql-bin.000002\'\\G;\r\n</p>\r\n<p>\r\n	c）指定查询 mysql-bin.000002这个文件，从pos点:624开始查起：mysql&gt; show binlog events in \'mysql-bin.000002\' from 624\\G;\r\n</p>\r\n<p>\r\n	d）指定查询 mysql-bin.000002这个文件，从pos点:624开始查起，查询10条（即10条语句）mysql&gt; show binlog events in \'mysql-bin.000002\' from 624 limit 10\\G;\r\n</p>\r\n<p>\r\n	e）指定查询 mysql-bin.000002这个文件，从pos点:624开始查起，偏移2行（即中间跳过2个），查询10条mysql&gt; show binlog events in \'mysql-bin.000002\' from 624 limit 2,10\\G;\r\n</p>\r\n<p>\r\n	五、利用binlog日志恢复mysql数据\r\n</p>\r\n<p>\r\n	以下对ops库的member表进行操作mysql&gt; use ops；mysql&gt; CREATE TABLE IF NOT EXISTS `member` (    -&gt; `id` int(10) unsigned NOT NULL AUTO_INCREMENT,    -&gt; `name` varchar(16) NOT NULL,    -&gt; `sex` enum(\'m\',\'w\') NOT NULL DEFAULT \'m\',    -&gt; `age` tinyint(3) unsigned NOT NULL,    -&gt; `classid` char(6) DEFAULT NULL,    -&gt; PRIMARY KEY (`id`)    -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.10 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;+---------------+| Tables_in_ops |+---------------+| member        |+---------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; desc member;+---------+---------------------+------+-----+---------+----------------+| Field   | Type                | Null | Key | Default | Extra          |+---------+---------------------+------+-----+---------+----------------+| id      | int(10) unsigned    | NO   | PRI | NULL    | auto_increment || name    | varchar(16)         | NO   |     | NULL    |                || sex     | enum(\'m\',\'w\')       | NO   |     | m       |                || age     | tinyint(3) unsigned | NO   |     | NULL    |                || classid | char(6)             | YES  |     | NULL    |                |+---------+---------------------+------+-----+---------+----------------+5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	事先插入两条数据mysql&gt; insert into member(`name`,`sex`,`age`,`classid`) values(\'wangshibo\',\'m\',27,\'cls1\'),(\'guohuihui\',\'w\',27,\'cls2\');Query OK, 2 rows affected (0.08 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    |+----+-----------+-----+-----+---------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	下面开始进行场景模拟：1）ops库会在每天凌晨4点进行一次完全备份的定时计划任务，如下：[root@vm-002 ~]# crontab -l0 4 * * * /usr/bin/mysqldump -uroot -p -B -F -R -x --master-data=2 ops|gzip &gt;/opt/backup/ops_$(date +%F).sql.gz\r\n</p>\r\n<p>\r\n	这里手动执行下，将ops数据库备份到/opt/backup/ops_$(date +%F).sql.gz文件中：[root@vm-002 ~]# mysqldump -uroot -p -B -F -R -x --master-data=2 ops|gzip &gt;/opt/backup/ops_$(date +%F).sql.gzEnter password: [root@vm-002 ~]# ls /opt/backup/ops_2016-09-25.sql.gz-----------------参数说明：-B：指定数据库-F：刷新日志-R：备份存储过程等-x：锁表--master-data：在备份语句里添加CHANGE MASTER语句以及binlog文件及位置点信息-----------------待到数据库备份完成，就不用担心数据丢失了，因为有完全备份数据在！！\r\n</p>\r\n<p>\r\n	由于上面在全备份的时候使用了-F选项，那么当数据备份操作刚开始的时候系统就会自动刷新log，这样就会自动产生一个新的binlog日志，这个新的binlog日志就会用来记录备份之后的数据库“增删改”操作查看一下：mysql&gt; show master status;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 |      106 |              |                  |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	也就是说， mysql-bin.000003 是用来记录4:00之后对数据库的所有“增删改”操作。\r\n</p>\r\n<p>\r\n	2）早上9点上班了，由于业务的需求会对数据库进行各种“增删改”操作。比如：在ops库下member表内插入、修改了数据等等：\r\n</p>\r\n<p>\r\n	先是早上进行插入数据：mysql&gt; insert into ops.member(`name`,`sex`,`age`,`classid`) values(\'yiyi\',\'w\',20,\'cls1\'),(\'xiaoer\',\'m\',22,\'cls3\'),(\'zhangsan\',\'w\',21,\'cls5\'),(\'lisi\',\'m\',20,\'cls4\'),(\'wangwu\',\'w\',26,\'cls6\');Query OK, 5 rows affected (0.08 sec)Records: 5  Duplicates: 0  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | xiaoer    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3）中午又执行了修改数据操作：mysql&gt; update ops.member set name=\'李四\' where id=4;Query OK, 1 row affected (0.07 sec)Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; update ops.member set name=\'小二\' where id=2;Query OK, 1 row affected (0.06 sec)Rows matched: 1  Changed: 1  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | 小二    | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | 李四    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	4）在下午18:00的时候，悲剧莫名其妙的出现了！手贱执行了drop语句，直接删除了ops库！吓尿！mysql&gt; drop database ops;Query OK, 1 row affected (0.02 sec)\r\n</p>\r\n<p>\r\n	5）这种时候，一定不要慌张！！！先仔细查看最后一个binlog日志，并记录下关键的pos点，到底是哪个pos点的操作导致了数据库的破坏(通常在最后几步)；\r\n</p>\r\n<p>\r\n	先备份一下最后一个binlog日志文件：[root@vm-002 ~]# cd /var/lib/mysql/[root@vm-002 mysql]# cp -v mysql-bin.000003 /opt/backup/`mysql-bin.000003\' -&gt; `/opt/backup/mysql-bin.000003\'[root@vm-002 mysql]# ls /opt/backup/mysql-bin.000003  ops_2016-09-25.sql.gz\r\n</p>\r\n<p>\r\n	接着执行一次刷新日志索引操作，重新开始新的binlog日志记录文件。按理说mysql-bin.000003这个文件不会再有后续写入了，因为便于我们分析原因及查找ops节点，以后所有数据库操作都会写入到下一个日志文件。mysql&gt; flush logs;Query OK, 0 rows affected (0.13 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000004 |      106 |              |                  |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	6）读取binlog日志，分析问题。读取binlog日志的方法上面已经说到。方法一：使用mysqlbinlog读取binlog日志：[root@vm-002 ~]# cd /var/lib/mysql/[root@vm-002 mysql]# mysqlbinlog mysql-bin.000003\r\n</p>\r\n<p>\r\n	方法二：登录服务器，并查看(推荐此种方法)mysql&gt; show binlog events in \'mysql-bin.000003\';\r\n</p>\r\n<p>\r\n	+------------------+-----+-------------+-----------+-------------+----------------------------------------------------------------------------------------------------------------------------+| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                                                                       |+------------------+-----+-------------+-----------+-------------+----------------------------------------------------------------------------------------------------------------------------+| mysql-bin.000003 |   4 | Format_desc |         1 |         106 | Server ver: 5.1.73-log, Binlog ver: 4                                                                                      || mysql-bin.000003 | 106 | Query       |         1 |         173 | BEGIN                                                                                                                      || mysql-bin.000003 | 173 | Intvar      |         1 |         201 | INSERT_ID=3                                                                                                                || mysql-bin.000003 | 201 | Query       |         1 |         444 | use `ops`; insert into ops.member(`name`,`sex`,`age`,`gsan\',\'w\',21,\'cls5\'),(\'lisi\',\'m\',20,\'cls4\'),(\'wangwu\',\'w\',26,\'cls6\') || mysql-bin.000003 | 444 | Xid         |         1 |         471 | COMMIT /* xid=66 */                                                                                                        || mysql-bin.000003 | 471 | Query       |         1 |         538 | BEGIN                                                                                                                      || mysql-bin.000003 | 538 | Query       |         1 |         646 | use `ops`; update ops.member set name=\'李四\' where id=                                                                   || mysql-bin.000003 | 646 | Xid         |         1 |         673 | COMMIT /* xid=68 */                                                                                                        || mysql-bin.000003 | 673 | Query       |         1 |         740 | BEGIN                                                                                                                      || mysql-bin.000003 | 740 | Query       |         1 |         848 | use `ops`; update ops.member set name=\'小二\' where id=                                                                   || mysql-bin.000003 | 848 | Xid         |         1 |         875 | COMMIT /* xid=69 */                                                                                                        || mysql-bin.000003 | 875 | Query       |         1 |         954 | drop database ops                                                                                                          || mysql-bin.000003 | 954 | Rotate      |         1 |         997 | mysql-bin.000004;pos=4                                                                                                     |+------------------+-----+-------------+-----------+-------------+----------------------------------------------------------------------------------------------------------------------------+13 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	或者：\r\n</p>\r\n<p>\r\n	mysql&gt; show binlog events in \'mysql-bin.000003\'\\G;..................*************************** 12. row ***************************   Log_name: mysql-bin.000003        Pos: 875 Event_type: Query  Server_id: 1End_log_pos: 954       Info: drop database ops*************************** 13. row ***************************   Log_name: mysql-bin.000003        Pos: 954 Event_type: Rotate  Server_id: 1End_log_pos: 997       Info: mysql-bin.000004;pos=413 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	通过分析，造成数据库破坏的pos点区间是介于 875--954 之间（这是按照日志区间的pos节点算的），只要恢复到875前就可。\r\n</p>\r\n<p>\r\n	7）先把凌晨4点全备份的数据恢复：[root@vm-002 ~]# cd /opt/backup/[root@vm-002 backup]# lsmysql-bin.000003  ops_2016-09-25.sql.gz[root@vm-002 backup]# gzip -d ops_2016-09-25.sql.gz [root@vm-002 backup]# mysql -uroot -p -v &lt; ops_2016-09-25.sql Enter password: --------------/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */--------------\r\n</p>\r\n<p>\r\n	--------------/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */--------------\r\n</p>\r\n<p>\r\n	..........................\r\n</p>\r\n<p>\r\n	--------------/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */--------------\r\n</p>\r\n<p>\r\n	这样就恢复了截至当日凌晨(4:00)前的备份数据都恢复了。\r\n</p>\r\n<p>\r\n	mysql&gt; show databases; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#发现ops库已经恢复回来了mysql&gt; use ops;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changedmysql&gt; show tables;+---------------+| Tables_in_ops |+---------------+| member        |+---------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    |+----+-----------+-----+-----+---------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	但是这仅仅只是恢复了当天凌晨4点之前的数据，在4:00--18:00之间的数据还没有恢复回来！！怎么办呢？莫慌！这可以根据前面提到的mysql-bin.000003的新binlog日志进行恢复。\r\n</p>\r\n<p>\r\n	8）从binlog日志恢复数据恢复命令的语法格式：mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名\r\n</p>\r\n<p>\r\n	--------------------------------------------------------常用参数选项解释：--start-position=875                      起始pos点--stop-position=954                      结束pos点--start-datetime=\"2016-9-25 22:01:08\"    起始时间点--stop-datetime=\"2019-9-25 22:09:46\"     结束时间点--database=zyyshop                        指定只恢复zyyshop数据库(一台主机上往往有多个数据库，只限本地log日志)--------------------------------------------------------        不常用选项：    -u --user=name              连接到远程主机的用户名-p --password[=name]        连接到远程主机的密码-h --host=name              从远程主机上获取binlog日志--read-from-remote-server   从某个MySQL服务器上读取binlog日志--------------------------------------------------------小结：实际是将读出的binlog日志内容，通过管道符传递给mysql命令。这些命令、文件尽量写成绝对路径；\r\n</p>\r\n<p>\r\n	a）完全恢复(需要手动vim编辑mysql-bin.000003，将那条drop语句剔除掉)[root@vm-002 backup]# /usr/bin/mysqlbinlog /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	b）指定pos结束点恢复(部分恢复)：--stop-position=471      pos结束节点（按照事务区间算，是471）注意：此pos结束节点介于“member表原始数据”与更新“name=\'李四\'”之前的数据，这样就可以恢复到更改“name=\'李四\'”之前的数据了。操作如下：[root@vm-002 ~]# /usr/bin/mysqlbinlog --stop-position=471 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | xiaoer    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	恢复截止到更改“name=\'李四\'”之间的数据（按照事务区间算，是673）[root@vm-002 ~]# /usr/bin/mysqlbinlog --stop-position=673 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name | sex | age | classid |+----+-----------+-----+-----+---------+| 1 | wangshibo | m | 27 | cls1 || 2 | guohuihui | w | 27 | cls2 || 3 | yiyi | w | 20 | cls1 || 4 | 李四 | m | 22 | cls3 || 5 | zhangsan | w | 21 | cls5 || 6 | lisi | m | 20 | cls4 || 7 | wangwu | w | 26 | cls6 |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	c）指定pso点区间恢复(部分恢复)：更新 name=\'李四\' 这条数据，日志区间是Pos[538] --&gt; End_log_pos[646]，按事务区间是：Pos[471] --&gt; End_log_pos[673]\r\n</p>\r\n<p>\r\n	更新 name=\'小二\' 这条数据，日志区间是Pos[740] --&gt; End_log_pos[848]，按事务区间是：Pos[673] --&gt; End_log_pos[875]\r\n</p>\r\n<p>\r\n	c1）单独恢复 name=\'李四\' 这步操作，可这样：按照binlog日志区间单独恢复：[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-position=538 --stop-position=646 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	按照事务区间单独恢复[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-position=471 --stop-position=673 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	c2）单独恢复 name=\'小二\' 这步操作，可这样：按照binlog日志区间单独恢复：[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-position=740 --stop-position=848 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	按照事务区间单独恢复[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-position=673 --stop-position=875 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	c3）将 name=\'李四\'、name=\'小二\' 多步操作一起恢复，需要按事务区间，可这样：[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-position=471 --stop-position=875 --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql  -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	查看数据库：mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name | sex | age | classid |+----+-----------+-----+-----+---------+| 1 | wangshibo | m | 27 | cls1 || 2 | 小二 | w | 27 | cls2 || 3 | yiyi | w | 20 | cls1 || 4 | 李四 | m | 22 | cls3 || 5 | zhangsan | w | 21 | cls5 || 6 | lisi | m | 20 | cls4 || 7 | wangwu | w | 26 | cls6 |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	这样，就恢复了删除前的数据状态了！！\r\n</p>\r\n<p>\r\n	-----------------另外：也可指定时间节点区间恢复(部分恢复)：除了用pos节点的办法进行恢复，也可以通过指定时间节点区间进行恢复，按时间恢复需要用mysqlbinlog命令读取binlog日志内容，找时间节点。\r\n</p>\r\n<p>\r\n	如上，误删除ops库后：先进行全备份恢复[root@vm-002 backup]# mysql -uroot -p -v &lt; ops_2016-09-25.sql\r\n</p>\r\n<p>\r\n	查看ops数据库mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name | sex | age | classid |+----+-----------+-----+-----+---------+| 1 | wangshibo | m | 27 | cls1 || 2 | guohuihui | w | 27 | cls2 |+----+-----------+-----+-----+---------+2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt;\r\n</p>\r\n<p>\r\n	查看mysq-bin00003日志，找出时间节点[root@vm-002 ~]# cd /var/lib/mysql[root@vm-002 mysql]# mysqlbinlog mysql-bin.000003 ..........................BEGIN/*!*/;# at 173#160925 21:57:19 server id 1  end_log_pos 201   IntvarSET INSERT_ID=3/*!*/;# at 201#160925 21:57:19 server id 1  end_log_pos 444   Query thread_id=3 exec_time=0 error_code=0use `ops`/*!*/;SET TIMESTAMP=1474811839/*!*/;insert into ops.member(`name`,`sex`,`age`,`classid`) values(\'yiyi\',\'w\',20,\'cls1\'),(\'xiaoer\',\'m\',22,\'cls3\'),(\'zhangsan\',\'w\',21,\'cls5\'),(\'lisi\',\'m\',20,\'cls4\'),(\'wangwu\',\'w\',26,\'cls6\') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #执行的sql语句/*!*/;# at 444#160925 21:57:19 server id 1  end_log_pos 471   Xid = 66 &nbsp; &nbsp;#开始执行的时间COMMIT/*!*/;# at 471#160925 21:58:41 server id 1  end_log_pos 538   Query thread_id=3 exec_time=0 error_code=0 &nbsp; &nbsp;#结束时间SET TIMESTAMP=1474811921/*!*/;BEGIN/*!*/;# at 538#160925 21:58:41 server id 1  end_log_pos 646   Query thread_id=3 exec_time=0 error_code=0SET TIMESTAMP=1474811921/*!*/;update ops.member set name=\'李四\' where id=4 &nbsp; &nbsp;&nbsp;#执行的sql语句/*!*/;# at 646#160925 21:58:41 server id 1  end_log_pos 673   Xid = 68 &nbsp; &nbsp;#开始执行的时间COMMIT/*!*/;# at 673#160925 21:58:56 server id 1  end_log_pos 740   Query thread_id=3 exec_time=0 error_code=0 &nbsp;&nbsp;#结束时间SET TIMESTAMP=1474811936/*!*/;BEGIN/*!*/;# at 740#160925 21:58:56 server id 1  end_log_pos 848   Query thread_id=3 exec_time=0 error_code=0SET TIMESTAMP=1474811936/*!*/;update ops.member set name=\'小二\' where id=2 &nbsp; &nbsp;&nbsp;&nbsp;#执行的sql语句/*!*/;# at 848#160925 21:58:56 server id 1  end_log_pos 875   Xid = 69 &nbsp;&nbsp;#开始执行的时间COMMIT/*!*/;# at 875#160925 22:01:08 server id 1  end_log_pos 954   Query thread_id=3 exec_time=0 error_code=0 &nbsp; &nbsp;#结束时间SET TIMESTAMP=1474812068/*!*/;drop database ops/*!*/;# at 954#160925 22:09:46 server id 1  end_log_pos 997   Rotate to mysql-bin.000004  pos: 4DELIMITER ;# End of log fileROLLBACK /* added by mysqlbinlog */;/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\r\n</p>\r\n<p>\r\n	恢复到更改“name=\'李四\'”之前的数据[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-datetime=\"2016-09-25 21:57:19\" --stop-datetime=\"2016-09-25 21:58:41\" --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql -uroot -p123456 -v ops\r\n</p>\r\n<p>\r\n	mysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | xiaoer    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-datetime=\"2016-09-25 21:58:41\" --stop-datetime=\"2016-09-25 21:58:56\" --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql -uroot -p123456 -v opsmysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | guohuihui | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | 李四    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	[root@vm-002 ~]# /usr/bin/mysqlbinlog --start-datetime=\"2016-09-25 21:58:56\" --stop-datetime=\"2016-09-25 22:01:08\" --database=ops /var/lib/mysql/mysql-bin.000003 | /usr/bin/mysql -uroot -p123456 -v opsmysql&gt; select * from member;+----+-----------+-----+-----+---------+| id | name      | sex | age | classid |+----+-----------+-----+-----+---------+|  1 | wangshibo | m   |  27 | cls1    ||  2 | 小二    | w   |  27 | cls2    ||  3 | yiyi      | w   |  20 | cls1    ||  4 | 李四    | m   |  22 | cls3    ||  5 | zhangsan  | w   |  21 | cls5    ||  6 | lisi      | m   |  20 | cls4    ||  7 | wangwu    | w   |  26 | cls6    |+----+-----------+-----+-----+---------+7 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	这样，就恢复了删除前的状态了！\r\n</p>\r\n<p>\r\n	总结：所谓恢复，就是让mysql将保存在binlog日志中指定段落区间的sql语句逐个重新执行一次而已。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('bc941170-81ff-4df4-af2a-0c7bfae57540','web cache server方案比较：varnish、squid、nginx','web cache server方案比较：varnish、squid、nginx','<p>\r\n	linux运维中，web cache server方案的部署是一个很重要的环节，选择也有很多种比如：varnish、squid、nginx。下面就对当下常用的这几个web cache server做一对比：\r\n</p>\r\n<p>\r\n	1）从功能上说：varnish和squid是专业的cache服务，而nginx的cache功能是由第三方模块完成。2）要做cache服务的话，肯定是要选择专业的cache服务，优先选择squid和varnish。Varnish 可以认为是内存缓存，速度一流，但是内存缓存也限制了其容量，缓存页面和图片一般是挺好的；varnish本身的技术上优势要高于squid，它采用了“Visual Page Cache”技术，在内存的利用上，Varnish比Squid具有优势，它避免了Squid频繁在内存、磁盘中交换文件，性能要比Squid高。varnish是不能cache到本地硬盘上的。Varnish可以使用正则表达式快速、批量地清除部分缓存varnish的内存管理完全交给内核，当缓存内容超过内存阈值时，内核会自动将一部分缓存存入swap中让出内存。以挪威一家报社的经验，1台varnish可以抵6台squid的性能。varnish用来做网站和小文件的缓存，相当给力的,做图片cache之类的合适varnish没有专门的存储引擎3）squid是功能最全面的比较传统的web cache server，有自己的存储引擎。，但是架构太老，性能不怎样。squid可以用于缓存更多更大的内容，属于专业用语缓存的功能，比如尤其适合缓存图片、文档等；squid可以说是越俎代庖自己实现了一套内存页/磁盘页的管理系统，但这个虚拟内存swap其实linux内核已经可以做得很好，squid的多此一举反而影响了性能squid支持正向代理缓存，而这方面varnish、nginx cache做不到4）nginx本来是反向代理/web服务器，用了插件可以做做这个副业，但是本身不支持的性能比较多。nginx是用第三方模块ncache做的缓冲，其性能基本达到varnish，但在架构中nginx一般作为反向（静态文件现在用nginx的很多，并发能支持到2万+）。在静态架构中，如果前端直接面对的是CDN活着前端了4层负载的话，完全用nginx的cache就够了。nginx Cache是为了提供访问最频繁资源的缓存而已，适合缓存纯文本体积较小的内容，缓存少量页面资源，主业是提供Web服务与代理的作用，若是Cache内容过多容易造成性能瓶颈与负载过大.nginx也没有专门的存储引擎，nginx可以认为是已个七层LB，再加上可以嵌入各种脚本语言，实现WAF规则和七层的定制开发策略非常容器，但要是作为专门的web cache server还要差不少。\r\n</p>\r\n<p>\r\n	如何构建一个高性能的缓存服务器，需要考虑的几个关键的技术因素：1）计算：需要考虑异步高并发，多核优化，cpu cache友好，需要构造一些精巧的技术结构，比如阿里swift就用到了后缀树；2）网络：zero copy发包（理论上说DPDK也可以用，sendfile；tcp内核协议栈策略定制；套接字的多路复用、port reuse等；3）存储：linux磁盘文件系统是通用的存储系统，天生对于海量小文件的IO不够友好；因此对于基于磁盘的缓存服务器来说，必须自己实现一个高性能的存储引擎，需要针对小数块的随机IO优化（主要随机读),另外分级存储，cache置换等也需要考虑。缓存服务器的存储引擎的技术复杂度不太高，没有关键字排序、ACID等要求，不说RDBMS的存储引擎，比基于LSMtree（例如leveldb）的KV存储引擎也要简单些。4）软件上，则考虑 DNS、tcp、http等协议特性，比如DNS缓存，回源切换，http内容压缩，失效时间等等。\r\n</p>\r\n<p>\r\n	针对CDN方案的实现：如何选择squid、Varnish、Nginx+memcache？？CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。1.使用CDN有3个好处1）优化跨ISP网络访问速度，在国内大联通和大电信之间是世界上最远的距离，在国外，中国和其他地区很平行，用cdn可以优化全球响应速度2）节约流量成本，CDN机房都一般都放在带宽便宜的小城市，带宽成本大概是BGP机房的1/33）快速提升性能，对于结构复杂的系统，部署CDN可以在不改动代码段情况提升网站整体性能，立竿见影2.市面上有很多CDN供应商，比较著名有：Akamai (全球最大)weblukercloudflarechinacache（蓝汛）网宿CDN帝联CDN阿里CDN（web cache server 叫swift）腾讯CDN七牛云融合CDN3.如果需要自己搭建CDN系统，有3种主流方案可以选择：squid、varnish、Nginx+memcache.1)对于大规模网站的CDN，存储共享是个强需求。为了消除单点，不可能只使用一台CDN服务器，如果只是简单做负载均衡，单台CDN server上需要存储全部数据，存储利用率太低了。squid支持几个实例并联，实际使用的人不多;varnish 只能用单实例;nginx+memcache 天然的分布式存储;当然，采用squid/varnish 也有解决办法: 需要在它们前面部署一个支持url hash的负载均衡设备(硬件，软件均可，比如说haproxy)2)内存存储的代价如果CDN把缓存放在内存当中，固然性能会有提升，但是当服务遭遇故障重启之后，全部数据都会丢失需要重建，这个时候会给后端应用服务器带来很大的短时压力服务需要较长的时间才能完全恢复.而实际运行当中，由于各种原因，CDN服务重启的概率相当高.3)一个很悲剧的事实对动态网页使用CDN，无论squid还是varnish都不能直接用，都需定制代码。例如varnish会判断response的header，如果发现里面有set-cookie项，它就认为这个页面不应该被缓存。对于规模庞大/OOP封装严密的网站，普通程序员根本意识不到调用哪一个fucntion会输出set-cookie，这个会导致CDN命中率急剧降低。但你也无力去对每行代码做code review，没有办法，只能去修改varnish代码了，这又引入一个新的维护成本. Squid也有这个问题4)purge效率purge就是CDN删除缓存项的接口，国内的UGC网站，因为严厉的内容检查制度和泛滥的垃圾广告，删帖子删图片特别频繁，某些网站可能高达40%（发100个贴，有40个帖子可能被删除或者修改)，所以对purge的效率有要求。squid和varnish的purge效率都达不到国内这种强度要求，nginx+memcache purge性能要好很多。在当前的中国,遇到突发事件后，要是不及时删除指定的链接或内容，后果可能会很严重（小到个人被炒，大到公司被关都有可能）某门户网站曾经发生过，某个链接怎么也删不掉，一慌张把CDN所有缓存都删了重启，导致内网流量瞬间暴涨，各业务线的服务器全线报警，集体骂娘！5）推荐CDN方案中小型网站直接买CDN服务就好，现在CDN已经进行按需付费的云计算模式了，性价比是可以准确计算的；外地部署单点，推荐用squid；准备在公司内部实施私有云战略，推荐nginx+memcache；不太建议使用varnish。\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('c429a60f-025d-4030-823f-e9c5f97d7428','Mysql优化系列（0）--总结性梳理','Mysql优化系列（0）--总结性梳理','<p>\r\n	对于一个网站来说，在运行很长一段时间后，数据库瓶颈问题会越来越暴露出来。作为运维人员，对数据库做必要的优化十分重要！下面总结以往查阅到的以及自己工作中的一些优化操作经验，并根据OSI七层模型从下往上进行优化mysql数据库记录。\r\n</p>\r\n<p>\r\n	一：物理层面1、cpu:2-16个  2*4双四核，L1L2越大越好2、内存:越大越好3、磁盘:SAS或者固态   300G*12磁盘越多IO越高raid 0&gt;10&gt;5&gt;14、网卡:千兆5、slave的配置最好大于等于master\r\n</p>\r\n<p>\r\n	二、系统配置如下，配置系统内核参数/etc/sysctl.conf（配置后，使用sysctl -p使之生效）net.ipv4.tcp_fin_timeout = 2net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_keepalive_time =600net.ipv4.ip_local_port_range = 4000    65000net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.route.gc_timeout = 100net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.core.somaxconn = 16384net.core.netdev_max_backlog = 16384net.ipv4.tcp_max_orphans = 16384\r\n</p>\r\n<p>\r\n	vm.swappiness=0 &nbsp; &nbsp; &nbsp;//尽量不使用swapvm.dirty_backgroud_ratio  5-10  vm.dirty_ratio &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//上面的值的两倍   将操作系统的脏数据刷到磁盘\r\n</p>\r\n<p>\r\n	三：mysql的安装MySQL数据库的线上环境安装，建议采取编译安装的方式，这样性能会有较大的提升。服务器系统则建议CentOS6.7 X86_64，源码包的编译参数会默认以Debug模式生成二进制代码，而Debug模式给MySQL带来的性能损失是比较大的，所以当我们编译准备安装的产品代码时，一定不要忘记使用--without-debug参数禁止Debug模式。如果把--with-mysqld-ldflags和--with-client-ld-flags两个编译参数设置为--all-static的话，可以告诉编译器以静态的方式编译，编译结果将得到最高的性能。使用静态编译和使用动态编译的代码相比，性能差距可能会达到5%至10%之多。在后面我会跟大家分享我们线上MySQL数据库的编译参数，大家可以参考下，然后根据自己的线上环境自行修改内容。\r\n</p>\r\n<p>\r\n	下面是对mysql服务配置文件my.cnf的详解：[client]port   = 3306# 客户端端口号为3306socket  = /data/3306/mysql.sockdefault-character-set = utf8# 客户端字符集,(控制character_set_client、character_set_connection、character_set_results)[mysql]no-auto-rehash  # 仅仅允许使用键值的updates和deletes[mysqld]  # 组包括了mysqld服务启动的参数，它涉及的方面很多，其中有MySQL的目录和文件，通信、网络、信息安全，内存管理、优化、查询缓存区，还有MySQL日志设置等。user    = mysql# mysql_safe脚本使用MySQL运行用户(编译时--user=mysql指定),推荐使用mysql用户。port    = 3306# MySQL服务运行时的端口号。建议更改默认端口,默认容易遭受攻击。socket  = /data/3306/mysql.sock  # socket文件是在Linux/Unix环境下特有的，用户在Linux/Unix环境下客户端连接可以不通过TCP/IP网络而直接使用unix socket连接MySQL。basedir = /application/mysql  # mysql程序所存放路径,常用于存放mysql启动、配置文件、日志等datadir = /data/3306/data  # MySQL数据存放文件(极其重要)character-set-server = utf8  # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码)log-error=/data/3306/mysql.err# mysql错误日志存放路径及名称(启动出现错误一定要看错误日志,百分之百都能通过错误日志排插解决。)pid-file=/data/3306/mysql.pid  # MySQL_pid文件记录的是当前mysqld进程的pid，pid亦即ProcessID。skip-locking# 避免MySQL的外部锁定，减少出错几率，增强稳定性。skip-name-resolv# 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时候。但是需要注意的是，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式了，否则MySQL将无法正常处理连接请求！skip-networking  # 开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果Web服务器是以远程连接的方式访问MySQL数据库服务器的，则不要开启该选项，否则无法正常连接！open_files_limit    = 1024# MySQLd能打开文件的最大个数,如果出现too mant open files之类的就需要调整该值了。back_log = 384  # back_log参数是值指出在MySQL暂时停止响应新请求之前，短时间内的多少个请求可以被存在堆栈中。如果系统在短时间内有很多连接，则需要增加该参数的值，该参数值指定到来的TCP/IP连接的监听队列的大小。不同的操作系统在这个队列的大小上有自己的限制。如果试图将back_log设置得高于操作系统的限制将是无效的，其默认值为50.对于Linux系统而言，推荐设置为小于512的整数。max_connections = 800# 指定MySQL允许的最大连接进程数。如果在访问博客时经常出现 Too Many Connections的错误提示，则需要增大该参数值。max_connect_errors = 6000  # 设置每个主机的连接请求异常中断的最大次数，当超过该次数，MySQL服务器将禁止host的连接请求，直到MySQL服务器重启或通过flush hosts命令清空此host的相关信息。wait_timeout = 120  # 指定一个请求的最大连接时间，对于4GB左右内存的服务器来说，可以将其设置为5~10。table_cache = 614K  # table_cache指示表高速缓冲区的大小。当MySQL访问一个表时，如果在MySQL缓冲区还有空间，那么这个表就被打开并放入表缓冲区，这样做的好处是可以更快速地访问表中的内容。一般来说，可以查看数据库运行峰值时间的状态值Open_tables和Open_tables，用以判断是否需要增加table_cache的值，即如果Open_tables接近table_cache的时候，并且Opened_tables这个值在逐步增加，那就要考虑增加这个值的大小了。external-locking = FALSE  # MySQL选项可以避免外部锁定。True为开启。max_allowed_packet =16M  # 服务器一次能处理最大的查询包的值，也是服务器程序能够处理的最大查询sort_buffer_size = 1M  # 设置查询排序时所能使用的缓冲区大小，系统默认大小为2MB。# 注意：该参数对应的分配内存是每个连接独占的，如果有100个连接，那么实际分配的总排序缓冲区大小为100 x6=600MB。所以，对于内存在4GB左右的服务器来说，推荐将其设置为6MB~8MBjoin_buffer_size = 8M# 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。thread_cache_size = 64# 设置Thread Cache池中可以缓存的连接线程最大数量，可设置为0~16384，默认为0.这个值表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中;如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建，如果有很多线程，增加这个值可以改善系统性能。通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。我们可以根据物理内存设置规则如下:1GB内存我们配置为8,2GB内存我们配置为16,3GB我们配置为32,4GB或4GB以上我们给此值为64或更大的值。thread_concurrency = 8  # 该参数取值为服务器逻辑CPU数量x 2，在本例中，服务器有两个物理CPU，而每个物理CPU又支持H.T超线程，所以实际取值为4 x 2 = 8。这也是双四核主流服务器的配置。query_cache_size = 64M# 指定MySQL查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况;如果Qcache_hits的值非常大，则表明查询缓冲使用得非常频繁。另外如果改值较小反而会影响效率，那么可以考虑不用查询缓冲。对于Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。query_cache_limit = 2M  # 只有小于此设置值的结果才会被缓存query_cache_min_res_unit = 2k  # 设置查询缓存分配内存的最小单位，要适当第设置此参数，可以做到为减少内存快的申请和分配次数，但是设置过大可能导致内存碎片数值上升。默认值为4K，建议设置为1K~16K。default_table_type = InnoDB  # 默认表的类型为InnoDBthread_stack = 256K  # 设置MySQL每个线程的堆栈大小，默认值足够大，可满足普通操作。可设置范围为128KB至4GB，默认为192KB#transaction_isolation = Level# 数据库隔离级别 (READ UNCOMMITTED(读取未提交内容) READ COMMITTED(读取提交内容) REPEATABLEREAD(可重读) SERIALIZABLE(可串行化))tmp_table_size = 64M  # 设置内存临时表最大值。如果超过该值，则会将临时表写入磁盘，其范围1KB到4GB。max_heap_table_size = 64M  # 独立的内存表所允许的最大容量。table_cache = 614# 给经常访问的表分配的内存，物理内存越大，设置就越大。调大这个值，一般情况下可以降低磁盘IO，但相应的会占用更多的内存,这里设置为614。table_open_cache = 512  # 设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。因此， table_cache 的大小应与 max_connections 的设置有关。例如，对于 200 个并行运行的连接，应该让表的缓存至少有 200 × N ，这里 N 是应用可以执行的查询的一个联接中表的最大数量。此外，还需要为临时表和文件保留一些额外的文件描述符。long_query_time = 1  # 慢查询的执行用时上限,默认设置是10s,推荐(1s~2s)log_long_format  # 没有使用索引的查询也会被记录。(推荐,根据业务来调整)log-slow-queries = /data/3306/slow.log  # 慢查询日志文件路径(如果开启慢查询,建议打开此日志)log-bin = /data/3306/mysql-bin  # logbin数据库的操作日志,例如update、delete、create等都会存储到binlog日志,通过logbin可以实现增量恢复relay-log = /data/3306/relay-bin# relay-log日志记录的是从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件,然后SQL线程会读取relay-log日志的内容并应用到从服务器relay-log-info-file = /data/3306/relay-log.info  # 从服务器用于记录中继日志相关信息的文件,默认名为数据目录中的relay-log.info。binlog_cache_size = 4M  # 在一个事务中binlog为了记录sql状态所持有的cache大小，如果你经常使用大的，多声明的事务，可以增加此值来获取更大的性能，所有从事务来的状态都被缓冲在binlog缓冲中，然后再提交后一次性写入到binlog中，如果事务比此值大，会使用磁盘上的临时文件来替代，此缓冲在每个链接的事务第一次更新状态时被创建。max_binlog_cache_size = 8M  # 最大的二进制Cache日志缓冲尺寸。max_binlog_size = 1G  # 二进制日志文件的最大长度(默认设置1GB)一个二进制文件信息超过了这个最大长度之前,MySQL服务器会自动提供一个新的二进制日志文件接续上。expire_logs_days = 7  # 超过7天的binlog,mysql程序自动删除(如果数据重要,建议不要开启该选项)key_buffer_size = 256M  # 指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器来说，该参数可设置为256MB或384MB。# 注意：如果该参数值设置得过大反而会使服务器的整体效率降低！read_buffer_size = 4M  # 读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。read_rnd_buffer_size = 16M# 设置进行随机读的时候所使用的缓冲区。此参数和read_buffer_size所设置的Buffer相反，一个是顺序读的时候使用，一个是随机读的时候使用。但是两者都是针对与线程的设置，每个线程都可以产生两种Buffer中的任何一个。默认值256KB，最大值4GB。bulk_insert_buffer_size = 8M  # 如果经常性的需要使用批量插入的特殊语句来插入数据,可以适当调整参数至16MB~32MB,建议8MB。myisam_sort_buffer_size = 8M# 设置在REPAIR Table或用Create index创建索引或 Alter table的过程中排序索引所分配的缓冲区大小，可设置范围4Bytes至4GB，默认为8MBlower_case_table_names = 1  # 实现MySQL不区分大小。(发开需求-建议开启)slave-skip-errors = 1032,1062  # 从库可以跳过的错误数字值(mysql错误以数字代码反馈,全的mysql错误代码大全,以后会发布至博客)。replicate-ignore-db=mysql  # 在做主从的情况下,设置不需要同步的库。server-id = 1  # 表示本机的序列号为1,如果做主从，或者多实例,serverid一定不能相同。myisam_sort_buffer_size = 128M# 当需要对于执行REPAIR, OPTIMIZE, ALTER 语句重建索引时，MySQL会分配这个缓存，以及LOAD DATA INFILE会加载到一个新表，它会根据最大的配置认真的分配的每个线程。myisam_max_sort_file_size = 10G# 当重新建索引（REPAIR，ALTER，TABLE，或者LOAD，DATA，TNFILE）时，MySQL被允许使用临时文件的最大值。myisam_repair_threads = 1# 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.myisam_recover# 自动检查和修复没有适当关闭的 MyISAM 表.innodb_additional_mem_pool_size = 4M  # 用来设置InnoDB存储的数据目录信息和其他内部数据结构的内存池大小。应用程序里的表越多，你需要在这里面分配越多的内存。对于一个相对稳定的应用，这个参数的大小也是相对稳定的，也没有必要预留非常大的值。如果InnoDB用广了这个池内的内存，InnoDB开始从操作系统分配内存，并且往MySQL错误日志写警告信息。默认为1MB，当发现错误日志中已经有相关的警告信息时，就应该适当的增加该参数的大小。innodb_buffer_pool_size = 64M  # InnoDB使用一个缓冲池来保存索引和原始数据，设置越大，在存取表里面数据时所需要的磁盘I/O越少。强烈建议不要武断地将InnoDB的Buffer Pool值配置为物理内存的50%~80%，应根据具体环境而定。innodb_data_file_path = ibdata1:128M:autoextend  # 设置配置一个可扩展大小的尺寸为128MB的单独文件，名为ibdata1.没有给出文件的位置，所以默认的是在MySQL的数据目录内。innodb_file_io_threads = 4  # InnoDB中的文件I/O线程。通常设置为4，如果是windows可以设置更大的值以提高磁盘I/Oinnodb_thread_concurrency = 8  # 你的服务器有几个CPU就设置为几，建议用默认设置，一般设为8。innodb_flush_log_at_trx_commit = 1  # 设置为0就等于innodb_log_buffer_size队列满后在统一存储，默认为1，也是最安全的设置。innodb_log_buffer_size = 2M  # 默认为1MB，通常设置为8~16MB就足够了。innodb_log_file_size = 32M  # 确定日志文件的大小，更大的设置可以提高性能，但也会增加恢复数据库的时间。innodb_log_files_in_group = 3  # 为提高性能,MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3。innodb_max_dirty_pages_pct = 90  # InnoDB主线程刷新缓存池中的数据。innodb_lock_wait_timeout = 120  # InnoDB事务被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用locak tables 语句注意到锁定设置。默认值是50秒。innodb_file_per_table = 0  # InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间。0关闭，1开启。# 独立表空间优点：# 1、每个表都有自己独立的表空间。# 2 、每个表的数据和索引都会存在自己的表空间中。# 3、可以实现单表在不同的数据库中移动。# 4、空间可以回收（除drop table操作处，表空不能自己回收。）[mysqldump]\r\n</p>\r\n<p>\r\n	quick\r\n</p>\r\n<p>\r\n	max_allowed_packet = 2M\r\n</p>\r\n<p>\r\n	# 设定在网络传输中一次消息传输量的最大值。系统默认值为1MB，最大值是1GB，必须设置为1024的倍数。单位为字节。\r\n</p>\r\n<p>\r\n	一些建议：强烈建议不要武断地将InnoDB的Buffer  Pool值配置为物理内存的50%~80%，应根据具体环境而定。如果key_reads太大，则应该把my.cnf中的key_buffer_size变大，保持key_reads/key_read_re-quests至少在1/100以上，越小越好。如果qcache_lowmem_prunes很大，就要增加query_cache_size的值。不过很多时候需要具体情况具体分析，其他参数的变更我们可以等MySQL上线稳定一段时间后在根据status值进行调整。\r\n</p>\r\n<p>\r\n	配置范例一份电子商务网站MySQL数据库调整后所运行的配置文件/etc/my.cnf(服务器为DELL R710、16GB内存、RAID10)，大家可以根据实际的MySQL数据库硬件情况进行调整配置文件如下：[client]port   = 3306socket   = /data/3306/mysql.sockdefault-character-set = utf8[mysqld]user    = mysqlport    = 3306character-set-server = utf8socket  = /data/3306/mysql.sockbasedir = /application/mysqldatadir = /data/3306/datalog-error=/data/3306/mysql_err.logpid-file=/data/3306/mysql.pidlog_slave_updates = 1log-bin = /data/3306/mysql-binbinlog_format = mixedbinlog_cache_size = 4Mmax_binlog_cache_size = 8Mmax_binlog_size = 1Gexpire_logs_days = 90binlog-ignore - db = mysqlbinlog-ignore - db = information_schemakey_buffer_size = 384Msort_buffer_size = 2Mread_buffer_size = 2Mread_rnd_buffer_size = 16Mjoin_buffer_size = 2Mthread_cache_size = 8query_cache_size = 32Mquery_cache_limit = 2Mquery_cache_min_res_unit = 2kthread_concurrency = 32table_cache = 614table_open_cache = 512open_files_limit    = 10240back_log = 600max_connections = 5000max_connect_errors = 6000external-locking = FALSEmax_allowed_packet =16Mthread_stack = 192Ktransaction_isolation = READ-COMMITTEDtmp_table_size = 256Mmax_heap_table_size = 512Mbulk_insert_buffer_size = 64Mmyisam_sort_buffer_size = 64Mmyisam_max_sort_file_size = 10Gmyisam_repair_threads = 1myisam_recoverlong_query_time = 2slow_query_logslow_query_log_file = /data/3306/slow.logskip-name-resolvskip-lockingskip-networkingserver-id = 1innodb_additional_mem_pool_size = 16Minnodb_buffer_pool_size = 512Minnodb_data_file_path = ibdata1:256M:autoextendinnodb_file_io_threads = 4innodb_thread_concurrency = 8innodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 16Minnodb_log_file_size = 128Minnodb_log_files_in_group = 3innodb_max_dirty_pages_pct = 90innodb_lock_wait_timeout = 120innodb_file_per_table = 0[mysqldump]quickmax_allowed_packet = 64M[mysql]no – auto - rehash\r\n</p>\r\n<p>\r\n	四：存储引擎的选择关于存储引擎的选择请看博客：MySQL存储引擎之Myisam和Innodb总结性梳理\r\n</p>\r\n<p>\r\n	五：线上优化调整MySQL数据库上线后，可以等其稳定运行一段时间后再根据服务器的status状态进行适当优化，我们可以用如下命令列出MySQL服务器运行的各种状态值。通过命令：show global status;  也可以通过 show status like \'查询%\';1、慢查询有时我们为了定位系统中效率比较低下的Query语法，需要打开慢查询日志，也就是Slow Query log。打开慢查询日志的相关命令如下：mysql&gt;show variables like \'%slow%\';+---------------------+-----------------------------------------+|Variable_name | Value |+---------------------+-----------------------------------------+|log_slow_queries | ON ||slow_launch_time | 2 |+---------------------+-----------------------------------------+mysql&gt;show global status like \'%slow%\';+---------------------+-------+|Variable_name | Value |+---------------------+-------+|Slow_launch_threads | 0 ||Slow_queries | 2128 |+---------------------+-------+打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响也会很小。另外，可以用MySQL自带的命令mysqldumpslow进行查询。比如：下面的命令可以查出访问次数最多的20个SQL语句：mysqldumpslow -s c -t 20 host-slow.log2、连接数我们如果经常遇见MySQL：ERROR1040：Too many connections的情况，一种情况是访问量确实很高，MySQL服务器扛不住了，这个时候就要考虑增加从服务器分散读压力，从架构层面。另外一种情况是MySQL配置文件中max_connections的值过小。来看一个例子。mysql&gt; show variables like \'max_connections\';+-----------------+-------+|Variable_name | Value |+-----------------+-------+|max_connections | 800 |+-----------------+-------+#### 这台服务器最大连接数是256，然后查询一下该服务器响应的最大连接数；mysql&gt; show global status like \'Max_used_connections\';+----------------------+-------+|Variable_name | Value |+----------------------+-------+|Max_used_connections | 245 |+----------------------+-------+#### MySQL服务器过去的最大连接数是245，没有达到服务器连接数的上线800，不会出现1040错误。#### Max_used_connections /max_connections * 100% = 85%#### 最大连接数占上限连接数的85%左右,如果发现比例在10%以下，则说明MySQL服务器连接数的上限设置得过高了。\r\n</p>\r\n<p>\r\n	3.key_buffer_sizekey_buffer_size是设置MyISAM表索引缓存空间的大小，此参数对MyISAM表性能影响最大。下面是一台MyISAM为主要存储引擎服务器的配置：mysql&gt; show variables like \'key_buffer_size\';+-----------------+-----------+|Variable_name | Value |+-----------------+-----------+|key_buffer_size | 536870912 |+-----------------+-----------+#### 从上面可以看出，分配了512MB内存给key_buffer_size。再来看key_buffer_size的使用情况：mysql&gt; show global status like \'key_read%\';+-------------------+--------------+|Variable_name | Value |+-------------------+-------+|Key_read_requests | 27813678766 ||Key_reads | 6798830|+-------------------+--------------+一共有27813678766个索引读取请求，有6798830个请求在内存中没有找到，直接从硬盘读取索引。key_cache_miss_rate = key_reads / key_read_requests * 100%比如上面的数据，key_cache_miss_rate为0.0244%，4000%个索引读取请求才有一个直接读硬盘，效果已经很好了，key_cache_miss_rate在0.1%以下都很好，如果key_cache_miss_rate在0.01%以下的话，则说明key_buffer_size分配得过多，可以适当减少。4.临时表当执行语句时，关于已经被创建了隐含临时表的数量，我们可以用如下命令查询其具体情况：mysql&gt; show global status like \'created_tmp%\';+-------------------------+----------+|Variable_name | Value |+-------------------------+----------+|Created_tmp_disk_tables | 21119 ||Created_tmp_files | 6 ||Created_tmp_tables | 17715532 |+-------------------------+----------+#### MySQL服务器对临时表的配置：mysql&gt; show variables where Variable_name in (\'tmp_table_size\',\'max_heap_table_size\');+---------------------+---------+|Variable_name | Value |+---------------------+---------+|max_heap_table_size | 2097152 ||tmp_table_size | 2097152 |+---------------------+---------+每次创建临时表时，Created_tmp_table都会增加，如果磁盘上创建临时表，Created_tmp_disk_tables也会增加。Created_tmp_files表示MySQL服务创建的临时文件数，比较理想的配置是：Created_tmp_disk_tables / Created_tmp_files *100% &lt;= 25%比如上面的服务器：Created_tmp_disk_tables / Created_tmp_files *100% =1.20%，这个值就很棒了。5.打开表的情况Open_tables表示打开表的数量，Opened_tables表示打开过的表数量，我们可以用如下命令查看其具体情况：mysql&gt; show global status like \'open%tables%\';+---------------+-------+|Variable_name | Value |+---------------+-------+|Open_tables | 351 ||Opened_tables | 1455 |#### 查询下服务器table_open_cache;mysql&gt; show variables like \'table_open_cache\';+------------------+-------+|Variable_name | Value |+------------------+-------+|table_open_cache | 2048 |+------------------+-------+如果Opened_tables数量过大，说明配置中table_open_cache的值可能太小。比较合适的值为：open_tables / opened_tables* 100% &gt; = 85%open_tables / table_open_cache* 100% &lt; = 95%6.进程使用情况如果我们在MySQL服务器的配置文件中设置了thread_cache_size，当客户端断开时，服务器处理此客户请求的线程将会缓存起来以响应一下客户而不是销毁(前提是缓存数未达上线)Thread_created表示创建过的线程数，我们可以用如下命令查看：mysql&gt; show global status like \'thread%\';+-------------------+-------+|Variable_name | Value |+-------------------+-------+|Threads_cached | 40||Threads_connected | 1 ||Threads_created | 330 ||Threads_running | 1 |+-------------------+-------+#### 查询服务器thread_cache_size配置如下：mysql&gt; show variables like \'thread_cache_size\';+-------------------+-------+|Variable_name | Value |+-------------------+-------+|thread_cache_size | 100 |+-------------------+-------+如果发现Threads_created的值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗费资源的，可以适当增大配置文件中thread_cache_size的值。\r\n</p>\r\n<p>\r\n	7.查询缓存(query cache)它主要涉及两个参数，query_cache_size是设置MySQL的Query Cache大小，query_cache_type是设置使用查询缓存的类型，我们可以用如下命令查看其具体情况：mysql&gt; show global status like \'qcache%\';+-------------------------+-----------+|Variable_name | Value |+-------------------------+-----------+|Qcache_free_blocks | 22756 ||Qcache_free_memory | 76764704 ||Qcache_hits | 213028692 ||Qcache_inserts | 208894227 ||Qcache_lowmem_prunes | 4010916 ||Qcache_not_cached | 13385031 ||Qcache_queries_in_cache | 43560 ||Qcache_total_blocks | 111212 |+-------------------------+-----------+MySQL查询缓存变量的相关解释如下：Qcache_free_blocks： 缓存中相领内存快的个数。数目大说明可能有碎片。flush query cache会对缓存中的碎片进行整理，从而得到一个空间块。Qcache_free_memory：缓存中的空闲空间。Qcache_hits：多少次命中。通过这个参数可以查看到Query Cache的基本效果。Qcache_inserts：插入次数，没插入一次查询时就增加1。命中次数除以插入次数就是命中比率。Qcache_lowmem_prunes：多少条Query因为内存不足而被清楚出Query Cache。通过Qcache_lowmem_prunes和Query_free_memory相互结合，能                          够更清楚地了解到系统中Query Cache的内存大小是否真的足够，是否非常频繁地出现因为内存不足而有Query被换出的情况。  Qcache_not_cached：不适合进行缓存的查询数量，通常是由于这些查询不是select语句或用了now()之类的函数。Qcache_queries_in_cache：当前缓存的查询和响应数量。Qcache_total_blocks：缓存中块的数量。\r\n</p>\r\n<p>\r\n	query_cache的配置命令：mysql&gt; show variables like \'query_cache%\';+------------------------------+---------+|Variable_name | Value |+------------------------------+---------+|query_cache_limit | 1048576 ||query_cache_min_res_unit | 2048 ||query_cache_size | 2097152 ||query_cache_type | ON ||query_cache_wlock_invalidate | OFF |+------------------------------+---------+字段解释如下：query_cache_limit：超过此大小的查询将不缓存。query_cache_min_res_unit：缓存块的最小值。query_cache_size：查询缓存大小。query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存select sql_no_cache查询。query_cache_wlock_invalidat：表示当有其他客户端正在对MyISAM表进行写操作，读请求是要等WRITE LOCK释放资源后再查询还是允许直接从Query Cache中读取结果，默认为OFF（可以直接从Query Cache中取得结果。）query_cache_min_res_unit的配置是一柄双刃剑，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。 查询缓存碎片率 = Qcache_free_blocks /Qcache_total_blocks * 100%如果查询碎片率超过20%，可以用 flush query cache 整理缓存碎片，或者试试减少query_cache_min_res_unit，如果你查询都是小数据库的话。 查询缓存利用率 = (Qcache_free_size –  Qcache_free_memory)/query_cache_size * 100%查询缓存利用率在25%一下的话说明query_cache_size设置得过大，可适当减少;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话则说明query_cache_size可能有点小，不然就是碎片太多。 查询命中率 = (Qcache_hits - Qcache_insert)/Qcache)hits * 100%示例服务器中的查询缓存碎片率等于20%左右，查询缓存利用率在50%，查询命中率在2%，说明命中率很差，可能写操作比较频繁，而且可能有些碎片。\r\n</p>\r\n<p>\r\n	8.排序使用情况它表示系统中对数据进行排序时所用的Buffer，我们可以用如下命令查看：mysql&gt; show global status like \'sort%\';+-------------------+----------+|Variable_name | Value |+-------------------+----------+|Sort_merge_passes | 10 ||Sort_range | 37431240 ||Sort_rows | 6738691532 ||Sort_scan | 1823485 |+-------------------+----------+Sort_merge_passes包括如下步骤：MySQL首先会尝试在内存中做排序，使用的内存大小由系统变量sort_buffer_size来决定，如果它不够大则把所有的记录都读在内存中，而MySQL则会把每次在内存中排序的结果存到临时文件中，等MySQL找到所有记录之后，再把临时文件中的记录做一次排序。这次再排序就会增加sort_merge_passes。实际上，MySQL会用另外一个临时文件来存储再次排序的结果，所以我们通常会看sort_merge_passes增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增大sort_buffer_size会减少sort_merge_passes和创建临时文件的次数，但盲目地增大sort_buffer_size并不一定能提高速度。\r\n</p>\r\n<p>\r\n	9.文件打开数(open_files)我们现在处理MySQL故障时，发现当Open_files大于open_files_limit值时，MySQL数据库就会发生卡住的现象，导致Nginx服务器打不开相应页面。这个问题大家在工作中应注意，我们可以用如下命令查看其具体情况：show global status like \'open_files\';+---------------+-------+|Variable_name | Value |+---------------+-------+|Open_files | 1481 |+---------------+-------+mysql&gt; show global status like \'open_files_limit\';+------------------+-------+|Variable_name | Value |+------------------+--------+|Open_files_limit | 4509 |+------------------+--------+比较合适的设置是：Open_files / Open_files_limit * 100% &lt; = 75% 10.InnoDB_buffer_pool_cache合理设置InnoDB存储引擎的缓存机制和MyISAM的最大区别就在于，InnoDB不仅仅缓存索引，同时还会缓存实际的数据。此参数用来设置InnoDB最主要的Buffer的大小，也就是缓存用户表及索引数据的最主要缓存空间，对InnoDB整体性能影响也最大。无论是MySQL官方手册还是网络上许多人分享的InnoDB优化建议，都是简单地建议将此值设置为整个系统物理内存的50%~80%。这种做法其实不妥，我们应根据实际的运行场景来正确设置此项参数。 很多时候我们会发现，通过参数设置进行性能优化所带来的性能提升，并不如许多人想象的那样会产生质的飞跃，除非是之前的设置存在严重不合理的情况。我们不能将性能调优完全依托与通过DBA在数据库上线后进行参数调整，而应该在系统设计和开发阶段就尽可能减少性能问题。(重点在于前期架构合理的设计及开发的程序合理)\r\n</p>\r\n<p>\r\n	六：MySQL数据库的可扩展架构方案（即高可用方案） &nbsp; 可参考：mysql高可用方案总结性说明如果凭借MySQL的优化任无法顶住压力，这个时候我们就必须考虑MySQL的可扩展性架构了(有人称为MySQL集群)它有以下明显的优势：1）成本低，很容易通过价格低廉Pc server搭建出一个处理能力非常强大的计算机集群。2）不太容易遇到瓶颈，因为很容易通过添加主机来增加处理能力。3）单节点故障对系统的整体影响较小。1、主从复制解决方案这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。MySQL replication就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。为了达到更高的可用性，在实际的应用环境中，一般都是采用MySQL replication技术配合高可用集群软件keepalived来实现自动failover，这种方式可以实现95.000%的SLA。\r\n</p>\r\n<p>\r\n	在实际应用场景中，MySQL Replication是使用最为广泛的一种提高系统扩展性的设计手段。众多的MySQL使用者通过Replication功能提升系统的扩展性后，通过 简单的增加价格低廉的硬件设备成倍 甚至成数量级地提高了原有系统的性能，是广大MySQL中低端使用者非常喜欢的功能之一，也是许多MySQL使用者选择MySQL最为重要的原因。比较常规的MySQL Replication架构也有好几种，这里分别简单说明下：MySQL Replication架构一：常规复制架构–Master-slaves是由一个Master复制到一个或多个Salve的架构模式，主要用于读压力大的应用数据库端廉价扩展解决方案，读写分离，Master主要负责写方面的压力。MySQL Replication架构二：级联复制架构即Master-Slaves-Slaves,这个也是为了防止Slaves的读压力过大，而配置一层二级 Slaves，很容易解决Master端因为附属slave太多而成为瓶劲的风险。MySQL Replication架构三：Dual Master与级联复制结合架构即Master-Master-Slaves，最大的好处是既可以避免主Master的写操作受到Slave集群的复制带来的影响，而且保证了主Master的单点故障。MySQL Replication的不足：如果Master主机硬件故障无法恢复，则可能造成部分未传送到slave端的数据丢失。所以大家应该根据自己目前的网络 规划，选择自己合理的Mysql架构方案，跟自己的MySQL DBA和程序员多沟涌，多备份(备份我至少会做到本地和异地双备份)，多测试，数据的事是最大的事，出不得半点差错，切记切记2、MMM/MHA高可用解决方案MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。\r\n</p>\r\n<p>\r\n	3、Heartbeat/SAN高可用解决方案在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。\r\n</p>\r\n<p>\r\n	4、Heartbeat/DRBD高可用解决方案此方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。\r\n</p>\r\n<p>\r\n	5、percona xtradb clusterPercona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。3）每个节点都包含完整的数据副本。PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MYSQL经典应用架构\r\n</p>\r\n<p>\r\n	其中：Dbm157是mysql主，dbm158是mysql主的备机，dbs159/160/161是mysql从。\r\n</p>\r\n<p>\r\n	MySQL写操作一般采用基于heartbeat+DRBD+MySQL搭建高可用集群的方案。通过heartbeat实现对mysql主进行状态监测，而DRBD实现dbm157数据同步到dbm158。\r\n</p>\r\n<p>\r\n	读操作普遍采用基于LVS+Keepalived搭建高可用高扩展集群的方案。前端AS应用通过提高的读VIP连接LVS，LVS有keepliaved做成高可用模式，实现互备。\r\n</p>\r\n<p>\r\n	最后，mysql主的从节点dbs159/160/161通过mysql主从复制功能同步mysql主的数据，通过lvs功能提供给前端AS应用进行读操作，并实现负载均衡。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('c90ff560-d2b1-4b89-bbe1-167592e7465a','Mysql的二进制日志binlog的模式说明','Mysql的二进制日志binlog的模式说明','<p>\r\n	binlog模式总共可分为以下三种：row，statement，mixed\r\n</p>\r\n<p>\r\n	1.Row日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况。优点：在row模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了，所以row的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程和function，以及trigger的调用和出发无法被正确复制问题。缺点：在row模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。\r\n</p>\r\n<p>\r\n	mysql&gt; insert into username(username) select * from aa;\r\n</p>\r\n<p>\r\n	ERROR 1146 (42S02): Table \'test.username\' doesn\'t exist\r\n</p>\r\n<p>\r\n	mysql&gt; insert into user(username) select * from aa;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	Records: 1 &nbsp;Duplicates: 0 &nbsp;Warnings: 0\r\n</p>\r\n<p>\r\n	查看binlog\r\n</p>\r\n<p>\r\n	root@xuebinbin:/vobiledata/mysqllog# mysqlbinlog mysql-bin.000017\r\n</p>\r\n<p>\r\n	BINLOG \'\r\n</p>\r\n<p>\r\n	63EfUBNQAAAALgAAAA8CAAAAAA8AAAAAAAEABHRlc3QABHVzZXIAAgIPAi0AAA==\r\n</p>\r\n<p>\r\n	63EfUBdQAAAAJgAAADUCAAAAAA8AAAAAAAEAAv/8BAAFYmFveXU=\r\n</p>\r\n<p>\r\n	\'/*!*/;\r\n</p>\r\n<p>\r\n	### INSERT INTO test.user\r\n</p>\r\n<p>\r\n	### SET\r\n</p>\r\n<p>\r\n	### &nbsp; @1=4 /* SHORTINT meta=0 nullable=0 is_null=0 */\r\n</p>\r\n<p>\r\n	### &nbsp; @2=\'baoyu\' /* VARSTRING(45) meta=45 nullable=0 is_null=0 */\r\n</p>\r\n<p>\r\n	# at 565\r\n</p>\r\n<p>\r\n	#120806 &nbsp;0:27:39 server id 80 &nbsp;end_log_pos 592 &nbsp; &nbsp; Xid = 20\r\n</p>\r\n<p>\r\n	COMMIT/*!*/;\r\n</p>\r\n<p>\r\n	DELIMITER ;\r\n</p>\r\n<p>\r\n	# End of log file\r\n</p>\r\n<p>\r\n	ROLLBACK /* added by mysqlbinlog */;\r\n</p>\r\n<p>\r\n	/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\r\n</p>\r\n<p>\r\n	由此可见，row模式是针对每一行的数据，而于关联表无关，它把关联中的相应数据记录在log中。这样一来会产生大量的数据。\r\n</p>\r\n<p>\r\n	2.statement每一条会修改数据的sql都会记录到master的binlog中，slave在复制的时候sql进程会解析成和原来master端执行多相同的sql再执行。优点：在statement模式下首先就是解决了row模式的缺点，不需要记录每一行数据的变化减少了binlog日志量，节省了I/O以及存储资源，提高性能。因为他只需要激励在master上所执行的语句的细节一届执行语句时候的上下的信息。缺点：在statement模式下，由于他是记录的执行语句，所以，为了让这些语句在slave端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果。另外就是，由于mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement中，目前已经发现不少情况会造成Mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep()函数在有些版本中就不能被正确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。由于row是基于每一行来记录的变化，所以不会出现，类似的问题。\r\n</p>\r\n<p>\r\n	mysql&gt; insert into user(username) values(\'xuebinbin\');\r\n</p>\r\n<p>\r\n	ERROR 1598 (HY000): Binary logging not possible. Message: Transaction level \'READ-COMMITTED\' in InnoDB is not safe for binlog mode \'STATEMENT\'\r\n</p>\r\n<p>\r\n	mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ\r\n</p>\r\n<p>\r\n	-&gt; ;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into user(username) values(\'xuebinbin\');\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	查看binlog\r\n</p>\r\n<p>\r\n	root@xuebinbin:/vobiledata/mysqllog# mysqlbinlog mysql-bin.000008\r\n</p>\r\n<p>\r\n	BEGIN\r\n</p>\r\n<p>\r\n	/*!*/;\r\n</p>\r\n<p>\r\n	# at 174\r\n</p>\r\n<p>\r\n	#120806 14:47:35 server id 80 &nbsp;end_log_pos 202 &nbsp; &nbsp; Intvar\r\n</p>\r\n<p>\r\n	SET INSERT_ID=2/*!*/;\r\n</p>\r\n<p>\r\n	# at 202\r\n</p>\r\n<p>\r\n	#120806 14:47:35 server id 80 &nbsp;end_log_pos 311 &nbsp; &nbsp; Query &nbsp; &nbsp;thread_id=5 &nbsp; &nbsp;exec_time=0 &nbsp; &nbsp;error_code=0\r\n</p>\r\n<p>\r\n	use test/*!*/;\r\n</p>\r\n<p>\r\n	SET TIMESTAMP=1344235655/*!*/;\r\n</p>\r\n<p>\r\n	insert into user(username) values(\'xuebinbin\')\r\n</p>\r\n<p>\r\n	/*!*/;\r\n</p>\r\n<p>\r\n	# at 311\r\n</p>\r\n<p>\r\n	#120806 14:47:35 server id 80 &nbsp;end_log_pos 338 &nbsp; &nbsp; Xid = 20\r\n</p>\r\n<p>\r\n	COMMIT/*!*/;\r\n</p>\r\n<p>\r\n	# at 338\r\n</p>\r\n<p>\r\n	#120806 14:53:18 server id 80 &nbsp;end_log_pos 357 &nbsp; &nbsp; Stop\r\n</p>\r\n<p>\r\n	DELIMITER ;\r\n</p>\r\n<p>\r\n	# End of log file\r\n</p>\r\n<p>\r\n	ROLLBACK /* added by mysqlbinlog */;\r\n</p>\r\n<p>\r\n	/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\r\n</p>\r\n<p>\r\n	结果发现statement是以sql记录形式记录的。这样的话一个sql就只记录一条，减少了大量的数据存储。\r\n</p>\r\n<p>\r\n	3.Mixed（该模式是STATEMENT和ROW的混合使用。）早起的MySQL一直都只有基于statemen 的复制模式，直到5.1.5版本的MySQL才开始支持row 复制。从5.0 开始，MySQL的复制已经解决了大量老版本中出现的无法正确复制的问题。但是由于存储过程的出现，给 MySQL Replication 又带来了更大的新挑战。从5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，并不是所有的修改都会以 row 模式来记录，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('caa5312a-bcb7-4982-90dc-f4ce64949244','Mysql读写分离方案－Amoeba环境部署记录','Mysql读写分离方案－Amoeba环境部署记录','<p>\r\n	Mysql的读写分离可以使用MySQL Proxy，也可以使用Amoeba。Amoeba(变形虫)项目是一个类似MySQL Proxy的分布式数据库中间代理层软件，是由陈思儒开发的一个开源的java项目。其主要功能包括读写分离，垂直分库，水平分库等，经过测试，发现其功能和稳定性都非常的不错，如果需要构架分布式数据库环境，采用Amoeba是一个不错的方案。目前Amoeba一共包括For aladdin,For MySQL和For Oracle三个版本，以下介绍主要关注For MySQL版本的一个读写分离实现。实际上垂直切分和水平切分的架构也相差不大，改动几个配置就可以轻松实现。下图是一个采用Amoeba的读写分离技术结合MySQL的Master-Slave Replication的一个分布式系统的架构：\r\n</p>\r\n<p>\r\n	Amoeba处于在应用和数据库之间，扮演一个中介的角色，将应用传递过来的SQL语句经过分析后，将写的语句交给Master库执行，将读的语句路由到Slave库执行（当然也可以到Master读，这个完全看配置）。Amoeba实现了简单的负载均衡（采用轮询算法，在配置文件里设置）和Failover。如果配置了多个读的库，则任何一个读的库出现宕机，不会导致整个系统故障，Amoeba能自动将读请求路由到其他可用的库上，当然，写还是单点的依赖于Master数据库的，这个需要通过数据库的切换，或者水平分割等技术来提升Master库的可用性。\r\n</p>\r\n<p>\r\n	Amoeba可以在不同机器上启动多个，并且做同样的配置来进行水平扩展，以分担压力和提升可用性，可以将Amoeba和MySQL装在同一台机器，也可以装在不同的机器上，Amoeba本身不做数据缓存，所以对于内存消耗很少，主要是CPU占用。对于应用来说，图中的三个Amoeba就是三台一模一样的MySQL数据库，连接其中任何一台都是可以的，所以需要在应用端有一个Load balance和Failover的机制，需要连接数据库时从三台中随机挑选一台即可，如果其他任何一台出现故障，则可以自动Failover到剩余的可用机器上。MySQL的JDBC驱动从connector-j 3.17版本起已经提供了这样的负载均衡和故障切换的功能，那么剩下的事情对于应用来说就很简单了，不需要做太多的改动就能搭建一套高可用的MySQL分布式数据库环境，何乐而不为？\r\n</p>\r\n<p>\r\n	Amoeba专注分布式数据库proxy开发。Amoeba身处在Client、DB Server(s)之间，对客户端透明，具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的query到目标数据库、可并发请求多台数据库合并结果。Amoeba主要解决：1）降低 数据切分带来的复杂多数据库结构2）提供切分规则并降低 数据切分规则 给应用带来的影响3）降低db 与客户端的连接数4）读写分离\r\n</p>\r\n<p>\r\n	为什么要用Amoeba目前要实现mysql的主从读写分离，主要有以下几种方案：1）通过程序实现，网上很多现成的代码，比较复杂，如果添加从服务器要更改多台服务器的代码。2）通过mysql-proxy来实现，由于mysql-proxy的主从读写分离是通过lua脚本来实现，目前lua的脚本的开发跟不上节奏，而写没有完美的现成的脚本，因此导致用于生产环境的话风险比较大，据网上很多人说mysql-proxy的性能不高。3）自己开发接口实现，这种方案门槛高，开发成本高，不是一般的小公司能承担得起。4）利用阿里巴巴的开源项目Amoeba来实现，具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的query到目标数据库，并且安装配置非常简单。经测试，性能相比mysql-proxy较高。\r\n</p>\r\n<p>\r\n	下面就基于Amoeba的读写分离环节部署做一记录：\r\n</p>\r\n<p>\r\n	1）环境准备\r\n</p>\r\n<p>\r\n	182.48.115.236     master-node\r\n</p>\r\n<p>\r\n	182.48.115.238     slave-node\r\n</p>\r\n<p>\r\n	182.48.115.237     amoeba-node\r\n</p>\r\n<p>\r\n	182.48.115.236和182.48.115.238做成mysql主从复制。关闭三台机器的iptables防火墙和selinux\r\n</p>\r\n<p>\r\n	mysql安装参考：http://www.cnblogs.com/kevingrace/p/6109679.html\r\n</p>\r\n<p>\r\n	mysql主从部署参考：http://www.cnblogs.com/kevingrace/p/6256603.html\r\n</p>\r\n<p>\r\n	2）amoeba安装\r\n</p>\r\n<p>\r\n	Amoeba框架是居于JDK1.5开发的，采用了JDK1.5的特性，所以还需要安装java环境，建议使用javaSE1.5以上的JDK版本.\r\n</p>\r\n<p>\r\n	1）安装java环境\r\n</p>\r\n<p>\r\n	安装参考：http://www.cnblogs.com/kevingrace/p/5870814.html\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# yum -y install java-1.7.0-openjdk*\r\n</p>\r\n<p>\r\n	设置java的环境变量\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# vim /etc/profile\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk.x86_64\r\n</p>\r\n<p>\r\n	export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\n</p>\r\n<p>\r\n	export PATH=$PATH:$JAVA_HOME/bin\r\n</p>\r\n<p>\r\n	使之生效\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# source /etc/profile\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# java -version\r\n</p>\r\n<p>\r\n	java version \"1.7.0_141\"\r\n</p>\r\n<p>\r\n	OpenJDK Runtime Environment (rhel-2.6.10.1.el6_9-x86_64 u141-b02)\r\n</p>\r\n<p>\r\n	OpenJDK 64-Bit Server VM (build 24.141-b02, mixed mode)\r\n</p>\r\n<p>\r\n	2）安装Amoeba\r\n</p>\r\n<p>\r\n	下载地址：https://sourceforge.net/projects/amoeba/\r\n</p>\r\n<p>\r\n	百度云盘下载：https://pan.baidu.com/s/1c1FRsbe    提取密码：xav2\r\n</p>\r\n<p>\r\n	Amoeba安装非常简单，直接解压即可使用，这里将Amoeba解压到/usr/local/amoeba目录下，这样就安装完成了\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# unzip amoeba-mysql-3.0.5-RC-distribution.zip\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# mv amoeba-mysql-3.0.5-RC /usr/local/amoeba\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# cd /usr/local/amoeba\r\n</p>\r\n<p>\r\n	[root@amoeba-node amoeba]# ll\r\n</p>\r\n<p>\r\n	总用量 20\r\n</p>\r\n<p>\r\n	drwxrwxrwx. 2 root root 4096 7月   5 2013 benchmark\r\n</p>\r\n<p>\r\n	drwxrwxrwx. 2 root root 4096 7月   5 2013 bin\r\n</p>\r\n<p>\r\n	drwxrwxrwx. 2 root root 4096 7月   5 2013 conf\r\n</p>\r\n<p>\r\n	-rwxrwxrwx. 1 root root  728 7月   5 2013 jvm.properties\r\n</p>\r\n<p>\r\n	drwxrwxrwx. 2 root root 4096 7月   5 2013 lib\r\n</p>\r\n<p>\r\n	3）配置Amoeba\r\n</p>\r\n<p>\r\n	Amoeba的配置文件位于/usr/local/amoeba/conf目录下。配置文件比较多，但是仅仅使用读写分离功能，只需配置两个文件即可，分别是dbServers.xml和amoeba.xml，\r\n</p>\r\n<p>\r\n	如果需要配置ip访问控制，还需要修改access_list.conf文件，下面首先介绍dbServers.xml的配置：\r\n</p>\r\n<p>\r\n	[root@amoeba-node amoeba]# cat conf/dbServers.xml\r\n</p>\r\n<p>\r\n	<!--?xml version=\"1.0\" encoding=\"gbk\"?-->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!--\r\n</p>\r\n<p>\r\n	Each dbServer needs to be configured into a Pool,\r\n</p>\r\n<p>\r\n	If you need to configure multiple dbServer with load balancing that can be simplified by the following configuration:\r\n</p>\r\n<p>\r\n	add attribute with name virtual = \"true\" in dbServer, but the configuration does not allow the element with name factoryConfig\r\n</p>\r\n<p>\r\n	such as \'multiPool\' dbServer\r\n</p>\r\n<p>\r\n	-->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	${defaultManager}\r\n</p>\r\n<p>\r\n	64\r\n</p>\r\n<p>\r\n	128\r\n</p>\r\n<p>\r\n	<!-- mysql port -->\r\n</p>\r\n<p>\r\n	3306//设置Amoeba要连接的mysql数据库的端口，默认是3306\r\n</p>\r\n<p>\r\n	<!-- mysql schema -->\r\n</p>\r\n<p>\r\n	huanqiutest//设置缺省的数据库，当连接amoeba时，操作表必须显式的指定数据库名，即采用dbname.tablename的方式，不支持 use dbname指定缺省库，因为操作会调度到各个后端dbserver\r\n</p>\r\n<p>\r\n	<!-- mysql user -->\r\n</p>\r\n<p>\r\n	wang//设置amoeba连接后端数据库服务器的账号，因此需要在所有后端数据库上创建该用户，并授权amoeba服务器可连接\r\n</p>\r\n<p>\r\n	wang123456//设置amoeba连接后端数据库服务器的密码\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	500//最大连接数，默认500\r\n</p>\r\n<p>\r\n	500//最大空闲连接数\r\n</p>\r\n<p>\r\n	1//最新空闲连接数\r\n</p>\r\n<p>\r\n	600000\r\n</p>\r\n<p>\r\n	600000\r\n</p>\r\n<p>\r\n	true\r\n</p>\r\n<p>\r\n	true\r\n</p>\r\n<p>\r\n	true\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	//设置一个后端可写的dbServer，这里定义为masterdb，这个名字可以任意命名，后面在amoeba.xml文件里会用到\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- mysql ip -->\r\n</p>\r\n<p>\r\n	182.48.115.236//设置后端可写dbserver的ip\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	//设置后端可读dbserver（如果是多个slave从节点，这里就配置多个<dbserver ...,然后加入到后面第一的可读的组内）<=\"\" p=\"\">\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- mysql ip -->\r\n</p>\r\n<p>\r\n	182.48.115.238//设置后端可读dbserver的ip\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	//设置定义一个虚拟的dbserver，实际上相当于一个dbserver组，这里将可读的数据库ip统一放到一个组中，将这个组的名字命名为myslave\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA-->\r\n</p>\r\n<p>\r\n	1//选择调度算法，1表示复制均衡，2表示权重，3表示HA， 这里选择1\r\n</p>\r\n<p>\r\n	<!-- Separated by commas,such as: server1,server2,server1 -->\r\n</p>\r\n<p>\r\n	slavedb//myslave组成员\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	另一个配置文件amoeba.xml\r\n</p>\r\n<p>\r\n	[root@amoeba-node amoeba]# cat conf/amoeba.xml\r\n</p>\r\n<p>\r\n	<!--?xml version=\"1.0\" encoding=\"gbk\"?-->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- service class must implements com.meidusa.amoeba.service.Service -->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- port -->\r\n</p>\r\n<p>\r\n	8066//设置amoeba监听的端口，默认是8066\r\n</p>\r\n<p>\r\n	<!-- bind ipAddress -->                        //下面配置监听的接口，如果不设置，默认监听所以的IP\r\n</p>\r\n<p>\r\n	<!--\r\n</p>\r\n<p>\r\n	127.0.0.1\r\n</p>\r\n<p>\r\n	-->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	128\r\n</p>\r\n<p>\r\n	64\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	root//提供客户端连接amoeba时需要使用这里设定的账号 (这里的账号密码和amoeba连接后端数据库服务器的密码无关)\r\n</p>\r\n<p>\r\n	123456\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	${amoeba.home}/conf/access_list.conf\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- proxy server client process thread size -->\r\n</p>\r\n<p>\r\n	128\r\n</p>\r\n<p>\r\n	<!-- per connection cache prepared statement size -->\r\n</p>\r\n<p>\r\n	500\r\n</p>\r\n<p>\r\n	<!-- default charset -->\r\n</p>\r\n<p>\r\n	utf8\r\n</p>\r\n<p>\r\n	<!-- query timeout( default: 60 second , TimeUnit:second) -->\r\n</p>\r\n<p>\r\n	60\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!--\r\n</p>\r\n<p>\r\n	Each ConnectionManager will start as thread\r\n</p>\r\n<p>\r\n	manager responsible for the Connection IO read , Death Detection\r\n</p>\r\n<p>\r\n	-->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	com.meidusa.toolkit.net.AuthingableConnectionManager\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<!-- default using file loader -->\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	${amoeba.home}/conf/dbServers.xml\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	${amoeba.home}/conf/rule.xml\r\n</p>\r\n<p>\r\n	${amoeba.home}/conf/ruleFunctionMap.xml\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	${amoeba.home}/conf/functionMap.xml\r\n</p>\r\n<p>\r\n	1500\r\n</p>\r\n<p>\r\n	masterdb//设置amoeba默认的池，这里设置为masterdb(这个是在dbServers.xml文件里定义的)\r\n</p>\r\n<p>\r\n	masterdb//这两个选项默认是注销掉的，一定要取消注释！否则读写分离无效，这里用来指定前面定义好的写池\r\n</p>\r\n<p>\r\n	myslave//取消注释，这个是前面在dbServers.xml文件里定义的读池\r\n</p>\r\n<p>\r\n	true\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	4）在masterdb上（即master节点机182.48.115.236上）创建数据库huanqiutest\r\n</p>\r\n<p>\r\n	mysql&gt; create database huanqiutest;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiutest        |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	然后在slavedb上（即slave节点182.48.115.238上）查看是否复制成功\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiutest        |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	分别在masterdb和slavedb上为amoedb授权\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT ALL ON huanqiutest.* TO \'wang\'@\'182.48.115.237\' IDENTIFIED BY \'wang123456\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	启动amoeba\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# /usr/local/amoeba/bin/launcher\r\n</p>\r\n<p>\r\n	....................................................................................\r\n</p>\r\n<p>\r\n	报错1:\r\n</p>\r\n<p>\r\n	The stack size specified is too small, Specify at least 228k\r\n</p>\r\n<p>\r\n	Error: Could not create the Java Virtual Machine.\r\n</p>\r\n<p>\r\n	Error: A fatal exception has occurred. Program will exit.\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	从错误文字上看，应该是由于stack size太小，导致JVM启动失败，要如何修改呢？\r\n</p>\r\n<p>\r\n	其实Amoeba已经考虑到这个问题，并将JVM参数配置写在属性文件里，可以通过该属性文件修改JVM参数。\r\n</p>\r\n<p>\r\n	修改jvm.properties文件JVM_OPTIONS参数。\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# vim /usr/local/amoeba/jvm.properties\r\n</p>\r\n<p>\r\n	将内容\r\n</p>\r\n<p>\r\n	JVM_OPTIONS=\"-server -Xms256m -Xmx1024m -Xss196k -XX:PermSize=16m -XX:MaxPermSize=96m\"\r\n</p>\r\n<p>\r\n	修改为\r\n</p>\r\n<p>\r\n	JVM_OPTIONS=\"-server -Xms1024m -Xmx1024m -Xss256k -XX:PermSize=16m -XX:MaxPermSize=96m\"\r\n</p>\r\n<p>\r\n	再次启动Amoeba就ok了\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# nohup /usr/local/amoeba/bin/launcher &amp;      //将amoeba放在后台执行。该命令执行后，按ctrl＋c\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# ps -ef|grep amoeba\r\n</p>\r\n<p>\r\n	root     19079     1  1 15:01 pts/0    00:00:02 /usr/lib/jvm/java-1.7.0-openjdk.x86_64/bin/java -server -Xms1024m -Xmx1024m -Xss256k -XX:PermSize=16m -XX:MaxPermSize=96m -Dproject.home=/usr/local/amoeba -Damoeba.home=/usr/local/amoeba -Dproject.name=Amoeba-MySQL -Dproject.output=/usr/local/amoeba/logs -Dignore.signals=1,2 -Dclassworlds.conf=/usr/local/amoeba/bin/launcher.classpath -classpath /usr/local/amoeba/lib/plexus-classworlds-2.4.2-HEXNOVA.jar org.codehaus.classworlds.Launcher\r\n</p>\r\n<p>\r\n	root     19103 19009  0 15:02 pts/0    00:00:00 /bin/bash /usr/local/amoeba/bin/launcher\r\n</p>\r\n<p>\r\n	root     19109 19103  0 15:02 pts/0    00:00:00 tail -f /usr/local/amoeba/logs/console.log\r\n</p>\r\n<p>\r\n	root     19172 19009  0 15:04 pts/0    00:00:00 grep amoeba\r\n</p>\r\n<p>\r\n	[root@amoeba-node ~]# lsof -i:8066\r\n</p>\r\n<p>\r\n	COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\r\n</p>\r\n<p>\r\n	java    19079 root   64u  IPv6 2705157      0t0  TCP *:8066 (LISTEN)\r\n</p>\r\n<p>\r\n	..................................................................................\r\n</p>\r\n<p>\r\n	3）amoeba读写分离测试\r\n</p>\r\n<p>\r\n	注意：上面在amoeba.xml中指定的连接amoba的帐号和密码（即root／123456）要提前在master和slave两台节点机上授权\r\n</p>\r\n<p>\r\n	mysql&gt; grant all on *.* to root@\'182.58.115.%\' identified by \"123456\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	然后在mysql客户端通过amoeba配置文件amoeba.xml中指定的用户名、密码、和端口以及amoeba服务器ip地址远程登陆mysql数据库\r\n</p>\r\n<p>\r\n	[root@localhost ~]# mysql -h182.48.115.237 -uroot -p123456 -P8066\r\n</p>\r\n<p>\r\n	Welcome to the MySQL monitor.  Commands end with ; or \\g.\r\n</p>\r\n<p>\r\n	Your MySQL connection id is 2052322366\r\n</p>\r\n<p>\r\n	Server version: 5.1.45-mysql-amoeba-proxy-3.0.4-BETA Source distribution\r\n</p>\r\n<p>\r\n	Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	Oracle is a registered trademark of Oracle Corporation and/or its\r\n</p>\r\n<p>\r\n	affiliates. Other names may be trademarks of their respective\r\n</p>\r\n<p>\r\n	owners.\r\n</p>\r\n<p>\r\n	Type \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiutest        |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	在huanqiutest库创建haha表，并插入数据\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiutest;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table if not exists haha (id int(10) PRIMARY KEY AUTO_INCREMENT,name varchar(50) NOT NULL);\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.20 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into haha values(1,\"wangshibo\"),(2,\"guohuihui\");\r\n</p>\r\n<p>\r\n	Query OK, 2 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	Records: 2  Duplicates: 0  Warnings: 0\r\n</p>\r\n<p>\r\n	mysql&gt; select * from haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	分别登陆masterdb（即master-node节点）和slavedb（slave-node节点）查看数据\r\n</p>\r\n<p>\r\n	master-node数据库\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiutest.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	slave-node数据库\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiutest.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	停掉masterdb，然后在客户端分别执行插入和查询功能\r\n</p>\r\n<p>\r\n	[root@master-node ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL............ SUCCESS!\r\n</p>\r\n<p>\r\n	客户端连接amoeba后插入新数据\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiutest.haha values(3,\"zhangmin\");\r\n</p>\r\n<p>\r\n	ERROR 1044 (42000): Amoeba could not connect to MySQL server[182.48.115.236:3306],拒绝连接\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiutest.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.01 sec)\r\n</p>\r\n<p>\r\n	可以看到，关掉masterdb后，写入报错，读正常\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	开启masterdb上的msyql 关闭slavedb上的mysql\r\n</p>\r\n<p>\r\n	masterdb\r\n</p>\r\n<p>\r\n	[root@master-node ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	slavedb\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL....                                    [确定]\r\n</p>\r\n<p>\r\n	客户端再次尝试\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiutest.haha values(3,\"zhangmin\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiutest.haha;\r\n</p>\r\n<p>\r\n	ERROR 1044 (42000): poolName=myslave, no valid pools\r\n</p>\r\n<p>\r\n	可以看到插入成功，读取失败\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	开启slavedb上的mysql，查看数据是否自动同步\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL..                                           [确定]\r\n</p>\r\n<p>\r\n	客户端：\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiutest.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	|  3 | zhangmin  |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	由此可见，amoeba的读写分离的效果已经很明显了！上面是amoeba针对一个库的读写分离配置，如果是多个库的读写分离，可以部署多个amoeba实例，amoeba端口不一样，然后启动多个实例即可。\r\n</p>\r\n<p>\r\n	....................................................................................................................Amoeba的有关配置文件说明\r\n</p>\r\n<p>\r\n	主配置文件：amoeba.xml                  用来配置Amoeba服务的基本参数，如Amoeba主机地址、端口、认证方式、用于连接的用户名、密码、线程数、超时时间、其他配置文件的位置等。\r\n</p>\r\n<p>\r\n	数据库服务器配置文件：dbServers.xml       用来存储和配置Amoeba所代理的数据库服务器的信息，如:主机IP、端口、用户名、密码等。\r\n</p>\r\n<p>\r\n	切分规则配置文件rule.xml                 用来配置切分规则。\r\n</p>\r\n<p>\r\n	数据库函数配置文件:functionMap.xml       用来配置数据库函数的处理方法，Amoeba将使用该配置文件中的方法解析数据库函数。\r\n</p>\r\n<p>\r\n	切分规则函数配置文件ruleFunctionMap.xml   用来配置切分规则中使用的用户自定义函数的处理方法。\r\n</p>\r\n<p>\r\n	访问规则配置文件:access_list.conf        用来授权或禁止某些服务器IP访问Amoeba。\r\n</p>\r\n<p>\r\n	日志规格配置文件log4j.xml                用来配置Amoeba输出日志的级别和方式。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('cda6334f-1b08-418d-807b-1c021a1ade88','Nginx code 状态码说明','Nginx code 状态码说明','<p>\r\n	最近了解下Nginx的Code状态码，在此简单总结下。一个http请求处理流程：\r\n</p>\r\n<p>\r\n	一个普通的http请求处理流程，如上图所示：A -&gt; client端发起请求给nginxB -&gt; nginx处理后，将请求转发到uwsgi，并等待结果C -&gt; uwsgi处理完请求后，返回数据给nginxD -&gt; nginx将处理结果返回给客户端每个阶段都会有一个预设的超时时间，由于网络、机器负载、代码异常等等各种原因，如果某个阶段没有在预期的时间内正常返回，就会导致这次请求异常，进而产生不同的状态码。\r\n</p>\r\n<p>\r\n	1）504504主要是针对B、C阶段。一般nginx配置中会有：\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	uwsgi_connect_timeout 6s;\r\n</p>\r\n<p>\r\n	uwsgi_send_timeout 6s;\r\n</p>\r\n<p>\r\n	uwsgi_read_timeout 10s;\r\n</p>\r\n<p>\r\n	uwsgi_buffering on;\r\n</p>\r\n<p>\r\n	uwsgi_buffers 80 16k;\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这个代表nginx与上游服务器（uwsgi）通信的超时时间，也就是说，如果在这个时间内，uwsgi没有响应，则认为这次请求超时，返回504状态码。\r\n</p>\r\n<p>\r\n	具体的日志如下：\r\n</p>\r\n<p>\r\n	access_log\r\n</p>\r\n<p>\r\n	[16/May/2016:22:11:38 +0800] 10.4.31.56 201605162211280100040310561523 15231401463407888908 10.*.*.* 127.0.0.1:8500 \"GET /api/media_article_list/?count=10&amp;source_type=0&amp;status=all&amp;from_time=0&amp;item_id=0&amp;flag=2&amp;_=1463407896337 HTTP/1.1\" 504 **.***.com **.**.**.39, **.**.**.60 10.000 10.000 \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36\" ...\r\n</p>\r\n<p>\r\n	error_log\r\n</p>\r\n<p>\r\n	2016/05/16 22:11:38 [error] 90674#0: *947302032 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 10.6.19.81, server: **.***.com, request: \"GET /api/media_article_list/?count=10&amp;source_type=0&amp;status=all&amp;from_time=0&amp;item_id=0&amp;flag=2&amp;_=1463407896337 HTTP/1.1\", upstream: \"http://127.0.0.1:8500/**/**/api/media_article_list/?count=10&amp;source_type=0&amp;status=all&amp;from_time=0&amp;item_id=0&amp;flag=2&amp;_=1463407896337\", host: \"mp.toutiao.com\", referrer: \"https://**.***.com/articles/?source_type=0\"\r\n</p>\r\n<p>\r\n	error_log中upstream timed out (110: Connection timed out) while reading response header from upstream，\r\n</p>\r\n<p>\r\n	意思是说，在规定的时间内，没有从header中拿到数据，即uwsgi没有返回任何数据。\r\n</p>\r\n<p>\r\n	2）502502主要针对B 、C阶段。产生502的时候，对应的error_log中的内容会有好几种：\r\n</p>\r\n<p>\r\n	access_log\r\n</p>\r\n<p>\r\n	[16/May/2016:16:39:49 +0800] 10.4.31.56 201605161639490100040310562612 2612221463387989972 10.6.19.81 127.0.0.1:88 \"GET /articles/?source_type=0 HTTP/1.1\" 503 **.***.com **.**.**.4, **.**.**.160 0.000 0.000 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36\" \"uuid=\\x22w:546d345b86ca443eb44bd9bb1120e821\\x22; tt_webid=15660522398; lasttag=news_culture; sessionid=f172028cc8310ba7f503adb5957eb3ea; sid_tt=f172028cc8310ba7f503adb5957eb3ea; _ga=GA1.2.354066248.1463056713; _gat=1\"\r\n</p>\r\n<p>\r\n	error_log\r\n</p>\r\n<p>\r\n	2016/05/16 16:39:49 [error] 90693#0: *944980723 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.6.19.80, server: **.***.com, request: \"GET /articles/ HTTP/1.1\", upstream: \"http://127.0.0.1:8500/**/**/articles/\", host: \"**.***.com\", referrer: \"http://**.***.com/new_article/\"\r\n</p>\r\n<p>\r\n	列一下常见的几种502对应的 error_log：\r\n</p>\r\n<p>\r\n	recv() failed (104: Connection reset by peer) while reading response header from upstream\r\n</p>\r\n<p>\r\n	upstream prematurely closed connection while reading response header from upstream\r\n</p>\r\n<p>\r\n	connect() failed (111: Connection refused) while connecting to upstream\r\n</p>\r\n<p>\r\n	....\r\n</p>\r\n<p>\r\n	这些都代表，在nginx设置的超时时间内，上游uwsgi没有给正确的响应（但是是有响应的，不然如果一直没响应，就会变成504超时了），因此nginx这边的状态码为502。\r\n</p>\r\n<p>\r\n	如上，access_log中出现503，为什么？\r\n</p>\r\n<p>\r\n	这个是因为nginx upstream的容灾机制。如果nginx有如下配置：\r\n</p>\r\n<p>\r\n	upstream app_backup {\r\n</p>\r\n<p>\r\n	server 127.0.0.1:8500 max_fails=3 fail_timeout=5s;\r\n</p>\r\n<p>\r\n	server 127.0.0.1:88 backup;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	max_fails=3 说明尝试3次后，会认为“ server 127.0.0.1:8500” 失效，于是进入 “server 127.0.0.1:88 backup”，即访问本机的88端口;\r\n</p>\r\n<p>\r\n	nginx upstream的容灾机制，默认情况下，Nginx 默认判断失败节点状态以connect refuse和time out状态为准，不过location里加了这个配置：\r\n</p>\r\n<p>\r\n	proxy_next_upstream error http_502;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 1s;\r\n</p>\r\n<p>\r\n	proxy_send_timeout    6s;\r\n</p>\r\n<p>\r\n	proxy_read_timeout    10s;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	这个配置是说，对于http状态是502的情况，也会走upstream的容灾机制；\r\n</p>\r\n<p>\r\n	概括一下就是，如果连续有3次(max_fails=3)状态为502的请求，则会任务这个后端server 127.0.0.1:8500 挂掉了，在接下来的5s(fail_timeout=5s)内，就会访问backup，即server 127.0.0.1:88 ，看下88端口对应的是什么：\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 88;\r\n</p>\r\n<p>\r\n	access_log /var/log/nginx/failover.log;\r\n</p>\r\n<p>\r\n	expires 1m;\r\n</p>\r\n<p>\r\n	error_page  500 502 503 504 /500.html;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	return 503;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location = /500.html {\r\n</p>\r\n<p>\r\n	root /**/**/**/nginx/5xx/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这个的意思就是，对于访问88端口的请求，nginx会返回503状态码，同时返回/opt/tiger/ss_conf/nginx/5xx/这个路径下的500.html文件。因此，access_log中看到的是503\r\n</p>\r\n<p>\r\n	3）499client发送请求后，如果在规定的时间内（假设超时时间为500ms）没有拿到nginx给的响应，则认为这次请求超时，会主动结束，这个时候nginx的access_log就会打印499状态码。A+B+C+D &gt; 500ms其实这个时候，server端有可能还在处理请求，只不过client断掉了连接，因此处理结果也无法返回给客户端。499如果比较多的话，可能会引起服务雪崩。比如说，client一直在发起请求，客户端因为某些原因处理慢了，没有在规定时间内返回数据，client认为请求失败，中断这次请求，然后再重新发起请求。这样不断的重复，服务端的请求越来越多，机器负载变大，请求处理越来越慢，没有办法响应任何请求\r\n</p>\r\n<p>\r\n	官网总结nginx返回499的情况，是由于：\r\n</p>\r\n<p>\r\n	client has closed connection    #客户端主动关闭了连接。\r\n</p>\r\n<p>\r\n	client has closed connection &nbsp; &nbsp;#客户端主动关闭了连接。\r\n</p>\r\n<p>\r\n	client has closed connection    #客户端主动关闭了连接。\r\n</p>\r\n<p>\r\n	解决的话，可以添加\r\n</p>\r\n<p>\r\n	proxy_ignore_client_abort    on;\r\n</p>\r\n<p>\r\n	还有一种原因，确实是客户端关闭了连接，或者连接超时。主要是因为PHP进程数太少，或php进程占用，资源不能很快释放，请求堆积。这种情况要解决的话，需要在程序上做优化。\r\n</p>\r\n<p>\r\n	4）500 服务器内部错误，也就是服务器遇到意外情况，而无法执行请求。发生错误，一般的几种情况：\r\n</p>\r\n<p>\r\n	web脚本错误，如php语法错误，lua语法错误等。\r\n</p>\r\n<p>\r\n	访问量大的时候，由于系统资源限制，而不能打开过多的文件句柄\r\n</p>\r\n<p>\r\n	分析错误的原因\r\n</p>\r\n<p>\r\n	查看nginx，php的错误日志\r\n</p>\r\n<p>\r\n	如果是too many open files，修改nginx的worker_rlimit_nofile参数，使用ulimit查看系统打开文件限制，修改/etc/security/limits.conf\r\n</p>\r\n<p>\r\n	如果脚本存在问题，则需要修复脚本错误，并优化代码\r\n</p>\r\n<p>\r\n	各种优化都做好，还是出现too many open files，那就需要考虑做负载均衡，把流量分散到不同服务器上去\r\n</p>\r\n<p>\r\n	5）503503是服务不可用的返回状态。由于在nginx配置中，设置了limit_req的流量限制，导致许多请求返回503错误代码，在限流的条件下，为提高用户体验，希望返回正常Code 200，且返回操作频繁的信息：\r\n</p>\r\n<p>\r\n	location  /test {\r\n</p>\r\n<p>\r\n	...\r\n</p>\r\n<p>\r\n	limit_req zone=zone_ip_rm burst=1 nodelay;\r\n</p>\r\n<p>\r\n	error_page 503 =200 /dealwith_503?callback=$arg_callback;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /dealwith_503{\r\n</p>\r\n<p>\r\n	set $ret_body \'{\"code\": \"V00006\",\"msg\": \"操作太频繁了，请坐下来喝杯茶。\"}\';\r\n</p>\r\n<p>\r\n	if ( $arg_callback != \"\" )\r\n</p>\r\n<p>\r\n	{\r\n</p>\r\n<p>\r\n	return 200 \'try{$arg_callback($ret_body)}catch(e){}\';\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	return 200 $ret_body;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	................................................Nginx Code Status...............................\r\n</p>\r\n<p>\r\n	200：服务器成功返回网页\r\n</p>\r\n<p>\r\n	403：服务器拒绝请求。\r\n</p>\r\n<p>\r\n	404：请求的网页不存在\r\n</p>\r\n<p>\r\n	499：客户端主动断开了连接。\r\n</p>\r\n<p>\r\n	500：服务器遇到错误，无法完成请求。\r\n</p>\r\n<p>\r\n	502：服务器作为网关或代理，从上游服务器收到无效响应。\r\n</p>\r\n<p>\r\n	503 - 服务不可用\r\n</p>\r\n<p>\r\n	504：服务器作为网关或代理，但是没有及时从上游服务器收到请求。\r\n</p>\r\n<p>\r\n	这些状态码被分为五大类：\r\n</p>\r\n<p>\r\n	100-199 用于指定客户端应相应的某些动作。\r\n</p>\r\n<p>\r\n	200-299 用于表示请求成功。\r\n</p>\r\n<p>\r\n	300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。\r\n</p>\r\n<p>\r\n	400-499 用于指出客户端的错误。 （自己电脑这边的问题） 自己电脑这边的问题）\r\n</p>\r\n<p>\r\n	500-599 用于支持服务器错误。 （对方的问题） 对方的问题）\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\r\n</p>\r\n<p>\r\n	201 （已创建） 请求成功并且服务器创建了新的资源。\r\n</p>\r\n<p>\r\n	202 （已接受） 服务器已接受请求，但尚未处理。\r\n</p>\r\n<p>\r\n	203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。\r\n</p>\r\n<p>\r\n	204 （无内容） 服务器成功处理了请求，但没有返回任何内容。\r\n</p>\r\n<p>\r\n	205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。\r\n</p>\r\n<p>\r\n	206 （部分内容） 服务器成功处理了部分 GET 请求。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\r\n</p>\r\n<p>\r\n	301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\r\n</p>\r\n<p>\r\n	302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\r\n</p>\r\n<p>\r\n	303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\r\n</p>\r\n<p>\r\n	304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\r\n</p>\r\n<p>\r\n	305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\r\n</p>\r\n<p>\r\n	307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	400 （错误请求） 服务器不理解请求的语法。\r\n</p>\r\n<p>\r\n	401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\r\n</p>\r\n<p>\r\n	403 （禁止） 服务器拒绝请求。\r\n</p>\r\n<p>\r\n	404 （未找到） 服务器找不到请求的网页。\r\n</p>\r\n<p>\r\n	405 （方法禁用） 禁用请求中指定的方法。\r\n</p>\r\n<p>\r\n	406 （不接受） 无法使用请求的内容特性响应请求的网页。\r\n</p>\r\n<p>\r\n	407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\r\n</p>\r\n<p>\r\n	408 （请求超时） 服务器等候请求时发生超时。\r\n</p>\r\n<p>\r\n	409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。\r\n</p>\r\n<p>\r\n	410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。\r\n</p>\r\n<p>\r\n	411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。\r\n</p>\r\n<p>\r\n	412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。\r\n</p>\r\n<p>\r\n	413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\r\n</p>\r\n<p>\r\n	414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。\r\n</p>\r\n<p>\r\n	415 （不支持的媒体类型） 请求的格式不受请求页面的支持。\r\n</p>\r\n<p>\r\n	416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。\r\n</p>\r\n<p>\r\n	417 （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。\r\n</p>\r\n<p>\r\n	---------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	500 （服务器内部错误） 服务器遇到错误，无法完成请求。\r\n</p>\r\n<p>\r\n	501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\r\n</p>\r\n<p>\r\n	502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\r\n</p>\r\n<p>\r\n	503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。\r\n</p>\r\n<p>\r\n	504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。\r\n</p>\r\n<p>\r\n	505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\r\n</p>\r\n<p>\r\n	proxy_intercept_errors 当上游服务器响应头回来后，可以根据响应状态码的值进行拦截错误处理，与error_page 指令相互结合。用在访问上游服务器出现错误的情况下。\r\n</p>\r\n<p>\r\n	如下的一个配置实例：\r\n</p>\r\n<p>\r\n	[root@dev ~]# cat ssl-zp.wangshibo.conf\r\n</p>\r\n<p>\r\n	upstream mianshi1 {\r\n</p>\r\n<p>\r\n	server 192.168.1.33:8080 max_fails=3 fail_timeout=10s;\r\n</p>\r\n<p>\r\n	#server 192.168.1.32:8080 max_fails=3 fail_timeout=10s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 443;\r\n</p>\r\n<p>\r\n	server_name zp.wangshibo.com;\r\n</p>\r\n<p>\r\n	ssl on;\r\n</p>\r\n<p>\r\n	### SSL log files ###\r\n</p>\r\n<p>\r\n	access_log logs/zrx_access.log;\r\n</p>\r\n<p>\r\n	error_log logs/zrx_error.log;\r\n</p>\r\n<p>\r\n	### SSL cert files ###\r\n</p>\r\n<p>\r\n	ssl_certificate ssl/wangshibo.cer;\r\n</p>\r\n<p>\r\n	ssl_certificate_key ssl/wangshibo.key;\r\n</p>\r\n<p>\r\n	ssl_session_timeout 5m;\r\n</p>\r\n<p>\r\n	error_page 404 301 https://zp.wangshibo.com/zrx-web/;\r\n</p>\r\n<p>\r\n	location /zrx-web/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://mianshi1;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	#proxy_set_header X-Forwarded-Proto https;\r\n</p>\r\n<p>\r\n	proxy_redirect off;\r\n</p>\r\n<p>\r\n	proxy_intercept_errors on;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('ce6ac140-9766-47b8-aecc-0fe38c5694e6','mysql操作命令梳理（4）-grant授权和revoke回收权限','mysql操作命令梳理（4）-grant授权和revoke回收权限','<p>\r\n	在mysql维护工作中，做好权限管理是一个很重要的环节。下面对mysql权限操作进行梳理：\r\n</p>\r\n<p>\r\n	mysql的权限命令是grant，权限撤销的命令时revoke；grant授权格式：grant 权限列表 on 库.表 to 用户名@\'ip\' identified by \"密码\";revoke回收权限格式：revoke 权限列表 on 库.表 from 用户名@\'ip\';\r\n</p>\r\n<p>\r\n	下面通过一些例子说明:1.grant授权1）grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。\r\n</p>\r\n<p>\r\n	mysql&gt; grant all on *.* to wang@\'192.168.1.150\' identified by \"password\";           //all等同于all privilege，其中的privileges可以省略\r\n</p>\r\n<p>\r\n	mysql&gt; grant all privileges on *.* to wang@\'192.168.1.%\' identified by \"123456\";    //192.168.1.%表示一个网段\r\n</p>\r\n<p>\r\n	mysql&gt; grant insert,select,update,delete,drop,create,alter on huanqiu.* to wang@\'%\' identified by \"123456\";\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges      //授权之后，不要忘记更新权限表\r\n</p>\r\n<p>\r\n	2.查看权限1）查看当前用户下所有的权限\r\n</p>\r\n<p>\r\n	mysql&gt; show grants;\r\n</p>\r\n<p>\r\n	+----------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for root@localhost                                                                                                              |\r\n</p>\r\n<p>\r\n	+----------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'localhost\' IDENTIFIED BY PASSWORD \'*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9\' WITH GRANT OPTION |\r\n</p>\r\n<p>\r\n	| GRANT PROXY ON \'\'@\'\' TO \'root\'@\'localhost\' WITH GRANT OPTION                                                                           |\r\n</p>\r\n<p>\r\n	+----------------------------------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）查看指定用户下的所有权限USAGE是默认的初始状态，表示无任何权限！！下面表示wang用户在192.168.1.0/24网段登陆本机mysql后，对huanqiu库下的所有表有insert,update,alter,delete,create,select的操作权限！\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for wang@\'192.168.1.%\';           //可以在select user,host,password from mysql.user执行结果中找对应的权限用户信息\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for wang@192.168.1.%                                                                                   |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'wang\'@\'192.168.1.%\' IDENTIFIED BY PASSWORD \'*678E2A46B8C71291A3915F92736C080819AD76DF\' |\r\n</p>\r\n<p>\r\n	| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER ON `huanqiu`.* TO \'wang\'@\'192.168.1.%\'                    |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	3.revoke撤销权限revoke跟grant语法差不多，只需要把关键字 “to” 换成 “from” 即可，并且revoke语句中不需要跟密码设置。注意：revoke可以回收所有权限，也可以回收部分权限。\r\n</p>\r\n<p>\r\n	mysql&gt; revoke all on *.* from wang@\'192.168.1.150\';\r\n</p>\r\n<p>\r\n	mysql&gt; revoke all privileges on *.* from wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	mysql&gt; revoke insert,select,update,delete,drop，create，alter on huanqiu.* from wang@\'%\';\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges\r\n</p>\r\n<p>\r\n	注意事项：1）grant, revoke用户权限后，该用户只有重新连接MySQL数据库，权限才能生效。2）如果想让授权的用户，也可以将这些权限grant给其他用户，那么授权时需添加选项 \"grant option\"！如下设置后，那么这个wang用户连接mysql后也可以将这些权限授予其他用户。\r\n</p>\r\n<p>\r\n	mysql&gt; grant insert,select,update,alter on huanqiu.* to wang@\'%\' identified by \"123456\" with grant option;\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------------------------------------------------mysql授权表一共涉及到5个表，分别是user、db、host、tables_priv和columns_priv。这5张表的内容和用途如下：1）user表user表列出可以连接服务器的用户及其口令，并且它指定他们有哪种全局（超级用户）权限。在user表启用的任何权限均是全局权限，并适用于所有数据库。例如，如果你启用了DELETE权限，在这里列出的用户可以从任何表中删除记录，所以在你这样做之前要认真考虑。\r\n</p>\r\n<p>\r\n	2）db表db表列出数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的所有表。\r\n</p>\r\n<p>\r\n	3）host表host表与db表结合使用在一个较好层次上控制特定主机对数据库的访问权限，这可能比单独使用db好些。这个表不受GRANT和REVOKE语句的影响，所以，你可能发觉你根本不是用它。\r\n</p>\r\n<p>\r\n	4）tables_priv表tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的所有列。\r\n</p>\r\n<p>\r\n	5）columns_priv表columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。------------------------------------------------------------------------------------------------------------------看下面一个实例：给wang用户授权的权限太大了，现在要收回部分权限，只留给wang用户select和alter的权限。\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for wang@192.168.1.%                                                                                   |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'wang\'@\'192.168.1.%\' IDENTIFIED BY PASSWORD \'*678E2A46B8C71291A3915F92736C080819AD76DF\' |\r\n</p>\r\n<p>\r\n	| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER ON `huanqiu`.* TO \'wang\'@\'192.168.1.%\'                    |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; revoke insert,update,delete,create on huanqiu.* from wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for wang@192.168.1.%                                                                                   |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'wang\'@\'192.168.1.%\' IDENTIFIED BY PASSWORD \'*678E2A46B8C71291A3915F92736C080819AD76DF\' |\r\n</p>\r\n<p>\r\n	| GRANT SELECT, ALTER ON `huanqiu`.* TO \'wang\'@\'192.168.1.%\'                                                    |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	发现revoke回收权限操作后，只剩下select和alter权限了。revoke回收部分权限，剩下的权限的密码保持不变。\r\n</p>\r\n<p>\r\n	这里特别注意下：如果给一个用户设置的权限过大，除了上面使用revoke回收部分权限外，还可以使用grant进行权限修改！也就是说，grant不仅可以添加权限，也可以修改权限（实际上就是对同一\'用户名\'@\'ip\'设置权限，以覆盖之前的权限）；grant修改后的权限将覆盖之前的权限！那么问题来了：授权后的密码是密文形式保存的，如果记不住之前授权时的密码，那么怎样保证覆盖后的权限跟之前的权限一致？\r\n</p>\r\n<p>\r\n	莫慌！grant授权操作中其实不仅可以设置明文密码，也可以设置密文密码，如下：1）grant 权限列表 on 库.表.* to 用户名@\'ip\' identified by \"明文密码\"2）grant 权限列表 on 库.表.* to 用户名@\'ip\' identified by password \"密文密码\"\r\n</p>\r\n<p>\r\n	也就是说：在grant重置权限的时候可以用查看的密文密码当做新的密码，然后去覆盖之前的权限，这就保证了修改前后的密码一致！如上的例子，采用grant的操作如下：\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for wang@192.168.1.%                                                                                   |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'wang\'@\'192.168.1.%\' IDENTIFIED BY PASSWORD \'*678E2A46B8C71291A3915F92736C080819AD76DF\' |\r\n</p>\r\n<p>\r\n	| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER ON `huanqiu`.* TO \'wang\'@\'192.168.1.%\'                    |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; grant alter,select on huanqiu.* to wang@\'192.168.1.%\' identified by password \'*678E2A46B8C71291A3915F92736C080819AD76DF\';\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; show grants for wang@\'192.168.1.%\';\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| Grants for wang@192.168.1.%                                                                                   |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	| GRANT USAGE ON *.* TO \'wang\'@\'192.168.1.%\' IDENTIFIED BY PASSWORD \'*678E2A46B8C71291A3915F92736C080819AD76DF\' |\r\n</p>\r\n<p>\r\n	| GRANT SELECT, ALTER ON `huanqiu`.* TO \'wang\'@\'192.168.1.%\'                                                    |\r\n</p>\r\n<p>\r\n	+---------------------------------------------------------------------------------------------------------------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	通常开发同事在让运维同事开通mysql权限时，他们会在自己本地mysql里生成一个密文密码，然后把这个密文密码给运维同事，运维同事在用这个密文密码进行授权，那么授权的密码就只有开发同事自己知道了，其他人都不知道！比较安全的一种做法~\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('d215d9a3-40a1-4bc6-81a5-4fa6616a83cc','Nginx+keepalived双机热备（主从模式）','Nginx+keepalived双机热备（主从模式）','<p>\r\n	负载均衡技术对于一个网站尤其是大型网站的web服务器集群来说是至关重要的！做好负载均衡架构，可以实现故障转移和高可用环境，避免单点故障，保证网站健康持续运行。关于负载均衡介绍，可以参考：linux负载均衡总结性说明（四层负载/七层负载）\r\n</p>\r\n<p>\r\n	由于业务扩展，网站的访问量不断加大，负载越来越高。现需要在web前端放置nginx负载均衡,同时结合keepalived对前端nginx实现HA高可用。1）nginx进程基于Master+Slave(worker)多进程模型，自身具有非常稳定的子进程管理功能。在Master进程分配模式下，Master进程永远不进行业务处理，只是进行任务分发，从而达到Master进程的存活高可靠性，Slave(worker)进程所有的业务信号都 由主进程发出，Slave(worker)进程所有的超时任务都会被Master中止，属于非阻塞式任务模型。2）Keepalived是Linux下面实现VRRP备份路由的高可靠性运行件。基于Keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时IP瞬间无缝交接。二者结合，可以构架出比较稳定的软件LB方案。\r\n</p>\r\n<p>\r\n	Keepalived介绍：Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。\r\n</p>\r\n<p>\r\n	VRRP协议：VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议。可以认为它是实现路由器高可用的容错协议，即将N台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。\r\n</p>\r\n<p>\r\n	在VRRP协议实现里，虚拟路由器使用 00-00-5E-00-01-XX 作为虚拟MAC地址，XX就是唯一的 VRID （Virtual Router IDentifier），这个地址同一时间只有一个物理路由器占用。在虚拟路由器里面的物理路由器组里面通过多播IP地址 224.0.0.18 来定时发送通告消息。每个Router都有一个 1-255 之间的优先级别，级别最高的（highest priority）将成为主控（master）路由器。通过降低master的优先权可以让处于backup状态的路由器抢占（pro-empt）主路由器的状态，两个backup优先级相同的IP地址较大者为master，接管虚拟IP。\r\n</p>\r\n<p>\r\n	keepalived与heartbeat/corosync等比较：Heartbeat、Corosync、Keepalived这三个集群组件我们到底选哪个好呢？首先要说明的是，Heartbeat、Corosync是属于同一类型，Keepalived与Heartbeat、Corosync，根本不是同一类型的。Keepalived使用的vrrp协议方式，虚拟路由冗余协议 (Virtual Router Redundancy Protocol，简称VRRP)；Heartbeat或Corosync是基于主机或网络服务的高可用方式；简单的说就是，Keepalived的目的是模拟路由器的高可用，Heartbeat或Corosync的目的是实现Service的高可用。所以一般Keepalived是实现前端高可用，常用的前端高可用的组合有，就是我们常见的LVS+Keepalived、Nginx+Keepalived、HAproxy+Keepalived。而Heartbeat或Corosync是实现服务的高可用，常见的组合有Heartbeat v3(Corosync)+Pacemaker+NFS+Httpd 实现Web服务器的高可用、Heartbeat v3(Corosync)+Pacemaker+NFS+MySQL 实现MySQL服务器的高可用。总结一下，Keepalived中实现轻量级的高可用，一般用于前端高可用，且不需要共享存储，一般常用于两个节点的高可用。而Heartbeat(或Corosync)一般用于服务的高可用，且需要共享存储，一般用于多节点的高可用。这个问题我们说明白了。\r\n</p>\r\n<p>\r\n	那heartbaet与corosync又应该选择哪个好？一般用corosync，因为corosync的运行机制更优于heartbeat，就连从heartbeat分离出来的pacemaker都说在以后的开发当中更倾向于corosync，所以现在corosync+pacemaker是最佳组合。\r\n</p>\r\n<p>\r\n	双机高可用一般是通过虚拟IP（飘移IP）方法来实现的，基于Linux/Unix的IP别名技术。双机高可用方法目前分为两种：1）双机主从模式：即前端使用两台服务器，一台主服务器和一台热备服务器，正常情况下，主服务器绑定一个公网虚拟IP，提供负载均衡服务，热备服务器处于空闲状态；当主服务器发生故障时，热备服务器接管主服务器的公网虚拟IP，提供负载均衡服务；但是热备服务器在主机器不出现故障的时候，永远处于浪费状态，对于服务器不多的网站，该方案不经济实惠。2）双机主主模式：即前端使用两台负载均衡服务器，互为主备，且都处于活动状态，同时各自绑定一个公网虚拟IP，提供负载均衡服务；当其中一台发生故障时，另一台接管发生故障服务器的公网虚拟IP（这时由非故障机器一台负担所有的请求）。这种方案，经济实惠，非常适合于当前架构环境。\r\n</p>\r\n<p>\r\n	今天在此分享下Nginx+keepalived实现高可用负载均衡的主从模式的操作记录：\r\n</p>\r\n<p>\r\n	keepalived可以认为是VRRP协议在Linux上的实现，主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的。\r\n</p>\r\n<p>\r\n	一、环境说明：操作系统：centos6.8，64位master机器（master-node）：103.110.98.14/192.168.1.14slave机器（slave-node）：103.110.98.24/192.168.1.24公用的虚拟IP（VIP）：103.110.98.20 &nbsp; &nbsp; &nbsp;//负载均衡器上配置的域名都解析到这个VIP上\r\n</p>\r\n<p>\r\n	应用环境如下：\r\n</p>\r\n<p>\r\n	二、环境安装安装nginx和keepalive服务（master-node和slave-node两台服务器上的安装操作完全一样）。安装依赖[root@master-node ~]# yum -y install gcc pcre-devel zlib-devel openssl-devel下载（百度云盘下载地址：https://pan.baidu.com/s/1ckTOKI &nbsp; &nbsp;&nbsp;提取秘钥：gi8i）[root@master-node ~]# cd /usr/local/src/[root@master-node src]#&nbsp;wget http://nginx.org/download/nginx-1.9.7.tar.gz[root@master-node src]# wget http://www.keepalived.org/software/keepalived-1.3.2.tar.gz安装nginx[root@master-node src]# tar -zvxf nginx-1.9.7.tar.gz [root@master-node src]# cd nginx-1.9.7添加www用户，其中-M参数表示不添加用户家目录，-s参数表示指定shell类型[root@master-node nginx-1.9.7]# useradd www -M -s /sbin/nologin [root@master-node nginx-1.9.7]# vim auto/cc/gcc          #将这句注释掉 取消Debug编译模式 大概在179行#CFLAGS=\"$CFLAGS -g\"[root@master-node nginx-1.9.7]#&nbsp;./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-http_flv_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre[root@master-node nginx-1.9.7]# make &amp;&amp; make install安装keepalived[root@master-node src]# tar -zvxf keepalived-1.3.2.tar.gz [root@master-node src]# cd keepalived-1.3.2[root@master-node keepalived-1.3.2]# ./configure [root@master-node keepalived-1.3.2]# make &amp;&amp; make install[root@master-node keepalived-1.3.2]# cp /usr/local/src/keepalived-1.3.2/keepalived/etc/init.d/keepalived /etc/rc.d/init.d/[root@master-node keepalived-1.3.2]# cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/[root@master-node keepalived-1.3.2]# mkdir /etc/keepalived[root@master-node keepalived-1.3.2]# cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/[root@master-node keepalived-1.3.2]# cp /usr/local/sbin/keepalived /usr/sbin/将nginx和keepalive服务加入开机启动服务[root@master-node keepalived-1.3.2]# echo \"/usr/local/nginx/sbin/nginx\" &gt;&gt; /etc/rc.local[root@master-node keepalived-1.3.2]# echo \"/etc/init.d/keepalived start\" &gt;&gt; /etc/rc.local\r\n</p>\r\n<p>\r\n	绑定虚拟IP（VIP），这个只在master负载均衡机绑定即可，后续出现故障时，slave负载均衡机会接管VIP首先查看下master负载均衡机的公网ip的信息：网卡、broadcast、netmask等[root@master-node ~]# ifconfigem1: flags=4163<up,broadcast,running,multicast>  mtu 1500        inet 103.110.98.14  netmask 255.255.255.192  broadcast 103.110.98.63        inet6 fe80::46a8:42ff:fe17:3ddd  prefixlen 64  scopeid 0x20ether 44:a8:42:17:3d:dd  txqueuelen 1000  (Ethernet)        RX packets 133787818  bytes 14858530059 (13.8 GiB)        RX errors 0  dropped 644  overruns 0  frame 0        TX packets 2291619  bytes 426619870 (406.8 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 16  .......</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	接着开始绑定VIP（这一步其实可以不用这么直接在外部使用ifconfig绑定。Nginx或Haproxy+Keepalived的七层负载均衡的高可用环境中，VIP就直接在 Keepalived 的配置文件里配置就好，使用命令 ip addr 就能看出 vip；而LVS+Keepalived 四层负载均衡的高可用环境中， vip是要在外面单独设置的（即ifconfig eth0:0 ....的方式创建vip），通过 ifconfig 可以查看出来 vip。）\r\n</p>\r\n<p>\r\n	[root@master-node ~]# ifconfig em1:0 103.110.98.20 broadcast 103.110.98.63 netmask 255.255.255.192 up [root@master-node ~]# route add -host 103.110.98.20 dev em1:0\r\n</p>\r\n<p>\r\n	查看VIP是否成功绑定了：[root@master-node ~]# ifconfigem1: flags=4163<up,broadcast,running,multicast>  mtu 1500        inet 103.110.98.14  netmask 255.255.255.192  broadcast 103.110.98.63        inet6 fe80::46a8:42ff:fe17:3ddd  prefixlen 64  scopeid 0x20ether 44:a8:42:17:3d:dd  txqueuelen 1000  (Ethernet)        RX packets 133789569  bytes 14858744709 (13.8 GiB)        RX errors 0  dropped 644  overruns 0  frame 0        TX packets 2291620  bytes 426619960 (406.8 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 16</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	em1:0: flags=4163<up,broadcast,running,multicast>  mtu 1500        inet 103.110.98.20  netmask 255.255.255.192  broadcast 103.110.98.63        ether 44:a8:42:17:3d:dd  txqueuelen 1000  (Ethernet)        device interrupt 16  .......</up,broadcast,running,multicast>\r\n</p>\r\n<p>\r\n	[root@master-node ~]# ping 103.110.98.20PING 103.110.98.20 (103.110.98.20) 56(84) bytes of data.64 bytes from 103.110.98.20: icmp_seq=1 ttl=64 time=0.044 ms64 bytes from 103.110.98.20: icmp_seq=2 ttl=64 time=0.036 ms\r\n</p>\r\n<p>\r\n	[root@master-node ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         103.10.86.1     0.0.0.0         UG    100    0        0 em1103.10.86.0     0.0.0.0         255.255.255.192 U     100    0        0 em1103.110.98.20    0.0.0.0         255.255.255.255 UH    0      0        0 em1192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 em2\r\n</p>\r\n<p>\r\n	三、配置服务\r\n</p>\r\n<p>\r\n	先关闭SElinux、配置防火墙 （master和slave两台负载均衡机都要做）[root@master-node ~]# vim /etc/sysconfig/selinux#SELINUX=enforcing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#注释掉#SELINUXTYPE=targeted &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#注释掉SELINUX=disabled &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #增加[root@master-node ~]# setenforce 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#使配置立即生效\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /etc/sysconfig/iptables.......-A INPUT -s 103.110.98.0/24 -d 224.0.0.18 -j ACCEPT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#允许组播地址通信-A INPUT -s 192.168.1.0/24 -d 224.0.0.18 -j ACCEPT-A INPUT -s 103.110.98.0/24 -p vrrp -j ACCEPT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#允许 VRRP（虚拟路由器冗余协）通信-A INPUT -s 192.168.1.0/24 -p vrrp -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT &nbsp; &nbsp; &nbsp;#开通80端口访问\r\n</p>\r\n<p>\r\n	[root@master-node ~]# /etc/init.d/iptables restart&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#重启防火墙使配置生效\r\n</p>\r\n<p>\r\n	1.配置nginxmaster-node和slave-node两台服务器的nginx的配置完全一样,主要是配置/usr/local/nginx/conf/nginx.conf的http，当然也可以配置vhost虚拟主机目录，然后配置vhost下的比如LB.conf文件。其中:多域名指向是通过虚拟主机（配置http下面的server）实现;同一域名的不同虚拟目录通过每个server下面的不同location实现;到后端的服务器在vhost/LB.conf下面配置upstream,然后在server或location中通过proxy_pass引用。要实现前面规划的接入方式，LB.conf的配置如下（添加proxy_cache_path和proxy_temp_path这两行，表示打开nginx的缓存功能）：\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /usr/local/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	user  www;\r\n</p>\r\n<p>\r\n	worker_processes  8;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  notice;\r\n</p>\r\n<p>\r\n	#error_log  logs/error.log  info;\r\n</p>\r\n<p>\r\n	#pid        logs/nginx.pid;\r\n</p>\r\n<p>\r\n	events {\r\n</p>\r\n<p>\r\n	worker_connections  65535;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	######\r\n</p>\r\n<p>\r\n	## set access log format\r\n</p>\r\n<p>\r\n	######\r\n</p>\r\n<p>\r\n	log_format  main  \'$http_x_forwarded_for $remote_addr $remote_user [$time_local] \"$request\" \'\r\n</p>\r\n<p>\r\n	\'$status $body_bytes_sent \"$http_referer\" \'\r\n</p>\r\n<p>\r\n	\'\"$http_user_agent\" \"$http_cookie\" $host $request_time\';\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	## http setting\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  65;\r\n</p>\r\n<p>\r\n	proxy_cache_path /var/www/cache levels=1:2 keys_zone=mycache:20m max_size=2048m inactive=60m;\r\n</p>\r\n<p>\r\n	proxy_temp_path /var/www/cache/tmp;\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 3000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_intercept_errors on;\r\n</p>\r\n<p>\r\n	#\r\n</p>\r\n<p>\r\n	client_header_timeout 600s;\r\n</p>\r\n<p>\r\n	client_body_timeout 600s;\r\n</p>\r\n<p>\r\n	# client_max_body_size 50m;\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;               #允许客户端请求的最大单个文件字节数\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;            #缓冲区代理缓冲请求的最大字节数，可以理解为先保存到本地再传给用户\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	## includes vhosts\r\n</p>\r\n<p>\r\n	include vhosts/*.conf;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@master-node ~]# mkdir /usr/local/nginx/conf/vhosts[root@master-node ~]# mkdir /var/www/cache[root@master-node ~]# ulimit 65535\r\n</p>\r\n<p>\r\n	[root@master-node ~]# vim /usr/local/nginx/conf/vhosts/LB.conf\r\n</p>\r\n<p>\r\n	upstream LB-WWW {\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	server 192.168.1.101:80 max_fails=3 fail_timeout=30s;     #max_fails = 3 为允许失败的次数，默认值为1\r\n</p>\r\n<p>\r\n	server 192.168.1.102:80 max_fails=3 fail_timeout=30s;     #fail_timeout = 30s 当max_fails次失败后，暂停将请求分发到该后端服务器的时间\r\n</p>\r\n<p>\r\n	server 192.168.1.118:80 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	upstream LB-OA {\r\n</p>\r\n<p>\r\n	ip_hash;\r\n</p>\r\n<p>\r\n	server 192.168.1.101:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	server 192.168.1.102:8080 max_fails=3 fail_timeout=30s;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen      80;\r\n</p>\r\n<p>\r\n	server_name dev.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/dev-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/dev-error.log;\r\n</p>\r\n<p>\r\n	location /svn {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.108/svn/;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;             #跟后端服务器连接超时时间，发起握手等候响应时间\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;                #后端服务器回传时间，就是在规定时间内后端服务器必须传完所有数据\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;                #连接成功后等待后端服务器的响应时间，已经进入后端的排队之中等候处理\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;                #代理请求缓冲区,会保存用户的头信息以供nginx进行处理\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;                  #同上，告诉nginx保存单个用几个buffer最大用多少空间\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;          #如果系统很忙时候可以申请最大的proxy_buffers\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;       #proxy缓存临时文件的大小\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location /submin {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.108/submin/;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  www.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/www-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/www-error.log;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-WWW;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  oa.wangshibo.com;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/oa-access.log main;\r\n</p>\r\n<p>\r\n	error_log  /usr/local/nginx/logs/oa-error.log;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	proxy_pass http://LB-OA;\r\n</p>\r\n<p>\r\n	proxy_redirect off ;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_send_timeout 300;\r\n</p>\r\n<p>\r\n	proxy_read_timeout 600;\r\n</p>\r\n<p>\r\n	proxy_buffer_size 256k;\r\n</p>\r\n<p>\r\n	proxy_buffers 4 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;\r\n</p>\r\n<p>\r\n	proxy_max_temp_file_size 128m;\r\n</p>\r\n<p>\r\n	proxy_cache mycache;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 200 302 60m;\r\n</p>\r\n<p>\r\n	proxy_cache_valid 404 1m;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	验证方法（保证从负载均衡器本机到后端真实服务器之间能正常通信）：1）首先在本机用IP访问上面LB.cong中配置的各个后端真实服务器的url2）然后在本机用域名和路径访问上面LB.cong中配置的各个后端真实服务器的域名/虚拟路径\r\n</p>\r\n<p>\r\n	----------------------------------------------------------------------------------------------------------------------------后端应用服务器的nginx配置，这里选择192.168.1.108作为例子进行说明由于这里的192.168.1.108机器是openstack的虚拟机，没有外网ip，不能解析域名。所以在server_name处也将ip加上，使得用ip也可以访问。[root@108-server ~]# cat /usr/local/nginx/conf/vhosts/svn.conf server {    listen 80;    #server_name dev.wangshibo.com;    server_name dev.wangshibo.com 192.168.1.108;\r\n</p>\r\n<p>\r\n	access_log  /usr/local/nginx/logs/dev.wangshibo-access.log main;    error_log  /usr/local/nginx/logs/dev.wangshibo-error.log;\r\n</p>\r\n<p>\r\n	location  / {    root /var/www/html;    index index.html index.php index.htm;    }}\r\n</p>\r\n<p>\r\n	[root@108-server ~]# ll /var/www/html/drwxr-xr-x. 2 www www 4096 Dec  7 01:46 submindrwxr-xr-x. 2 www www 4096 Dec  7 01:45 svn[root@108-server ~]# cat /var/www/html/svn/index.htmlthis is the page of svn/192.168.1.108[root@108-server ~]# cat /var/www/html/submin/index.htmlthis is the page of submin/192.168.1.108\r\n</p>\r\n<p>\r\n	[root@108-server ~]# cat /etc/hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.1.108   dev.wangshibo.com\r\n</p>\r\n<p>\r\n	[root@108-server ~]# curl http://dev.wangshibo.com &nbsp; &nbsp; &nbsp; //由于是内网机器不能联网，亦不能解析域名。所以用域名访问没有反应。只能用ip访问[root@ops-server4 vhosts]# curl http://192.168.1.108this is 192.168.1.108 page!!![root@ops-server4 vhosts]# curl http://192.168.1.108/svn/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //最后一个/符号要加上，否则访问不了。this is the page of svn/192.168.1.108[root@ops-server4 vhosts]# curl http://192.168.1.108/submin/this is the page of submin/192.168.1.108----------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	然后在master-node和slave-node两台负载机器上进行测试（iptables防火墙要开通80端口）：[root@master-node ~]# curl http://192.168.1.108/svn/this is the page of svn/192.168.1.108[root@master-node ~]# curl http://192.168.1.108/submin/this is the page of submin/192.168.1.108\r\n</p>\r\n<p>\r\n	浏览器访问：在本机host绑定dev.wangshibo.com，如下，即绑定到master和slave机器的公网ip上测试是否能正常访问（nginx+keepalive环境正式完成后，域名解析到的真正地址是VIP地址）103.110.98.14 dev.wangshibo.com103.110.98.24 dev.wangshibo.com\r\n</p>\r\n<p>\r\n	2.keepalived配置1）master-node负载机上的keepalived配置（sendmail部署可以参考：linux下sendmail邮件系统安装操作记录）[root@master-node ~]# cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak[root@master-node ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived     #全局定义\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {     #指定keepalived在发生事件时(比如切换)发送通知邮件的邮箱\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn   #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn   #keepalived在发生诸如切换操作时需要发送email通知地址\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1      #指定发送email的smtp服务器\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30    #设置连接smtp server的超时时间\r\n</p>\r\n<p>\r\n	router_id master-node     #运行keepalived的机器的一个标识，通常可设为hostname。故障发生时，发邮件时显示在邮件主题中的信息。\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_http_port {      #检测nginx服务是否在运行。有很多方式，比如进程，用脚本检测等等\r\n</p>\r\n<p>\r\n	script \"/opt/chk_nginx.sh\"   #这里通过脚本监测\r\n</p>\r\n<p>\r\n	interval 2                   #脚本执行间隔，每2s检测一次\r\n</p>\r\n<p>\r\n	weight -5                    #脚本结果导致的优先级变更，检测失败（脚本返回非0）则优先级 -5\r\n</p>\r\n<p>\r\n	fall 2                    #检测连续2次失败才算确定是真失败。会用weight减少优先级（1-255之间）\r\n</p>\r\n<p>\r\n	rise 1                    #检测1次成功就算成功。但不修改优先级\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {    #keepalived在同一virtual_router_id中priority（0-255）最大的会成为master，也就是接管VIP，当priority最大的主机发生故障后次priority将会接管\r\n</p>\r\n<p>\r\n	state MASTER    #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器。注意这里的state指定instance(Initial)的初始状态，就是说在配置好后，这台服务器的初始状态就是这里指定的，但这里指定的不算，还是得要通过竞选通过优先级来确定。如果这里设置为MASTER，但如若他的优先级不及另外一台，那么这台在发送通告时，会发送自己的优先级，另外一台发现优先级不如自己的高，那么他会就回抢占为MASTER\r\n</p>\r\n<p>\r\n	interface em1          #指定HA监测网络的接口。实例绑定的网卡，因为在配置虚拟IP的时候必须是在已有的网卡上添加的\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.14  # 发送多播数据包时的源IP地址，这里注意了，这里实际上就是在哪个地址上发送VRRP通告，这个非常重要，一定要选择稳定的网卡端口来发送，这里相当于heartbeat的心跳端口，如果没有设置那么就用默认的绑定的网卡的IP，也就是interface指定的IP地址\r\n</p>\r\n<p>\r\n	virtual_router_id 51         #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的\r\n</p>\r\n<p>\r\n	priority 101                 #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级\r\n</p>\r\n<p>\r\n	advert_int 1                 #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒\r\n</p>\r\n<p>\r\n	authentication {             #设置验证类型和密码。主从必须一样\r\n</p>\r\n<p>\r\n	auth_type PASS           #设置vrrp验证类型，主要有PASS和AH两种\r\n</p>\r\n<p>\r\n	auth_pass 1111           #设置vrrp验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {          #VRRP HA 虚拟地址 如果有多个VIP，继续换行填写\r\n</p>\r\n<p>\r\n	103.110.98.20\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {                      #执行监控的服务。注意这个设置不能紧挨着写在vrrp_script配置块的后面（实验中碰过的坑），否则nginx监控失效！！\r\n</p>\r\n<p>\r\n	chk_http_port                    #引用VRRP脚本，即在 vrrp_script 部分指定的名字。定期运行它们来改变优先级，并最终引发主备切换。\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	2）slave-node负载机上的keepalived配置[root@slave-node ~]# cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak[root@slave-node ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id slave-node\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_http_port {\r\n</p>\r\n<p>\r\n	script \"/opt/chk_nginx.sh\"\r\n</p>\r\n<p>\r\n	interval 2\r\n</p>\r\n<p>\r\n	weight -5\r\n</p>\r\n<p>\r\n	fall 2\r\n</p>\r\n<p>\r\n	rise 1\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface em1\r\n</p>\r\n<p>\r\n	mcast_src_ip 103.110.98.24\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 99\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	103.110.98.20\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_http_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	让keepalived监控NginX的状态：1）经过前面的配置，如果master主服务器的keepalived停止服务，slave从服务器会自动接管VIP对外服务；一旦主服务器的keepalived恢复，会重新接管VIP。 但这并不是我们需要的，我们需要的是当NginX停止服务的时候能够自动切换。2）keepalived支持配置监控脚本，我们可以通过脚本监控NginX的状态，如果状态不正常则进行一系列的操作，最终仍不能恢复NginX则杀掉keepalived，使得从服务器能够接管服务。\r\n</p>\r\n<p>\r\n	如何监控NginX的状态最简单的做法是监控NginX进程，更靠谱的做法是检查NginX端口，最靠谱的做法是检查多个url能否获取到页面。\r\n</p>\r\n<p>\r\n	注意：这里要提示一下keepalived.conf中vrrp_script配置区的script一般有2种写法：1）通过脚本执行的返回结果，改变优先级，keepalived继续发送通告消息，backup比较优先级再决定。这是直接监控Nginx进程的方式。2）脚本里面检测到异常，直接关闭keepalived进程，backup机器接收不到advertisement会抢占IP。这是检查NginX端口的方式。上文script配置部分，\"killall -0 nginx\"属于第1种情况，\"/opt/chk_nginx.sh\" 属于第2种情况。个人更倾向于通过shell脚本判断，但有异常时exit 1，正常退出exit 0，然后keepalived根据动态调整的 vrrp_instance 优先级选举决定是否抢占VIP：如果脚本执行结果为0，并且weight配置的值大于0，则优先级相应的增加如果脚本执行结果非0，并且weight配置的值小于0，则优先级相应的减少其他情况，原本配置的优先级不变，即配置文件中priority对应的值。\r\n</p>\r\n<p>\r\n	提示：优先级不会不断的提高或者降低可以编写多个检测脚本并为每个检测脚本设置不同的weight（在配置中列出就行）不管提高优先级还是降低优先级，最终优先级的范围是在[1,254]，不会出现优先级小于等于0或者优先级大于等于255的情况在MASTER节点的 vrrp_instance 中 配置 nopreempt ，当它异常恢复后，即使它 prio 更高也不会抢占，这样可以避免正常情况下做无谓的切换以上可以做到利用脚本检测业务进程的状态，并动态调整优先级从而实现主备切换。\r\n</p>\r\n<p>\r\n	另外：在默认的keepalive.conf里面还有 virtual_server,real_server 这样的配置，我们这用不到，它是为lvs准备的。\r\n</p>\r\n<p>\r\n	如何尝试恢复服务由于keepalived只检测本机和他机keepalived是否正常并实现VIP的漂移，而如果本机nginx出现故障不会则不会漂移VIP。所以编写脚本来判断本机nginx是否正常，如果发现NginX不正常，重启之。等待3秒再次校验，仍然失败则不再尝试，关闭keepalived，其他主机此时会接管VIP；\r\n</p>\r\n<p>\r\n	根据上述策略很容易写出监控脚本。此脚本必须在keepalived服务运行的前提下才有效！如果在keepalived服务先关闭的情况下，那么nginx服务关闭后就不能实现自启动了。该脚本检测ngnix的运行状态，并在nginx进程不存在时尝试重新启动ngnix，如果启动失败则停止keepalived，准备让其它机器接管。监控脚本如下（master和slave都要有这个监控脚本）：[root@master-node ~]# vim /opt/chk_nginx.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	counter=$(ps -C nginx --no-heading|wc -l)\r\n</p>\r\n<p>\r\n	if [ \"${counter}\" = \"0\" ]; then\r\n</p>\r\n<p>\r\n	/usr/local/nginx/sbin/nginx\r\n</p>\r\n<p>\r\n	sleep 2\r\n</p>\r\n<p>\r\n	counter=$(ps -C nginx --no-heading|wc -l)\r\n</p>\r\n<p>\r\n	if [ \"${counter}\" = \"0\" ]; then\r\n</p>\r\n<p>\r\n	/etc/init.d/keepalived stop\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master-node ~]# chmod 755 /opt/chk_nginx.sh[root@master-node ~]# sh /opt/chk_nginx.sh80/tcp open  http\r\n</p>\r\n<p>\r\n	此架构需考虑的问题1）master没挂，则master占有vip且nginx运行在master上2）master挂了，则slave抢占vip且在slave上运行nginx服务3）如果master上的nginx服务挂了，则nginx会自动重启，重启失败后会自动关闭keepalived，这样vip资源也会转移到slave上。4）检测后端服务器的健康状态5）master和slave两边都开启nginx服务，无论master还是slave，当其中的一个keepalived服务停止后，vip都会漂移到keepalived服务还在的节点上；如果要想使nginx服务挂了，vip也漂移到另一个节点，则必须用脚本或者在配置文件里面用shell命令来控制。（nginx服务宕停后会自动启动，启动失败后会强制关闭keepalived，从而致使vip资源漂移到另一台机器上）\r\n</p>\r\n<p>\r\n	最后验证（将配置的后端应用域名都解析到VIP地址上）：关闭主服务器上的keepalived或nginx，vip都会自动飘到从服务器上。验证keepalived服务故障情况：1）先后在master、slave服务器上启动nginx和keepalived，保证这两个服务都正常开启:[root@master-node ~]# /usr/local/nginx/sbin/nginx  [root@master-node ~]# /etc/init.d/keepalived start[root@slave-node ~]# /usr/local/nginx/sbin/nginx [root@slave-node ~]# /etc/init.d/keepalived start2）在主服务器上查看是否已经绑定了虚拟IP： [root@master-node ~]# ip addr.......2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000    link/ether 44:a8:42:17:3d:dd brd ff:ff:ff:ff:ff:ff    inet 103.110.98.14/26 brd 103.10.86.63 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.20/32 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.20/26 brd 103.10.86.63 scope global secondary em1:0       valid_lft forever preferred_lft forever    inet6 fe80::46a8:42ff:fe17:3ddd/64 scope link        valid_lft forever preferred_lft forever......3）停止主服务器上的keepalived: [root@master-node ~]# /etc/init.d/keepalived stop Stopping keepalived (via systemctl):                       [  OK  ][root@master-node ~]# /etc/init.d/keepalived status[root@master-node ~]# ps -ef|grep keepalivedroot     26952 24348  0 17:49 pts/0    00:00:00 grep --color=auto keepalived[root@master-node ~]# 4）然后在从服务器上查看，发现已经接管了VIP：[root@slave-node ~]# ip addr.......2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000    link/ether 44:a8:42:17:3c:a5 brd ff:ff:ff:ff:ff:ff    inet 103.110.98.24/26 brd 103.10.86.63 scope global em1    inet 103.110.98.20/32 scope global em1    inet6 fe80::46a8:42ff:fe17:3ca5/64 scope link        valid_lft forever preferred_lft forever.......发现master的keepalived服务挂了后，vip资源自动漂移到slave上，并且网站正常访问，丝毫没有受到影响！5）重新启动主服务器上的keepalived，发现主服务器又重新接管了VIP，此时slave机器上的VIP已经不在了。[root@master-node ~]# /etc/init.d/keepalived startStarting keepalived (via systemctl):                       [  OK  ][root@master-node ~]# ip addr.......2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000    link/ether 44:a8:42:17:3d:dd brd ff:ff:ff:ff:ff:ff    inet 103.110.98.14/26 brd 103.10.86.63 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.20/32 scope global em1       valid_lft forever preferred_lft forever    inet 103.110.98.20/26 brd 103.10.86.63 scope global secondary em1:0       valid_lft forever preferred_lft forever    inet6 fe80::46a8:42ff:fe17:3ddd/64 scope link        valid_lft forever preferred_lft forever......</broadcast,multicast,up,lower_up></broadcast,multicast,up,lower_up></broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	[root@slave-node ~]# ip addr.......2: em1: <broadcast,multicast,up,lower_up> mtu 1500 qdisc mq state UP qlen 1000link/ether 44:a8:42:17:3c:a5 brd ff:ff:ff:ff:ff:ffinet 103.110.98.24/26 brd 103.10.86.63 scope global em1inet6 fe80::46a8:42ff:fe17:3ca5/64 scope link valid_lft forever preferred_lft forever</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	接着验证下nginx服务故障，看看keepalived监控nginx状态的脚本是否正常？如下：手动关闭master机器上的nginx服务，最多2秒钟后就会自动起来（因为keepalive监控nginx状态的脚本执行间隔时间为2秒）。域名访问几乎不受影响！[root@master-node ~]# /usr/local/nginx/sbin/nginx -s stop[root@master-node ~]# ps -ef|grep nginxroot     28401 24826  0 19:43 pts/1    00:00:00 grep --color=auto nginx[root@master-node ~]# ps -ef|grep nginxroot     28871 28870  0 19:47 ?        00:00:00 /bin/sh /opt/chk_nginx.shroot     28875 24826  0 19:47 pts/1    00:00:00 grep --color=auto nginx[root@master-node ~]# ps -ef|grep nginxroot     28408     1  0 19:43 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginxwww      28410 28408  0 19:43 ?        00:00:00 nginx: worker processwww      28411 28408  0 19:43 ?        00:00:00 nginx: worker processwww      28412 28408  0 19:43 ?        00:00:00 nginx: worker processwww      28413 28408  0 19:43 ?        00:00:00 nginx: worker process\r\n</p>\r\n<p>\r\n	最后可以查看两台服务器上的/var/log/messages，观察VRRP日志信息的vip漂移情况~~~~\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('d7a04a46-b70c-4542-b3ef-aa00455da34d','Nginx虚拟目录alias和root目录','Nginx虚拟目录alias和root目录','<p>\r\n	nginx是通过alias设置虚拟目录，在nginx的配置中，alias目录和root目录是有区别的：1）alias指定的目录是准确的，即location匹配访问的path目录下的文件直接是在alias目录下查找的；2）root指定的目录是location匹配访问的path目录的上一级目录,这个path目录一定要是真实存在root指定目录下的；3）使用alias标签的目录块中不能使用rewrite的break（具体原因不明）；另外，alias指定的目录后面必须要加上\"/\"符号！！4）alias虚拟目录配置中，location匹配的path目录如果后面不带\"/\"，那么访问的url地址中这个path目录后面加不加\"/\"不影响访问，访问时它会自动加上\"/\"；&nbsp; &nbsp; 但是如果location匹配的path目录后面加上\"/\"，那么访问的url地址中这个path目录必须要加上\"/\"，访问时它不会自动加上\"/\"。如果不加上\"/\"，访问就会失败！5）root目录配置中，location匹配的path目录后面带不带\"/\"，都不会影响访问。\r\n</p>\r\n<p>\r\n	举例说明（比如nginx配置的域名是www.wangshibo.com）：（1）location /huan/ {&nbsp; &nbsp; &nbsp; alias /home/www/huan/;    }\r\n</p>\r\n<p>\r\n	在上面alias虚拟目录配置下，访问http://www.wangshibo.com/huan/a.html实际指定的是/home/www/huan/a.html。注意：alias指定的目录后面必须要加上\"/\"，即/home/www/huan/不能改成/home/www/huan\r\n</p>\r\n<p>\r\n	上面的配置也可以改成root目录配置，如下，这样nginx就会去/home/www/huan下寻找http://www.wangshibo.com/huan的访问资源，两者配置后的访问效果是一样的！location /huan/ {&nbsp; &nbsp; &nbsp; &nbsp;root /home/www/;    }\r\n</p>\r\n<p>\r\n	（2）上面的例子中alias设置的目录名和location匹配访问的path目录名一致，这样可以直接改成root目录配置；那要是不一致呢？再看一例：location /web/ {&nbsp; &nbsp; &nbsp; alias /home/www/html/;    }\r\n</p>\r\n<p>\r\n	访问http://www.wangshibo.com/web的时候就会去/home/www/html/下寻找访问资源。这样的话，还不能直接改成root目录配置。如果非要改成root目录配置，就只能在/home/www下将html-&gt;web（做软连接，即快捷方式），如下：location /web/ {&nbsp; &nbsp; &nbsp;root /home/www/;    }\r\n</p>\r\n<p>\r\n	# ln -s /home/www/web /home/www/html &nbsp; &nbsp; &nbsp; //即保持/home/www/web和/home/www/html内容一直\r\n</p>\r\n<p>\r\n	所以，一般情况下，在nginx配置中的良好习惯是：1）在location /中配置root目录；2）在location /path中配置alias虚拟目录。\r\n</p>\r\n<p>\r\n	如下一例：server {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen 80;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_name www.wangshibo.com;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index index.html index.php index.htm;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; access_log /usr/local/nginx/logs/image.log;\r\n</p>\r\n<p>\r\n	location / {&nbsp; &nbsp; &nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; &nbsp; &nbsp; }\r\n</p>\r\n<p>\r\n	location /haha { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//匹配的path目录haha不需要真实存在alias指定的目录中&nbsp; &nbsp; &nbsp; &nbsp;alias /var/www/html/ops/; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //后面的\"/\"符号一定要带上&nbsp; &nbsp; &nbsp; &nbsp;rewrite ^/opp/hen.php(.*)$ /opp/hen.php?s=$1 last;&nbsp; &nbsp; # rewrite ^/opp/(.*)$ /opp/hen.php?s=$1 last;&nbsp; &nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	location /wang { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//匹配的path目录wang一定要真实存在root指定的目录中（就/var/www/html下一定要有wang目录存在）&nbsp; &nbsp; &nbsp; root /var/www/html;&nbsp; &nbsp; &nbsp;}\r\n</p>\r\n<p>\r\n	}\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('d938c5cc-7765-483a-955a-74cf1fd88c96','自动化暂无文章','自动化暂无文章','自动化暂无文章','2017-07-24 10:47:06',5,19,'images/svn.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('dd7b8efd-3689-44d0-bc5e-e7d88207dd12','nginx反向代理tomcat访问时浏览器加载失败，出现 ERR_CONTENT_LENGTH_MI','nginx反向代理tomcat访问时浏览器加载失败，出现 ERR_CONTENT_LENGTH_MISMATCH 问题','<p>\r\n	问题说明：测试机上部署了一套业务环境，nginx反向代理tomcat，在访问时长时间处于加载中，十分缓慢！\r\n</p>\r\n<p>\r\n	通过浏览器调试（F12键-&gt;Console），发现有错误ERR_CONTENT_LENGTH_MISMATCH 出现：\r\n</p>\r\n<p>\r\n	查看nginx日志（当出现故障时，要记得第一时间查看相关日志）.......open() \"/Data/app/nginx/proxy_temp/3/00/0000000003\" failed (13: Permission denied) while reading upstream, client:...... server: localhost, request: \"GET\r\n</p>\r\n<p>\r\n	原因：nginx在做代理时，其工作进程对大文件做了缓存，这个缓存在 %nginx%/proxy_temp 目录下，主进程在读取缓存的时候由于权限问题而无法访问。\r\n</p>\r\n<p>\r\n	[root@dev-new-test proxy_temp]# pwd/Data/app/nginx/proxy_temp[root@dev-new-test proxy_temp]# ll总用量 40drwx------ 33 www www 4096 11月 22 17:07 0drwx------ 34 www www 4096 11月 22 17:07 1drwx------ 34 www www 4096 11月 22 17:07 2drwx------ 35 www www 4096 11月 22 17:07 3drwx------ 35 www www 4096 11月 22 17:16 4drwx------ 35 www www 4096 11月 22 17:16 5drwx------ 34 www www 4096 11月 22 16:46 6drwx------ 33 www www 4096 11月 22 16:46 7drwx------ 33 www www 4096 11月 22 16:47 8drwx------ 33 www www 4096 11月 22 17:07 9\r\n</p>\r\n<p>\r\n	发现nginx的缓存目录都是www权限，而nginx进程的启动用户是nobody，因为需要将缓存的目录权限修改成nobody！[root@dev-new-test proxy_temp]# ps -ef|grep nginxnobody   28072 46482  0 18:09 ?        00:00:00 nginx: worker process ......\r\n</p>\r\n<p>\r\n	[root@dev-new-test proxy_temp]# pwd/Data/app/nginx/proxy_temp[root@dev-new-test proxy_temp]# chown -R nobody.nobody ./*[root@dev-new-test proxy_temp]# ll总用量 40drwx------ 33 nobody nobody 4096 11月 22 17:07 0drwx------ 34 nobody nobody 4096 11月 22 17:07 1drwx------ 34 nobody nobody 4096 11月 22 17:07 2drwx------ 35 nobody nobody 4096 11月 22 17:07 3drwx------ 35 nobody nobody 4096 11月 22 17:16 4drwx------ 35 nobody nobody 4096 11月 22 17:16 5drwx------ 34 nobody nobody 4096 11月 22 16:46 6drwx------ 33 nobody nobody 4096 11月 22 16:46 7drwx------ 33 nobody nobody 4096 11月 22 16:47 8drwx------ 33 nobody nobody 4096 11月 22 17:07 9\r\n</p>\r\n<p>\r\n	这样，就解决了上面出现的错误问题：\r\n</p>\r\n<p>\r\n	另外：nginx代理tomcat，访问缓慢问题，还有一种可能原因就是tomcat默认的根目录是webapps/ROOT，如果不是ROOT，可能也会导致访问问题。因为，在部署环境时，首先将webapps下的文件全部删除，然后将war包上传到webapps下改名为ROOT.war，最好说服开发同事在打包时就打包成ROOT.war名称，不然后续上传后就手动修改，这样tomcat重启后，就会自动解压ROOT.war包，自然根目录就会是webapps/ROOT\r\n</p>\r\n<p>\r\n	还有在部署多个tomcat实例时，尽量不要拷贝已用的tomcat并修改端口后投入使用，最好是拷贝源码解压后的纯净的tomcat，然后修改端口投入使用。\r\n</p>\r\n<p>\r\n	当然，访问页面没有反应时，也可能是因为服务器磁盘爆满导致！多方面考虑吧~\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('de610ef4-aac4-422e-b7c4-ed69665bbb3c','Itchat控制windows音乐播放器','Itchat控制windows音乐播放器','环境:windows python2.7<br />\r\n依赖包：pywin32 itchat<br />\r\n依赖包安装 ：pip install itchat &nbsp; 官方文档：http://itchat.readthedocs.io/zh/latest/<br />\r\nwindows pywin32 下载链接：https://nchc.dl.sourceforge.net/project/pywin32/pywin32/Build%20221/pywin32-221.win-amd64-py2.7.exe<br />\r\n效果图：<br />\r\n<br />\r\n代码：<br />\r\n# _*_ coding:utf-8 _*_<br />\r\nimport itchat<br />\r\nimport os<br />\r\nimport win32api<br />\r\nmusic_path=r\'d:\\Music\' ##音乐存放路径<br />\r\ndef get_musiclist(musicpath):<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; 获取音乐播放列表<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; music_list=[]<br />\r\n&nbsp; &nbsp; a=1<br />\r\n&nbsp; &nbsp; for musicpath in os.listdir(musicpath):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if os.path.splitext(musicpath)[1] in [\'.mp3\',\'.ape\',\'.flac\']:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; music_list.append(\'%s %s\'%(a,musicpath.decode(\'gbk\')))<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a+=1<br />\r\n&nbsp; &nbsp; return music_list &nbsp;&nbsp;<br />\r\n<br />\r\ndef music_play(musicfile):<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; 用系统默认的音乐播放器播放音乐<br />\r\n&nbsp; &nbsp; \"\"\"<br />\r\n&nbsp; &nbsp; &nbsp;win32api.ShellExecute(0, \'open\', r\'%s\\%s\'%(music_path,musicfile), \'\',\'\',0)<br />\r\n<br />\r\n@itchat.msg_register(itchat.content.TEXT)<br />\r\n<br />\r\ndef text_reply(msg):<br />\r\n&nbsp; &nbsp; if msg[\'Text\']==\'help\':<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; help_text=u\'1 help 帮助\\r\\n2 数字 播放音乐\\r\\n3 字符 查找播放音乐\'<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; itchat.send(help_text, toUserName=\'filehelper\')<br />\r\n&nbsp; &nbsp; for music in get_musiclist(music_path):<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if msg[\'Text\']==music.split(\' \',1)[0]:###用音乐序列号播放音乐<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; music_play(music.split(\' \',1)[1]) &nbsp; &nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itchat.send(u\' 正在播放音乐：%s\'%music.split(\' \',1)[1], toUserName=\'filehelper\')<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; elif msg[\'Text\'].lower() in music.lower():###用音乐文件名播放音乐<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; music_play(music.split(\' \',1)[1])<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itchat.send(u\' 正在播放音乐：%s\'%music.split(\' \',1)[1], toUserName=\'filehelper\')<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br />\r\n&nbsp; &nbsp; else:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; itchat.send(u\'没有找到：%s\'%msg[\'Text\'], toUserName=\'filehelper\') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r\nitchat.auto_login(hotReload=True)##扫码一次后存储<br />\r\nitchat.run()<br />\r\n<br />\r\n<br />\r\n<br />','2017-08-01 10:55:29',2,1,'images/python.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('de6ec6af-3748-4677-8e2c-461561e2c9f6','proxy_pass反向代理配置中url后面加不加/的说明','proxy_pass反向代理配置中url后面加不加/的说明','<p>\r\n	在日常的web网站部署中，经常会用到nginx的proxy_pass反向代理，有一个配置需要弄清楚：配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走（这样配置在Nginx反向代理+负载均衡简单实现（http方式）也提到过）。下面举个小实例说明下：centos7系统库中默认是没有nginx的rpm包的，所以我们自己需要先更新下rpm依赖库\r\n</p>\r\n<p>\r\n	1）使用yum安装nginx需要包括Nginx的库，安装Nginx的库\r\n</p>\r\n<p>\r\n	[root@localhost ~]# rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\r\n</p>\r\n<p>\r\n	2）使用下面命令安装nginx\r\n</p>\r\n<p>\r\n	[root@localhost ~]# yum install nginx\r\n</p>\r\n<p>\r\n	3）nginx配置\r\n</p>\r\n<p>\r\n	[root@localhost ~]# cd /etc/nginx/conf.d/\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat /var/www/html/index.html\r\n</p>\r\n<p>\r\n	this is page of test!!!!\r\n</p>\r\n<p>\r\n	4）启动Nginx\r\n</p>\r\n<p>\r\n	[root@localhost ~]# service nginx start     //或者使用 systemctl start nginx.service\r\n</p>\r\n<p>\r\n	5）测试访问（103.110.186.23是192.168.1.23机器的外网ip）\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23\r\n</p>\r\n<p>\r\n	this is page of test!!!!\r\n</p>\r\n<p>\r\n	--------------------------看看下面几种情况：分别用http://192.168.1.23/proxy/index.html进行访问测试-----------------\r\n</p>\r\n<p>\r\n	为了方便测试，先在另一台机器192.168.1.5上部署一个8090端口的nginx，配置如下：\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# cat /usr/local/nginx/conf/vhosts/haha.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 8090;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# cat /var/www/html/index.html\r\n</p>\r\n<p>\r\n	this is 192.168.1.5\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# /usr/local/nginx/sbin/nginx -s reload\r\n</p>\r\n<p>\r\n	测试访问（103.110.186.5是192.168.1.5的外网ip）：\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# curl http://192.168.1.5:8090\r\n</p>\r\n<p>\r\n	this is 192.168.1.5\r\n</p>\r\n<p>\r\n	192.168.1.23作为nginx反向代理机器，nginx配置如下：1）第一种情况：\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	这样，访问http://192.168.1.23/proxy/就会被代理到http://192.168.1.5:8090/。p匹配的proxy目录不需要存在根目录/var/www/html里面注意，终端里如果访问http://192.168.1.23/proxy（即后面不带\"/\"），则会访问失败！因为proxy_pass配置的url后面加了\"/\"\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23/proxy/\r\n</p>\r\n<p>\r\n	this is 192.168.1.5\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23/proxy\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	301 Moved Permanently\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<h1>\r\n	301 Moved Permanently\r\n</h1>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<hr />\r\nnginx/1.10.3\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	页面访问http://103.110.186.23/proxy的时候，会自动加上\"/”（同理是由于proxy_pass配置的url后面加了\"/\"），并反代到http://103.110.186.5:8090的结果\r\n</p>\r\n<p>\r\n	2）第二种情况，proxy_pass配置的url后面不加\"/\"\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	那么访问http://192.168.1.23/proxy或http://192.168.1.23/proxy/，都会失败！\r\n</p>\r\n<p>\r\n	这样配置后，访问http://192.168.1.23/proxy/就会被反向代理到http://192.168.1.5:8090/proxy/\r\n</p>\r\n<p>\r\n	3）第三种情况\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/haha/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23/proxy/\r\n</p>\r\n<p>\r\n	192.168.1.5  haha-index.html\r\n</p>\r\n<p>\r\n	这样配置的话，访问http://103.110.186.23/proxy代理到http://192.168.1.5:8090/haha/\r\n</p>\r\n<p>\r\n	4）第四种情况：相对于第三种配置的url不加\"/\"\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy/ {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/haha;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23/proxy/index.html\r\n</p>\r\n<p>\r\n	192.168.1.5   hahaindex.html\r\n</p>\r\n<p>\r\n	上面配置后，访问http://192.168.1.23/proxy/index.html就会被代理到http://192.168.1.5:8090/hahaindex.html\r\n</p>\r\n<p>\r\n	同理，访问http://192.168.1.23/proxy/test.html就会被代理到http://192.168.1.5:8090/hahatest.html\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# curl http://192.168.1.23/proxy/index.html\r\n</p>\r\n<p>\r\n	192.168.1.5   hahaindex.html\r\n</p>\r\n<p>\r\n	注意，这种情况下，不能直接访问http://192.168.1.23/proxy/，后面就算是默认的index.html文件也要跟上，否则访问失败！\r\n</p>\r\n<p>\r\n	-------------------------------------------------------------------------------------上面四种方式都是匹配的path路径后面加\"/\"，下面说下path路径后面不带\"/\"的情况：\r\n</p>\r\n<p>\r\n	1）第一种情况，proxy_pass后面url带\"/\"：\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	2）第二种情况，proxy_pass后面url不带\"/\"\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]#\r\n</p>\r\n<p>\r\n	这样配置的话，访问http://103.110.186.23/proxy会自动加上\"/”（即变成http://103.110.186.23/proxy/），代理到192.168.1.5:8090/proxy/\r\n</p>\r\n<p>\r\n	3）第三种情况\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/haha/;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	这样配置的话，访问http://103.110.186.23/proxy会自动加上\"/”（即变成http://103.110.186.23/proxy/），代理到http://192.168.1.5:8090/haha/\r\n</p>\r\n<p>\r\n	4）第四种情况：相对于第三种配置的url不加\"/\"\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# cat test.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen 80;\r\n</p>\r\n<p>\r\n	server_name localhost;\r\n</p>\r\n<p>\r\n	location / {\r\n</p>\r\n<p>\r\n	root /var/www/html;\r\n</p>\r\n<p>\r\n	index index.html;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location  /proxy {\r\n</p>\r\n<p>\r\n	proxy_pass http://192.168.1.5:8090/haha;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@localhost conf.d]# service nginx restart\r\n</p>\r\n<p>\r\n	Redirecting to /bin/systemctl restart  nginx.service\r\n</p>\r\n<p>\r\n	这样配置的话，访问http://103.110.186.23/proxy，和第三种结果一样，同样被代理到http://192.168.1.5:8090/haha/\r\n</p>','2017-07-31 17:16:48',1,1,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('de94c6bd-874e-4a8c-b8a0-d5febd65a29d','MySQL高可用方案－PXC环境部署记录','MySQL高可用方案－PXC环境部署记录','<p>\r\n	之前梳理了Mysql+Keepalived双主热备高可用操作记录，对于mysql高可用方案，经常用到的的主要有下面三种：\r\n</p>\r\n<p>\r\n	一、基于主从复制的高可用方案：双节点主从 + keepalived\r\n</p>\r\n<p>\r\n	一般来说，中小型规模的时候，采用这种架构是最省事的。\r\n</p>\r\n<p>\r\n	两个节点可以采用简单的一主一从模式，或者双主模式，并且放置于同一个VLAN中，在master节点发生故障后，利用keepalived/heartbeat的高可用机制实现快速\r\n</p>\r\n<p>\r\n	切换到slave节点。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在这个方案里，有几个需要注意的地方：\r\n</p>\r\n<p>\r\n	采用keepalived作为高可用方案时，两个节点最好都设置成BACKUP模式，避免因为意外情况下（比如脑裂）相互抢占导致往两个节点写入相同数据而引发冲突；\r\n</p>\r\n<p>\r\n	1）把两个节点的auto_increment_increment（自增步长）和auto_increment_offset（自增起始值）设成不同值。其目的是为了避免master节点意外宕机时，\r\n</p>\r\n<p>\r\n	可能会有部分binlog未能及时复制到slave上被应用，从而会导致slave新写入数据的自增值和原先master上冲突了，因此一开始就使其错开；当然了，如果有合适的\r\n</p>\r\n<p>\r\n	容错机制能解决主从自增ID冲突的话，也可以不这么做；\r\n</p>\r\n<p>\r\n	2）slave节点服务器配置不要太差，否则更容易导致复制延迟。作为热备节点的slave服务器，硬件配置不能低于master节点；\r\n</p>\r\n<p>\r\n	3）如果对延迟问题很敏感的话，可考虑使用MariaDB分支版本，或者直接上线MySQL 5.7最新版本，利用多线程复制的方式可以很大程度降低复制延迟；\r\n</p>\r\n<p>\r\n	4）对复制延迟特别敏感的另一个备选方案，是采用semi sync replication（就是所谓的半同步复制）或者后面会提到的PXC方案，基本上无延迟，不过事务并发性\r\n</p>\r\n<p>\r\n	能会有不小程度的损失，需要综合评估再决定；\r\n</p>\r\n<p>\r\n	5）keepalived的检测机制需要适当完善，不能仅仅只是检查mysqld进程是否存活，或者MySQL服务端口是否可通，还应该进一步做数据写入或者运算的探测，判断响\r\n</p>\r\n<p>\r\n	应时间，如果超过设定的阈值，就可以启动切换机制；\r\n</p>\r\n<p>\r\n	6）keepalived最终确定进行切换时，还需要判断slave的延迟程度。需要事先定好规则，以便决定在延迟情况下，采取直接切换或等待何种策略。直接切换可能因为复\r\n</p>\r\n<p>\r\n	制延迟有些数据无法查询到而重复写入；\r\n</p>\r\n<p>\r\n	7）keepalived或heartbeat自身都无法解决脑裂的问题，因此在进行服务异常判断时，可以调整判断脚本，通过对第三方节点补充检测来决定是否进行切换，可降低脑\r\n</p>\r\n<p>\r\n	裂问题产生的风险。\r\n</p>\r\n<p>\r\n	双节点主从+keepalived/heartbeat方案架构示意图见下：\r\n</p>\r\n<p>\r\n	二、基于主从复制的高可用方案：多节点主从+MHA/MMM\r\n</p>\r\n<p>\r\n	多节点主从，可以采用一主多从，或者双主多从的模式。\r\n</p>\r\n<p>\r\n	这种模式下，可以采用MHA或MMM来管理整个集群，目前MHA应用的最多，优先推荐MHA，最新的MHA也已支持MySQL 5.6的GTID模式了，是个好消息。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	MHA的优势很明显：\r\n</p>\r\n<p>\r\n	1）开源，用Perl开发，代码结构清晰，二次开发容易；\r\n</p>\r\n<p>\r\n	2）方案成熟，故障切换时，MHA会做到较严格的判断，尽量减少数据丢失，保证数据一致性；\r\n</p>\r\n<p>\r\n	3)提供一个通用框架，可根据自己的情况做自定义开发，尤其是判断和切换操作步骤；\r\n</p>\r\n<p>\r\n	4)支持binlog server，可提高binlog传送效率，进一步减少数据丢失风险。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	不过MHA也有些限制：\r\n</p>\r\n<p>\r\n	1）需要在各个节点间打通ssh信任，这对某些公司安全制度来说是个挑战，因为如果某个节点被黑客攻破的话，其他节点也会跟着遭殃；\r\n</p>\r\n<p>\r\n	2）自带提供的脚本还需要进一步补充完善，当然了，一般的使用还是够用的。\r\n</p>\r\n<p>\r\n	三、基于Galera协议的高可用方案：PXC\r\n</p>\r\n<p>\r\n	Galera是Codership提供的多主数据同步复制机制，可以实现多个节点间的数据同步复制以及读写，并且可保障数据库的服务高可用及数据一致性。\r\n</p>\r\n<p>\r\n	基于Galera的高可用方案主要有MariaDB Galera Cluster和Percona XtraDB Cluster（简称PXC），目前PXC用的会比较多一些。\r\n</p>\r\n<p>\r\n	mariadb的集群原理跟PXC一样,maridb-cluster其实就是PXC，两者原理是一样的。\r\n</p>\r\n<p>\r\n	下面重点介绍下基于PXC的mysql高可用环境部署记录。\r\n</p>\r\n<p>\r\n	1、PXC介绍\r\n</p>\r\n<p>\r\n	Percona XtraDB Cluster（简称PXC集群）提供了MySQL高可用的一种实现方法。\r\n</p>\r\n<p>\r\n	1）集群是有节点组成的，推荐配置至少3个节点，但是也可以运行在2个节点上。\r\n</p>\r\n<p>\r\n	2）每个节点都是普通的mysql/percona服务器，可以将现有的数据库服务器组成集群，反之，也可以将集群拆分成单独的服务器。\r\n</p>\r\n<p>\r\n	3）每个节点都包含完整的数据副本。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	PXC集群主要由两部分组成：Percona Server with XtraDB和Write Set Replication patches（使用了Galera library，一个通用的用于事务型应用的同步、多主复制插件）。\r\n</p>\r\n<p>\r\n	2、PXC特性\r\n</p>\r\n<p>\r\n	1）同步复制，事务要么在所有节点提交或不提交。\r\n</p>\r\n<p>\r\n	2）多主复制，可以在任意节点进行写操作。\r\n</p>\r\n<p>\r\n	3）在从服务器上并行应用事件，真正意义上的并行复制。\r\n</p>\r\n<p>\r\n	4）节点自动配置，数据一致性，不再是异步复制。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	PXC最大的优势：强一致性、无同步延迟\r\n</p>\r\n<p>\r\n	3、PXC优缺点\r\n</p>\r\n<p>\r\n	PXC的优点\r\n</p>\r\n<p>\r\n	1）服务高可用；\r\n</p>\r\n<p>\r\n	2）数据同步复制(并发复制)，几乎无延迟；\r\n</p>\r\n<p>\r\n	3）多个可同时读写节点，可实现写扩展，不过最好事先进行分库分表，让各个节点分别写不同的表或者库，避免让galera解决数据冲突；\r\n</p>\r\n<p>\r\n	4）新节点可以自动部署，部署操作简单；\r\n</p>\r\n<p>\r\n	5）数据严格一致性，尤其适合电商类应用；\r\n</p>\r\n<p>\r\n	6）完全兼容MySQL；\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	虽然PXC有这么多好处，但也有些局限性：\r\n</p>\r\n<p>\r\n	1）只支持InnoDB引擎；当前版本（5.6.20）的复制只支持InnoDB引擎，其他存储引擎的更改不复制。然而，DDL（Data Definition Language） 语句在statement级别\r\n</p>\r\n<p>\r\n	被复制，并且，对mysql.*表的更改会基于此被复制。例如CREATE USER...语句会被复制，但是 INSERT INTO mysql.user...语句则不会。\r\n</p>\r\n<p>\r\n	（也可以通过wsrep_replicate_myisam参数开启myisam引擎的复制，但这是一个实验性的参数）。\r\n</p>\r\n<p>\r\n	2）PXC集群一致性控制机制，事有可能被终止，原因如下：集群允许在两个节点上同时执行操作同一行的两个事务，但是只有一个能执行成功，另一个会被终止，集群会给被终止的\r\n</p>\r\n<p>\r\n	客户端返回死锁错误(Error: 1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK)).\r\n</p>\r\n<p>\r\n	3）写入效率取决于节点中最弱的一台，因为PXC集群采用的是强一致性原则，一个更改操作在所有节点都成功才算执行成功。\r\n</p>\r\n<p>\r\n	4）所有表都要有主键；\r\n</p>\r\n<p>\r\n	5）不支持LOCK TABLE等显式锁操作；\r\n</p>\r\n<p>\r\n	6）锁冲突、死锁问题相对更多；\r\n</p>\r\n<p>\r\n	7）不支持XA；\r\n</p>\r\n<p>\r\n	8）集群吞吐量/性能取决于短板；\r\n</p>\r\n<p>\r\n	9）新加入节点采用SST时代价高；\r\n</p>\r\n<p>\r\n	10）存在写扩大问题；\r\n</p>\r\n<p>\r\n	11）如果并发事务量很大的话，建议采用InfiniBand网络，降低网络延迟；\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	事实上，采用PXC的主要目的是解决数据的一致性问题，高可用是顺带实现的。因为PXC存在写扩大以及短板效应，并发效率会有较大损失，类似semi sync replication机制。\r\n</p>\r\n<p>\r\n	4、PXC原理描述\r\n</p>\r\n<p>\r\n	分布式系统的CAP理论：\r\n</p>\r\n<p>\r\n	C：一致性，所有的节点数据一致\r\n</p>\r\n<p>\r\n	A：可用性，一个或者多个节点失效，不影响服务请求\r\n</p>\r\n<p>\r\n	P：分区容忍性，节点间的连接失效，仍然可以处理请求\r\n</p>\r\n<p>\r\n	其实，任何一个分布式系统，需要满足这三个中的两个。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	PXC会使用大概是4个端口号\r\n</p>\r\n<p>\r\n	3306：数据库对外服务的端口号\r\n</p>\r\n<p>\r\n	4444：请求SST SST: 指数据一个镜象传输 xtrabackup , rsync ,mysqldump\r\n</p>\r\n<p>\r\n	4567: 组成员之间进行沟通的一个端口号\r\n</p>\r\n<p>\r\n	4568: 传输IST用的。相对于SST来说的一个增量。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	一些名词介绍：\r\n</p>\r\n<p>\r\n	WS：write set 写数据集\r\n</p>\r\n<p>\r\n	IST: Incremental State Transfer 增量同步\r\n</p>\r\n<p>\r\n	SST：State Snapshot Transfer 全量同步\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	PXC环境所涉及的端口：\r\n</p>\r\n<p>\r\n	#mysql实例端口\r\n</p>\r\n<p>\r\n	10Regular MySQL port, default 3306.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#pxc cluster相互通讯的端口\r\n</p>\r\n<p>\r\n	2）Port for group communication, default 4567. It can be changed by the option:\r\n</p>\r\n<p>\r\n	wsrep_provider_options =\"gmcast.listen_addr=tcp://0.0.0.0:4010; \"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#用于SST传送的端口\r\n</p>\r\n<p>\r\n	3）Port for State Transfer, default 4444. It can be changed by the option:\r\n</p>\r\n<p>\r\n	wsrep_sst_receive_address=10.11.12.205:5555\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#用于IST传送的端口\r\n</p>\r\n<p>\r\n	4）Port for Incremental State Transfer, default port for group communication + 1 (4568). It can be changed by the option:\r\n</p>\r\n<p>\r\n	wsrep_provider_options = \"ist.recv_addr=10.11.12.206:7777; \"\r\n</p>\r\n<p>\r\n	PXC的架构示意图：\r\n</p>\r\n<p>\r\n	数据读写示意图\r\n</p>\r\n<p>\r\n	---------------------------------------下面看下传统复制流程----------------------------------\r\n</p>\r\n<p>\r\n	异步复制\r\n</p>\r\n<p>\r\n	半同步 超过10秒的阀值会退化为异步\r\n</p>\r\n<p>\r\n	不管同步或是半同步，都存在一定的延迟，那么PXC怎么做到不延迟呢？PXC最大的优势：强一致性、无同步延迟每一个节点都可以读写，WriteSet写的集合，用箱子推给Group里所有的成员， data page 相当于物理复制，而不是发日志，就是一个写的结果了。\r\n</p>\r\n<p>\r\n	PXC原理图\r\n</p>\r\n<p>\r\n	从上图可以看出：\r\n</p>\r\n<p>\r\n	当client端执行dml操作时，将操作发给server，server的native进程处理请求，client端执行commit，server将复制写数据集发给group(cluster)，cluster\r\n</p>\r\n<p>\r\n	中每个动作对应一个GTID，其它server接收到并通过验证(合并数据)后，执行appyl_cb动作和commit_cb动作，若验证没通过，则会退出处理;当前server节点验证通\r\n</p>\r\n<p>\r\n	过后，执行commit_cb，并返回，若没通过，执行rollback_cb。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	只要当前节点执行了commit_cb和其它节点验证通过后就可返回。\r\n</p>\r\n<p>\r\n	3306:数据库对外服务的端口号\r\n</p>\r\n<p>\r\n	4444:请求SST，在新节点加入时起作用\r\n</p>\r\n<p>\r\n	4567:组成员之间沟通的端口\r\n</p>\r\n<p>\r\n	4568:传输IST，节点下线，重启加入时起作用\r\n</p>\r\n<p>\r\n	SST:全量同步\r\n</p>\r\n<p>\r\n	IST:增量同步\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	问题：如果主节点写入过大，apply_cb时间跟不上，怎么处理？\r\n</p>\r\n<p>\r\n	Wsrep_slave_threads参数配置成cpu的个数相等或是1.5倍。\r\n</p>\r\n<p>\r\n	用户发起Commit，在收到Ok之前，集群每次发起一个动作，都会有一个唯一的编号 ，也就是PXC独有的Global Trx Id。动作发起者是commit_cb，其它节点多了一个动作： apply_cb\r\n</p>\r\n<p>\r\n	上面的这些动作，是通过那个端号交互的？4567，4568端口，IST只是在节点下线，重启加入那一个时间有用4444端口，只会在新节点加入进来时起作用\r\n</p>\r\n<p>\r\n	PXC结构里面，如果主节点写入过大，apply_cb 时间会不会跟不上，那么wsrep_slave_threads参数 解决apply_cb跟不上问题 配置成和CPU的个数相等或是1.5倍当前节点commit_cb 后就可以返回了，推过去之后，验证通过就行了可以返回客户端了，cb也就是commit block 提交数据块.\r\n</p>\r\n<p>\r\n	5、PXC启动和关闭过程\r\n</p>\r\n<p>\r\n	State Snapshot Transfer(SST)，每个节点都有一份独立的数据，当用mysql bootstrap-pxc启动第一个节点，在第一个节点上把帐号初始化，其它节点启动后加入进来。集群中有哪些节点是由wsrep_cluster_address = gcomm://xxxx,,xxxx,xxx参数决定。第一个节点把自己备份一下(snapshot)传给加入的新节点，第三个节点的死活是由前两个节点投票决定。\r\n</p>\r\n<p>\r\n	状态机变化阶段：\r\n</p>\r\n<p>\r\n	1）OPEN: 节点启动成功，尝试连接到集群，如果失败则根据配置退出或创建新的集群\r\n</p>\r\n<p>\r\n	2）PRIMARY: 节点处于集群PC中，尝试从集群中选取donor进行数据同步\r\n</p>\r\n<p>\r\n	3）JOINER: 节点处于等待接收/接收数据文件状态，数据传输完成后在本地加载数据\r\n</p>\r\n<p>\r\n	4）JOINED: 节点完成数据同步工作，尝试保持和集群进度一致\r\n</p>\r\n<p>\r\n	5）SYNCED：节点正常提供服务：数据的读写，集群数据的同步，新加入节点的sst请求\r\n</p>\r\n<p>\r\n	6）DONOR(贡献数据者)：节点处于为新节点准备或传输集群全量数据状态，对客户端不可用。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	状态机变化因素：\r\n</p>\r\n<p>\r\n	1）新节点加入集群\r\n</p>\r\n<p>\r\n	2）节点故障恢复\r\n</p>\r\n<p>\r\n	3）节点同步失效\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	传输SST有几种方法:\r\n</p>\r\n<p>\r\n	1）mysqldump\r\n</p>\r\n<p>\r\n	2）xtrabackup\r\n</p>\r\n<p>\r\n	3）rsync\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	比如有三个节点：node1、node2、node3\r\n</p>\r\n<p>\r\n	当node3停机重启后，通过IST来同步增量数据，来完成保证与node1和node2的数据一致，IST的实现是由wsrep_provider_options=\"gcache.size=1G\"参数决定，\r\n</p>\r\n<p>\r\n	一般设置为1G大，参数大小是由什么决定的，根据停机时间，若停机一小时，需要确认1小时内产生多大的binlog来算出参数大小。\r\n</p>\r\n<p>\r\n	假设这三个节点都关闭了，会发生什么呢？\r\n</p>\r\n<p>\r\n	全部传SST，因为gcache数据没了\r\n</p>\r\n<p>\r\n	全部关闭需要采用滚动关闭方式：\r\n</p>\r\n<p>\r\n	1）关闭node1，修复完后，启动加回来;\r\n</p>\r\n<p>\r\n	2）关闭node2,修复完后，启动加回来;\r\n</p>\r\n<p>\r\n	3）......,直到最后一个节点\r\n</p>\r\n<p>\r\n	4）原则要保持Group里最少一个成员活着\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	数据库关闭之后，最会保存一个last Txid，所以启动时，先要启动最后一个关闭的节点，启动顺序和关闭顺序刚好相反。\r\n</p>\r\n<p>\r\n	wsrep_recover=on参数在启动时加入，用于从log中分析gtid。\r\n</p>\r\n<p>\r\n	怎样避免关闭和启动时数据丢失？\r\n</p>\r\n<p>\r\n	1）所有的节点中最少有一个在线，进行滚动重启;\r\n</p>\r\n<p>\r\n	2）利用主从的概念，把一个从节点转化成PXC里的节点。\r\n</p>\r\n<p>\r\n	6、PXC注意的问题\r\n</p>\r\n<p>\r\n	1）脑裂：任何命令执行出现unkown command ，表示出现脑裂，集群两节点间4567端口连不通，无法提供对外服务。\r\n</p>\r\n<p>\r\n	SET GLOBAL wsrep_provider_options=\"pc.ignore_sb=true\";\r\n</p>\r\n<p>\r\n	2）并发写：三个节点的自增起始值为1、2、3，步长都为3，解决了insert问题，但update同时对一行操作就会有问题，出现：\r\n</p>\r\n<p>\r\n	Error： 1213  SQLSTATE: 40001，所以更新和写入在一个节点上操作。\r\n</p>\r\n<p>\r\n	3）DDL：引起全局锁，采用：pt-online-schema-change\r\n</p>\r\n<p>\r\n	4）MyISAM引擎不能被复制，只支持innodb\r\n</p>\r\n<p>\r\n	5）pxc结构里面必须有主键，如果没有主建，有可能会造成集中每个节点的Data page里的数据不一样\r\n</p>\r\n<p>\r\n	6）不支持表级锁，不支持lock /unlock tables\r\n</p>\r\n<p>\r\n	7）pxc里只能把slow log ,query log 放到File里\r\n</p>\r\n<p>\r\n	8）不支持XA事务\r\n</p>\r\n<p>\r\n	9）性能由集群中性能最差的节点决定\r\n</p>\r\n<p>\r\n	------------------------------------------------------------------------------------------------------------下面记录在Centos下部署基于PXC的Mysql高可用方案操作过程\r\n</p>\r\n<p>\r\n	官方配置说明：https://www.percona.com/doc/percona-xtradb-cluster/5.5/howtos/centos_howto.html\r\n</p>\r\n<p>\r\n	1）环境描述（centos6.8版本）\r\n</p>\r\n<p>\r\n	node1  10.171.60.171  percona1\r\n</p>\r\n<p>\r\n	node2  10.44.183.73   percona2\r\n</p>\r\n<p>\r\n	node3  10.51.58.169   percona3\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	三个节点上的iptables最好关闭（否则就要开放3306、4444、4567、4568端口的访问）、关闭selinux\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）三个node节点都要执行以下操作。\r\n</p>\r\n<p>\r\n	可以选择源码或者yum，在此使用yum安装。\r\n</p>\r\n<p>\r\n	基础安装\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# yum -y groupinstall Base Compatibility libraries Debugging Tools Dial-up Networking suppport Hardware monitoring utilities Performance Tools Development tools\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	组件安装\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# yum install http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm -y\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# yum install Percona-XtraDB-Cluster-55 -y\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	3）数据库配置\r\n</p>\r\n<p>\r\n	选择一个node作为名义上的master，下面就以node1为master，只需要修改mysql的配置文件－－/etc/my.cnf\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－－－－－－以下是在node1节点上的配置－－－－－－－－－－－－－－－－－－－－－－\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# cat /etc/my.cnf\r\n</p>\r\n<p>\r\n	[mysqld]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	datadir=/var/lib/mysql\r\n</p>\r\n<p>\r\n	user=mysql\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Path to Galera library\r\n</p>\r\n<p>\r\n	wsrep_provider=/usr/lib64/libgalera_smm.so\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster connection URL contains the IPs of node#1, node#2 and node#3\r\n</p>\r\n<p>\r\n	wsrep_cluster_address=gcomm://10.171.60.171,10.44.183.73,10.51.58.169\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# In order for Galera to work correctly binlog format should be ROW\r\n</p>\r\n<p>\r\n	binlog_format=ROW\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# MyISAM storage engine has only experimental support\r\n</p>\r\n<p>\r\n	default_storage_engine=InnoDB\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera\r\n</p>\r\n<p>\r\n	innodb_autoinc_lock_mode=2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Node #1 address\r\n</p>\r\n<p>\r\n	wsrep_node_address=10.171.60.171\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_method=xtrabackup-v2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster name\r\n</p>\r\n<p>\r\n	wsrep_cluster_name=my_centos_cluster\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Authentication for SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_auth=\"sstuser:s3cret\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动数据库（三个节点都要操作）：\r\n</p>\r\n<p>\r\n	node1的启动方式：\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# /etc/init.d/mysql bootstrap-pxc\r\n</p>\r\n<p>\r\n	.....................................................................\r\n</p>\r\n<p>\r\n	如果是centos7，则启动命令如下：\r\n</p>\r\n<p>\r\n	[root@percona1 ~]# systemctl start mysql@bootstrap.service\r\n</p>\r\n<p>\r\n	.....................................................................\r\n</p>\r\n<p>\r\n	若是重启的话，就先kill，然后删除pid文件后再执行上面的启动命令。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	配置数据库（三个节点都要操作）\r\n</p>\r\n<p>\r\n	mysql&gt; show status like \'wsrep%\';\r\n</p>\r\n<p>\r\n	+----------------------------+--------------------------------------+\r\n</p>\r\n<p>\r\n	| Variable_name              | Value                                |\r\n</p>\r\n<p>\r\n	+----------------------------+--------------------------------------+\r\n</p>\r\n<p>\r\n	.........\r\n</p>\r\n<p>\r\n	| wsrep_local_state          | 4                                    |\r\n</p>\r\n<p>\r\n	| wsrep_local_state_comment  | Synced                               |\r\n</p>\r\n<p>\r\n	| wsrep_cert_index_size      | 0                                    |\r\n</p>\r\n<p>\r\n	| wsrep_causal_reads         | 0                                    |\r\n</p>\r\n<p>\r\n	| wsrep_incoming_addresses   | 10.171.60.171:3306                   |      //集群中目前只有一个成员的ip\r\n</p>\r\n<p>\r\n	| wsrep_cluster_conf_id      | 1                                    |\r\n</p>\r\n<p>\r\n	| wsrep_cluster_size         | 1                                    |      //主要看这里，目前node2和node3还没有加入集群，所以集群成员目前只有一个\r\n</p>\r\n<p>\r\n	| wsrep_cluster_state_uuid   | 5dee8d6d-455f-11e7-afd8-ca25b704d994 |\r\n</p>\r\n<p>\r\n	| wsrep_cluster_status       | Primary                              |\r\n</p>\r\n<p>\r\n	| wsrep_connected            | ON                                   |\r\n</p>\r\n<p>\r\n	| wsrep_local_bf_aborts      | 0                                    |\r\n</p>\r\n<p>\r\n	| wsrep_local_index          | 0                                    |\r\n</p>\r\n<p>\r\n	| wsrep_provider_name        | Galera                               |\r\n</p>\r\n<p>\r\n	| wsrep_provider_vendor      | Codership Oy <info@codership.com>    |</info@codership.com>\r\n</p>\r\n<p>\r\n	| wsrep_provider_version     | 2.12(r318911d)                       |\r\n</p>\r\n<p>\r\n	| wsrep_ready                | ON                                   |\r\n</p>\r\n<p>\r\n	| wsrep_thread_count         | 2                                    |\r\n</p>\r\n<p>\r\n	+----------------------------+--------------------------------------+\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	数据库用户名密码的设置\r\n</p>\r\n<p>\r\n	mysql&gt; UPDATE mysql.user SET password=PASSWORD(\"Passw0rd\") where user=\'root\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	创建、授权、同步账号\r\n</p>\r\n<p>\r\n	mysql&gt; CREATE USER \'sstuser\'@\'localhost\' IDENTIFIED BY \'s3cret\';\r\n</p>\r\n<p>\r\n	mysql&gt; GRANT RELOAD, LOCK TABLES, REPLICATION CLIENT ON *.* TO \'sstuser\'@\'localhost\';\r\n</p>\r\n<p>\r\n	mysql&gt; FLUSH PRIVILEGES;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	................注意下面几个察看命令...............\r\n</p>\r\n<p>\r\n	mysql&gt; SHOW VARIABLES LIKE \'wsrep_cluster_address\';\r\n</p>\r\n<p>\r\n	#如果配置了指向集群地址，上面那个参数值，应该是你指定集群的IP地址\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# 此参数查看是否开启\r\n</p>\r\n<p>\r\n	mysql&gt; show status like \'wsrep_ready\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# 查看集群的成员数\r\n</p>\r\n<p>\r\n	mysql&gt; show status like \'wsrep_cluster_size\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# 这个查看wsrep的相关参数\r\n</p>\r\n<p>\r\n	mysql&gt; show status like \'wsrep%\';\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	4）那么node2和node3只需要配置my.cnf文件中的wsrep_node_address这个参数，将其修改为自己的ip地址即可。\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\r\n</p>\r\n<p>\r\n	node2节点的/etc/my.cnf配置\r\n</p>\r\n<p>\r\n	[root@percona2 ~]# cat /etc/my.cnf\r\n</p>\r\n<p>\r\n	[mysqld]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	datadir=/var/lib/mysql\r\n</p>\r\n<p>\r\n	user=mysql\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Path to Galera library\r\n</p>\r\n<p>\r\n	wsrep_provider=/usr/lib64/libgalera_smm.so\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster connection URL contains the IPs of node#1, node#2 and node#3\r\n</p>\r\n<p>\r\n	wsrep_cluster_address=gcomm://10.171.60.171,10.44.183.73,10.51.58.169\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# In order for Galera to work correctly binlog format should be ROW\r\n</p>\r\n<p>\r\n	binlog_format=ROW\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# MyISAM storage engine has only experimental support\r\n</p>\r\n<p>\r\n	default_storage_engine=InnoDB\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera\r\n</p>\r\n<p>\r\n	innodb_autoinc_lock_mode=2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Node #1 address\r\n</p>\r\n<p>\r\n	wsrep_node_address=10.44.183.73\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_method=xtrabackup-v2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster name\r\n</p>\r\n<p>\r\n	wsrep_cluster_name=my_centos_cluster\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Authentication for SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_auth=\"sstuser:s3cret\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\r\n</p>\r\n<p>\r\n	node3节点的/etc/my.cnf配置\r\n</p>\r\n<p>\r\n	[root@percona3 ~]# cat /etc/my.cnf\r\n</p>\r\n<p>\r\n	[mysqld]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	datadir=/var/lib/mysql\r\n</p>\r\n<p>\r\n	user=mysql\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Path to Galera library\r\n</p>\r\n<p>\r\n	wsrep_provider=/usr/lib64/libgalera_smm.so\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster connection URL contains the IPs of node#1, node#2 and node#3\r\n</p>\r\n<p>\r\n	wsrep_cluster_address=gcomm://10.171.60.171,10.44.183.73,10.51.58.169\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# In order for Galera to work correctly binlog format should be ROW\r\n</p>\r\n<p>\r\n	binlog_format=ROW\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# MyISAM storage engine has only experimental support\r\n</p>\r\n<p>\r\n	default_storage_engine=InnoDB\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera\r\n</p>\r\n<p>\r\n	innodb_autoinc_lock_mode=2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Node #1 address\r\n</p>\r\n<p>\r\n	wsrep_node_address=10.51.58.169\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_method=xtrabackup-v2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Cluster name\r\n</p>\r\n<p>\r\n	wsrep_cluster_name=my_centos_cluster\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	# Authentication for SST method\r\n</p>\r\n<p>\r\n	wsrep_sst_auth=\"sstuser:s3cret\"\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	node2和node3的启动方式：\r\n</p>\r\n<p>\r\n	[root@percona2 ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	..................................注意................................\r\n</p>\r\n<p>\r\n	-&gt; 除了名义上的master之外，其它的node节点只需要启动mysql即可。\r\n</p>\r\n<p>\r\n	-&gt; 节点的数据库的登陆和master节点的用户名密码一致，自动同步。所以其它的节点数据库用户名密码无须重新设置。\r\n</p>\r\n<p>\r\n	也就是说，如上设置，只需要在名义上的master节点（如上的node1）上设置权限，其它的节点配置好/etc/my.cnf后，只需要启动mysql就行，权限会自动同步过来。\r\n</p>\r\n<p>\r\n	如上的node2，node3节点，登陆mysql的权限是和node1一样的（即是用node1设置的权限登陆）\r\n</p>\r\n<p>\r\n	.....................................................................\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	如果上面的node2、node3启动mysql失败，比如/var/lib/mysql下的err日志报错如下：\r\n</p>\r\n<p>\r\n	[ERROR] WSREP: gcs/src/gcs_group.cpp:long int gcs_group_handle_join_msg(gcs_\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解决办法：\r\n</p>\r\n<p>\r\n	-&gt; 查看节点上的iptables防火墙是否关闭；检查到名义上的master节点上的4567端口是否连通（telnet）\r\n</p>\r\n<p>\r\n	-&gt; selinux是否关闭\r\n</p>\r\n<p>\r\n	-&gt; 删除名义上的master节点上的grastate.dat后，重启名义上的master节点的数据库；当然当前节点上的grastate.dat也删除并重启数据库\r\n</p>\r\n<p>\r\n	.....................................................................\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	5)最后进行测试\r\n</p>\r\n<p>\r\n	在任意一个node上，进行添加，删除，修改操作，都会同步到其他的服务器，是现在主主的模式，当然前提是表引擎必须是innodb，因为galera目前只支持innodb的表。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; show status like \'wsrep%\';\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	wsrep_local_state          | 4                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_local_state_comment  | Synced                                                 |\r\n</p>\r\n<p>\r\n	| wsrep_cert_index_size      | 2                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_causal_reads         | 0                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_incoming_addresses   | 10.44.183.73:3306,10.51.58.169:3306,10.171.60.171:3306 |\r\n</p>\r\n<p>\r\n	| wsrep_cluster_conf_id      | 9                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_cluster_size         | 3                                                      |     //集群成员是3个\r\n</p>\r\n<p>\r\n	| wsrep_cluster_state_uuid   | 92e43358-456d-11e7-af61-733b6b73c72c                   |\r\n</p>\r\n<p>\r\n	| wsrep_cluster_status       | Primary                                                |\r\n</p>\r\n<p>\r\n	| wsrep_connected            | ON                                                     |\r\n</p>\r\n<p>\r\n	| wsrep_local_bf_aborts      | 0                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_local_index          | 2                                                      |\r\n</p>\r\n<p>\r\n	| wsrep_provider_name        | Galera                                                 |\r\n</p>\r\n<p>\r\n	| wsrep_provider_vendor      | Codership Oy <info@codership.com>                      |</info@codership.com>\r\n</p>\r\n<p>\r\n	| wsrep_provider_version     | 2.12(r318911d)                                         |\r\n</p>\r\n<p>\r\n	| wsrep_ready                | ON                                                     |\r\n</p>\r\n<p>\r\n	| wsrep_thread_count         | 2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在node3上创建一个库\r\n</p>\r\n<p>\r\n	mysql&gt; create database wangshibo;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.02 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	然后在node1和node2上查看，自动同步过来\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	| wangshibo          |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在node1上的wangshibo库下创建表，插入数据\r\n</p>\r\n<p>\r\n	mysql&gt; use wangshibo;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table test(\r\n</p>\r\n<p>\r\n	-&gt; id int(5));\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.11 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; insert into test values(1);\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; insert into test values(2);\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.02 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	同样，在其它的节点上查看，也是能自动同步过来\r\n</p>\r\n<p>\r\n	mysql&gt; select * from wangshibo.test;\r\n</p>\r\n<p>\r\n	+------+\r\n</p>\r\n<p>\r\n	| id   |\r\n</p>\r\n<p>\r\n	+------+\r\n</p>\r\n<p>\r\n	|    1 |\r\n</p>\r\n<p>\r\n	|    2 |\r\n</p>\r\n<p>\r\n	+------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('df0a93b9-d6c9-4809-88f1-d1fb54dc508e','Mysql备份系列（2）--mysqldump备份（全量+增量）方案操作记录','Mysql备份系列（2）--mysqldump备份（全量+增量）方案操作记录','<p>\r\n	在日常运维工作中，对mysql数据库的备份是万分重要的，以防在数据库表丢失或损坏情况出现，可以及时恢复数据。\r\n</p>\r\n<p>\r\n	线上数据库备份场景：每周日执行一次全量备份，然后每天下午1点执行MySQLdump增量备份.\r\n</p>\r\n<p>\r\n	下面对这种备份方案详细说明下：1.MySQLdump增量备份配置执行增量备份的前提条件是MySQL打开binlog日志功能，在my.cnf中加入log-bin=/opt/Data/MySQL-bin“log-bin=”后的字符串为日志记载目录，一般建议放在不同于MySQL数据目录的磁盘上。\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	mysqldump &gt;       导出数据\r\n</p>\r\n<p>\r\n	mysql &lt; 导入数据 （或者使用source命令导入数据，导入前要先切换到对应库下）\r\n</p>\r\n<p>\r\n	注意一个细节：\r\n</p>\r\n<p>\r\n	若是mysqldump导出一个库的数据，导出文件为a.sql，然后mysql导入这个数据到新的空库下。\r\n</p>\r\n<p>\r\n	如果新库名和老库名不一致，那么需要将a.sql文件里的老库名改为新库名，\r\n</p>\r\n<p>\r\n	这样才能顺利使用mysql命令导入数据（如果使用source命令导入就不需要修改a.sql文件了）。\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2.MySQLdump增量备份假定星期日下午1点执行全量备份，适用于MyISAM存储引擎。[root@test-huanqiu ~]# MySQLdump --lock-all-tables --flush-logs --master-data=2 -u root -p test &gt; backup_sunday_1_PM.sql\r\n</p>\r\n<p>\r\n	对于InnoDB将--lock-all-tables替换为--single-transaction--flush-logs为结束当前日志，生成新日志文件；--master-data=2 选项将会在输出SQL中记录下完全备份后新日志文件的名称，\r\n</p>\r\n<p>\r\n	用于日后恢复时参考，例如输出的备份SQL文件中含有：CHANGE MASTER TO MASTER_LOG_FILE=’MySQL-bin.000002′, MASTER_LOG_POS=106;\r\n</p>\r\n<p>\r\n	3.MySQLdump增量备份其他说明：如果MySQLdump加上–delete-master-logs 则清除以前的日志，以释放空间。但是如果服务器配置为镜像的复制主服务器，用MySQLdump –delete-master-logs删掉MySQL二进制日志很危险，因为从服务器可能还没有完全处理该二进制日志的内容。在这种情况下，使用 PURGE MASTER LOGS更为安全。\r\n</p>\r\n<p>\r\n	每日定时使用 MySQLadmin flush-logs来创建新日志，并结束前一日志写入过程。并把前一日志备份，例如上例中开始保存数据目录下的日志文件 MySQL-bin.000002 , ...\r\n</p>\r\n<p>\r\n	1.恢复完全备份mysql -u root -p &lt; backup_sunday_1_PM.sql\r\n</p>\r\n<p>\r\n	2.恢复增量备份mysqlbinlog MySQL-bin.000002 … | MySQL -u root -p注意此次恢复过程亦会写入日志文件，如果数据量很大，建议先关闭日志功能\r\n</p>\r\n<p>\r\n	--compatible=name它告诉 MySQLdump，导出的数据将和哪种数据库或哪个旧版本的 MySQL 服务器相兼容。值可以为 ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等，要使用几个值，用逗号将它们隔开。当然了，它并不保证能完全兼容，而是尽量兼容。\r\n</p>\r\n<p>\r\n	--complete-insert，-c导出的数据采用包含字段名的完整 INSERT 方式，也就是把所有的值都写在一行。这么做能提高插入效率，但是可能会受到 max_allowed_packet 参数的影响而导致插入失败。因此，需要谨慎使用该参数，至少我不推荐。\r\n</p>\r\n<p>\r\n	--default-character-set=charset指定导出数据时采用何种字符集，如果数据表不是采用默认的 latin1 字符集的话，那么导出时必须指定该选项，否则再次导入数据后将产生乱码问题。\r\n</p>\r\n<p>\r\n	--disable-keys告诉 MySQLdump 在 INSERT 语句的开头和结尾增加 /*!40000 ALTER TABLE table DISABLE KEYS */; 和 /*!40000 ALTER TABLE table ENABLE KEYS */; 语句，这能大大提高插入语句的速度，因为它是在插入完所有数据后才重建索引的。该选项只适合 MyISAM 表。\r\n</p>\r\n<p>\r\n	--extended-insert = true|false默认情况下，MySQLdump 开启 --complete-insert 模式，因此不想用它的的话，就使用本选项，设定它的值为 false 即可。\r\n</p>\r\n<p>\r\n	--hex-blob使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用本选项。影响到的字段类型有 BINARY、VARBINARY、BLOB。\r\n</p>\r\n<p>\r\n	--lock-all-tables，-x在开始导出之前，提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭 --single-transaction 和 --lock-tables 选项。\r\n</p>\r\n<p>\r\n	--lock-tables它和 --lock-all-tables 类似，不过是锁定当前导出的数据表，而不是一下子锁定全部库下的表。本选项只适用于 MyISAM 表，如果是 Innodb 表可以用 --single-transaction 选项。\r\n</p>\r\n<p>\r\n	--no-create-info，-t只导出数据，而不添加 CREATE TABLE 语句。\r\n</p>\r\n<p>\r\n	--no-data，-d不导出任何数据，只导出数据库表结构。mysqldump --no-data --databases mydatabase1 mydatabase2 mydatabase3 &gt; test.dump将只备份表结构。--databases指示主机上要备份的数据库。\r\n</p>\r\n<p>\r\n	--opt这只是一个快捷选项，等同于同时添加 --add-drop-tables --add-locking --create-option --disable-keys --extended-insert --lock-tables --quick --set-charset 选项。本选项能让 MySQLdump 很快的导出数据，并且导出的数据能很快导回。该选项默认开启，但可以用 --skip-opt 禁用。注意，如果运行 MySQLdump 没有指定 --quick 或 --opt 选项，则会将整个结果集放在内存中。如果导出大数据库的话可能会出现问题。\r\n</p>\r\n<p>\r\n	--quick，-q该选项在导出大表时很有用，它强制 MySQLdump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中。\r\n</p>\r\n<p>\r\n	--routines，-R导出存储过程以及自定义函数。\r\n</p>\r\n<p>\r\n	--single-transaction该选项在导出数据之前提交一个 BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于事务表，例如 InnoDB 和 BDB。本选项和 --lock-tables 选项是互斥的，因为 LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用 --quick 选项。\r\n</p>\r\n<p>\r\n	--triggers同时导出触发器。该选项默认启用，用 --skip-triggers 禁用它。\r\n</p>\r\n<p>\r\n	跨主机备份使用下面的命令可以将host1上的sourceDb复制到host2的targetDb，前提是host2主机上已经创建targetDb数据库：-C 指示主机间的数据传输使用数据压缩mysqldump --host=host1 --opt sourceDb| mysql --host=host2 -C targetDb\r\n</p>\r\n<p>\r\n	结合Linux的cron命令实现定时备份比如需要在每天凌晨1:30备份某个主机上的所有数据库并压缩dump文件为gz格式30 1 * * * mysqldump -u root -pPASSWORD --all-databases | gzip &gt; /mnt/disk2/database_`date \'+%m-%d-%Y\'`.sql.gz\r\n</p>\r\n<p>\r\n	一个完整的Shell脚本备份MySQL数据库示例。比如备份数据库opspc[root@test-huanqiu ~]# vim /root/backup.sh#!bin/bashecho \"Begin backup mysql database\"mysqldump -u root -ppassword opspc &gt; /home/backup/mysqlbackup-`date +%Y-%m-%d`.sqlecho \"Your database backup successfully completed\"\r\n</p>\r\n<p>\r\n	[root@test-huanqiu ~]# crontab -e30 1 * * * /bin/bash -x /root/backup.sh &gt; /dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	mysqldump全量备份+mysqlbinlog二进制日志增量备份1）从mysqldump备份文件恢复数据会丢失掉从备份点开始的更新数据，所以还需要结合mysqlbinlog二进制日志增量备份。首先确保已开启binlog日志功能。在my.cnf中包含下面的配置以启用二进制日志：[mysqld]log-bin=mysql-bin\r\n</p>\r\n<p>\r\n	2）mysqldump命令必须带上--flush-logs选项以生成新的二进制日志文件：mysqldump --single-transaction --flush-logs --master-data=2 &gt; backup.sql其中参数--master-data=[0|1|2]0: 不记录1：记录为CHANGE MASTER语句2：记录为注释的CHANGE MASTER语句\r\n</p>\r\n<p>\r\n	mysqldump全量+增量备份方案的具体操作可参考下面两篇文档：数据库误删除后的数据恢复操作说明解说mysql之binlog日志以及利用binlog日志恢复数据\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------下面分享一下自己用过的mysqldump全量和增量备份脚本\r\n</p>\r\n<p>\r\n	应用场景：1）增量备份在周一到周六凌晨3点，会复制mysql-bin.00000*到指定目录；2）全量备份则使用mysqldump将所有的数据库导出，每周日凌晨3点执行，并会删除上周留下的mysq-bin.00000*，然后对mysql的备份操作会保留在bak.log文件中。\r\n</p>\r\n<p>\r\n	脚本实现：1）全量备份脚本（假设mysql登录密码为123456；注意脚本中的命令路径）：[root@test-huanqiu ~]# vim /root/Mysql-FullyBak.sh#!/bin/bash# Program# use mysqldump to Fully backup mysql data per week!# History# PathBakDir=/home/mysql/backupLogFile=/home/mysql/backup/bak.logDate=`date +%Y%m%d`Begin=`date +\"%Y年%m月%d日 %H:%M:%S\"`cd $BakDirDumpFile=$Date.sqlGZDumpFile=$Date.sql.tgz/usr/local/mysql/bin/mysqldump -uroot -p123456 --quick --events --all-databases --flush-logs --delete-master-logs --single-transaction &gt; $DumpFile/bin/tar -zvcf $GZDumpFile $DumpFile/bin/rm $DumpFileLast=`date +\"%Y年%m月%d日 %H:%M:%S\"`echo 开始:$Begin 结束:$Last $GZDumpFile succ &gt;&gt; $LogFilecd $BakDir/daily/bin/rm -f *\r\n</p>\r\n<p>\r\n	2）增量备份脚本（脚本中mysql的数据存放路径是/home/mysql/data，具体根据自己的实际情况进行调整）[root@test-huanqiu ~]# vim /root/Mysql-DailyBak.sh#!/bin/bash# Program# use cp to backup mysql data everyday!# History# PathBakDir=/home/mysql/backup/daily &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //增量备份时复制mysql-bin.00000*的目标目录，提前手动创建这个目录BinDir=/home/mysql/data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //mysql的数据目录LogFile=/home/mysql/backup/bak.logBinFile=/home/mysql/data/mysql-bin.index &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //mysql的index文件路径，放在数据目录下的/usr/local/mysql/bin/mysqladmin -uroot -p123456 flush-logs#这个是用于产生新的mysql-bin.00000*文件Counter=`wc -l $BinFile |awk \'{print $1}\'`NextNum=0#这个for循环用于比对$Counter,$NextNum这两个值来确定文件是不是存在或最新的for file in  `cat $BinFile`do&nbsp; &nbsp; base=`basename $file`&nbsp; &nbsp; #basename用于截取mysql-bin.00000*文件名，去掉./mysql-bin.000005前面的./&nbsp; &nbsp; NextNum=`expr $NextNum + 1`&nbsp; &nbsp; if [ $NextNum -eq $Counter ]&nbsp; &nbsp; then&nbsp; &nbsp; &nbsp; &nbsp; echo $base skip!  &gt;&gt; $LogFile&nbsp; &nbsp; else&nbsp; &nbsp; &nbsp; &nbsp; dest=$BakDir/$base&nbsp; &nbsp; &nbsp; &nbsp; if(test -e $dest)&nbsp; &nbsp; &nbsp; &nbsp; #test -e用于检测目标文件是否存在，存在就写exist!到$LogFile去&nbsp; &nbsp; &nbsp; &nbsp; then&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo  $base exist! &gt;&gt; $LogFile&nbsp; &nbsp; &nbsp; &nbsp; else&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp $BinDir/$base $BakDir&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $base copying &gt;&gt; $LogFile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi&nbsp; &nbsp; &nbsp;fidoneecho `date +\"%Y年%m月%d日 %H:%M:%S\"` $Next Bakup succ! &gt;&gt; $LogFile\r\n</p>\r\n<p>\r\n	3）设置crontab任务，执行备份脚本。先执行的是增量备份脚本，然后执行的是全量备份脚本：[root@test-huanqiu ~]# crontab -e#每个星期日凌晨3:00执行完全备份脚本0 3 * * 0 /bin/bash -x /root/Mysql-FullyBak.sh &gt;/dev/null 2&gt;&amp;1#周一到周六凌晨3:00做增量备份0 3 * * 1-6 /bin/bash -x /root/Mysql-DailyBak.sh &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	4）手动执行上面两个脚本，测试下备份效果[root@test-huanqiu backup]# pwd/home/mysql/backup[root@test-huanqiu backup]# mkdir daily[root@test-huanqiu backup]# lltotal 4drwxr-xr-x. 2 root root 4096 Nov 29 11:29 daily[root@test-huanqiu backup]# ll daily/total 0\r\n</p>\r\n<p>\r\n	先执行增量备份脚本[root@test-huanqiu backup]# sh /root/Mysql-DailyBak.sh [root@test-huanqiu backup]# lltotal 8-rw-r--r--. 1 root root  121 Nov 29 11:29 bak.logdrwxr-xr-x. 2 root root 4096 Nov 29 11:29 daily[root@test-huanqiu backup]# ll daily/total 8-rw-r-----. 1 root root 152 Nov 29 11:29 mysql-binlog.000030-rw-r-----. 1 root root 152 Nov 29 11:29 mysql-binlog.000031[root@test-huanqiu backup]# cat bak.log mysql-binlog.000030 copyingmysql-binlog.000031 copyingmysql-binlog.000032 skip!2016年11月29日 11:29:32 Bakup succ!\r\n</p>\r\n<p>\r\n	然后执行全量备份脚本[root@test-huanqiu backup]# sh /root/Mysql-FullyBak.sh 20161129.sql[root@test-huanqiu backup]# lltotal 152-rw-r--r--. 1 root root 145742 Nov 29 11:30 20161129.sql.tgz-rw-r--r--. 1 root root    211 Nov 29 11:30 bak.logdrwxr-xr-x. 2 root root   4096 Nov 29 11:30 daily[root@test-huanqiu backup]# ll daily/total 0[root@test-huanqiu backup]# cat bak.log mysql-binlog.000030 copyingmysql-binlog.000031 copyingmysql-binlog.000032 skip!2016年11月29日 11:29:32 Bakup succ!开始:2016年11月29日 11:30:38 结束:2016年11月29日 11:30:38 20161129.sql.tgz succ\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('e2aa5c7e-bd0b-406f-91be-5a4a32fc0269','Mysql双主热备+LVS+Keepalived高可用操作记录','Mysql双主热备+LVS+Keepalived高可用操作记录','<p>\r\n	MySQL复制能够保证数据的冗余的同时可以做读写分离来分担系统压力，如果是主主复制还可以很好的避免主节点的单点故障。然而MySQL主主复制存在一些问题无法满足我们的实际需要：未提供统一访问入口来实现负载均衡，如果其中master宕掉的话需要手动切换到另外一个master，而不能自动进行切换。前面介绍了Mysql+Keepalived双主热备高可用方案记录，那篇文档里没有使用到LVS（实现负载均衡），而下面要介绍的就是如何通过Keepalived+LVS方式来是实现MySQL的高可用性，利用LVS实现MySQL的读写负载均衡，Keepalived避免节点出现单点故障，同时解决以上问题。\r\n</p>\r\n<p>\r\n	Keepalived是一个基于VRRP（虚拟路由冗余协议）可用来实现服务高可用性的软件方案，避免出现单点故障。Keepalived一般用来实现轻量级高可用性，且不需要共享存储，一般用于两个节点之间，常见有LVS+Keepalived、Nginx+Keepalived组合。\r\n</p>\r\n<p>\r\n	LVS(Linux Virtual Server)是一个高可用性虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。LVS主要用于多服务器的负载均衡，作用于网络层。LVS构建的服务器集群系统中，前端的负载均衡层被称为Director Server；后端提供服务的服务器组层被称为Real Server。通过下图可以大致了解LVS的基础架构。\r\n</p>\r\n<p>\r\n	LVS有三种工作模式，分别是：1）DR（Direct Routing 直接路由）模式。 DR可以支持相当多的Real Server，但需要保证Director Server（分发器）虚拟网卡与物理网卡在同一网段，并且后端Real Server的vip要建立在本地回环口lo设备上，这样做是为了防止ip冲突；DR模式的好处是进站流量经过Director Server，出站流量不经过Director Server，减轻了Director Server的负载压力。2）NAT（Network Address Translation 网络地址转换）模式。NAT扩展性有限，无法支持更多的Real Server，因为所有的请求包和应答包都需要Director Server进行解析再生，这样就很影响效率。 3）TUN(Tunneling IP隧道）模式。TUN模式能够支持更多的Real Server，但需要所有服务器支持IP隧道协议；\r\n</p>\r\n<p>\r\n	LVS负载均衡有10中调度算法，分别是：rr（轮询）、wrr（加权轮询）、lc、wlc、lblc、lblcr、dh、sh、sed、nq\r\n</p>\r\n<p>\r\n	以下详细记录了Mysql在主主同步环境下，利用LVS实现Mysql的读写负责均衡以及使用Keepalived心跳测试避免节点出现单点故障，实现故障转移的高可用。1）高可用方案的环境准备\r\n</p>\r\n<p>\r\n	LVS_Master：           182.148.15.237\r\n</p>\r\n<p>\r\n	LVS_Backup：           182.148.15.236\r\n</p>\r\n<p>\r\n	MySQL1 Real Server：   182.148.15.233\r\n</p>\r\n<p>\r\n	MySQL2 Real Server：   182.148.15.238\r\n</p>\r\n<p>\r\n	VIP：                  182.148.15.239\r\n</p>\r\n<p>\r\n	OS:                    CentOS 6.8\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	温馨提示：LVS_Master和LVS_Backup充当的是Director Server分发器的角色。\r\n</p>\r\n<p>\r\n	这里的LVS采用DR模式，即\"进站流量经过Director Server分发器，出站流量不经过分发器\"，这就要求：\r\n</p>\r\n<p>\r\n	1）LVS_Master和LVS_Backup需要将VIP绑定在其正常提供服务的网卡上（这里指182.48.115.0网段所在的网卡），netmask和对于网卡设备一致。\r\n</p>\r\n<p>\r\n	2）后端的Real Server要在本地回环口lo上绑定vip（防止ip冲突）\r\n</p>\r\n<p>\r\n	2）环境部署记录如下a）Mysql主主热备环境部署   MySQL1 Real Server1和MySQL2 Real Server的主主热备可以参考Mysql+Keepalived双主热备高可用操作记录中对应部分。\r\n</p>\r\n<p>\r\n	b）Keepalived安装LVS_Master和LVS_Backup的keepalived安装，也可以参考Mysql+Keepalived双主热备高可用操作记录中对应部分。\r\n</p>\r\n<p>\r\n	c）LVS安装\r\n</p>\r\n<p>\r\n	LVS_Master和LVS_Backup两台机器安装步骤一样\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	先下载ipvsadm\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# cd /usr/local/src/\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	需要安装以下软件包\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# yum install -y libnl* popt*\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看是否加载lvs模块\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# modprobe -l |grep ipvs\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	解压安装\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# ln -s /usr/src/kernels/2.6.32-431.5.1.el6.x86_64/ /usr/src/linux\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# tar -zxvf ipvsadm-1.26.tar.gz\r\n</p>\r\n<p>\r\n	[root@LVS_Master src]# cd ipvsadm-1.26\r\n</p>\r\n<p>\r\n	[root@LVS_Master ipvsadm-1.26]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	LVS安装完成，查看当前LVS集群\r\n</p>\r\n<p>\r\n	[root@LVS_Master ipvsadm-1.26]# ipvsadm -L -n\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	d）在Direct Server机器上绑定VIP（Haproxy或Nginx+Keepalived的七层负载均衡的高可用环境中，VIP就直接在 Keepalived 的配置文件里配置就好，使用命令 ip addr 就能看出 vip；但是LVS+Keepalived 四层负载均衡的高可用环境中， vip必须要在外面单独设置的（即ifconfig eth0:0 ....的方式创建vip），通过 ifconfig 可以查看出来 vip。）\r\n</p>\r\n<p>\r\n	这里的LVS_Master和LVS_Backup只有一个提供服务，所以只需要在LVS_Master上绑定VIP。\r\n</p>\r\n<p>\r\n	当LVS_Master出现故障时，VIP资源会自动漂到LVS_Backup上，转而由LVS_Backup提供服务。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:68:DC:B6\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.237  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe68:dcb6/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:600603 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:12972 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:94524601 (90.1 MiB)  TX bytes:1136665 (1.0 MiB)\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ifconfig eth0:0 182.148.15.239 broadcast 182.148.15.255 netmask 255.255.255.224 up\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# route add -host 182.148.15.239 dev eth0:0\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:68:DC:B6\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.237  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe68:dcb6/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:601975 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:13178 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:94697091 (90.3 MiB)  TX bytes:1161185 (1.1 MiB)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	eth0:0    Link encap:Ethernet  HWaddr 52:54:00:68:DC:B6\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.239  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	e）编写LVS启动脚本/etc/init.d/realserver\r\n</p>\r\n<p>\r\n	1）在MySQL1 Real Server服务器上的操作\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# vim /etc/init.d/realserver\r\n</p>\r\n<p>\r\n	#!/bin/sh\r\n</p>\r\n<p>\r\n	VIP=182.148.15.239\r\n</p>\r\n<p>\r\n	. /etc/rc.d/init.d/functions\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	case \"$1\" in\r\n</p>\r\n<p>\r\n	# 禁用本地的ARP请求、绑定本地回环地址\r\n</p>\r\n<p>\r\n	start)\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo down\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo up\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/all/arp_announce\r\n</p>\r\n<p>\r\n	/sbin/sysctl -p &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo:0 $VIP netmask 255.255.255.255 up #在回环地址上绑定VIP，设定掩码，与Direct Server（自身）上的IP保持通信\r\n</p>\r\n<p>\r\n	/sbin/route add -host $VIP dev lo:0\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server starts successfully.\\n\"\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	stop)\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo:0 down\r\n</p>\r\n<p>\r\n	/sbin/route del $VIP &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/all/arp_announce\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server stopped.\\n\"\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	status)\r\n</p>\r\n<p>\r\n	isLoOn=`/sbin/ifconfig lo:0 | grep \"$VIP\"`\r\n</p>\r\n<p>\r\n	isRoOn=`/bin/netstat -rn | grep \"$VIP\"`\r\n</p>\r\n<p>\r\n	if [ \"$isLoON\" == \"\" -a \"$isRoOn\" == \"\" ]; then\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server has run yet.\"\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server is running.\"\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	exit 3\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	*)\r\n</p>\r\n<p>\r\n	echo \"Usage: $0 {start|stop|status}\"\r\n</p>\r\n<p>\r\n	exit 1\r\n</p>\r\n<p>\r\n	esac\r\n</p>\r\n<p>\r\n	exit 0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	将lvs脚本加入开机自启动\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# chmod +x /etc/init.d/realserver\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# echo \"/etc/init.d/realserver\" &gt;&gt; /etc/rc.d/rc.local\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动LVS脚本\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# service realserver start\r\n</p>\r\n<p>\r\n	LVS-DR real server starts successfully.\\n\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看MySQL1 Real Server服务器，发现VIP已经成功绑定到本地回环口lo上了\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:D1:27:75\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.233  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fed1:2775/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:598406 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:12050 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:78790653 (75.1 MiB)  TX bytes:33151764 (31.6 MiB)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lo        Link encap:Local Loopback\r\n</p>\r\n<p>\r\n	inet addr:127.0.0.1  Mask:255.0.0.0\r\n</p>\r\n<p>\r\n	inet6 addr: ::1/128 Scope:Host\r\n</p>\r\n<p>\r\n	UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:483 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:483 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:0\r\n</p>\r\n<p>\r\n	RX bytes:55807 (54.4 KiB)  TX bytes:55807 (54.4 KiB)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lo:0      Link encap:Local Loopback\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.239  Mask:255.255.255.255\r\n</p>\r\n<p>\r\n	UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）在MySQL2 Real Server服务器上的操作\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# vim /etc/init.d/realserver       //这个脚本在后端Real Server上都是一样的内容\r\n</p>\r\n<p>\r\n	#!/bin/sh\r\n</p>\r\n<p>\r\n	VIP=182.148.15.239\r\n</p>\r\n<p>\r\n	. /etc/rc.d/init.d/functions\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	case \"$1\" in\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	start)\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo down\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo up\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/all/arp_announce\r\n</p>\r\n<p>\r\n	/sbin/sysctl -p &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo:0 $VIP netmask 255.255.255.255 up\r\n</p>\r\n<p>\r\n	/sbin/route add -host $VIP dev lo:0\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server starts successfully.\\n\"\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	stop)\r\n</p>\r\n<p>\r\n	/sbin/ifconfig lo:0 down\r\n</p>\r\n<p>\r\n	/sbin/route del $VIP &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce\r\n</p>\r\n<p>\r\n	echo \"1\" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore\r\n</p>\r\n<p>\r\n	echo \"2\" &gt;/proc/sys/net/ipv4/conf/all/arp_announce\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server stopped.\\n\"\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	status)\r\n</p>\r\n<p>\r\n	isLoOn=`/sbin/ifconfig lo:0 | grep \"$VIP\"`\r\n</p>\r\n<p>\r\n	isRoOn=`/bin/netstat -rn | grep \"$VIP\"`\r\n</p>\r\n<p>\r\n	if [ \"$isLoON\" == \"\" -a \"$isRoOn\" == \"\" ]; then\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server has run yet.\"\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	echo \"LVS-DR real server is running.\"\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	exit 3\r\n</p>\r\n<p>\r\n	;;\r\n</p>\r\n<p>\r\n	*)\r\n</p>\r\n<p>\r\n	echo \"Usage: $0 {start|stop|status}\"\r\n</p>\r\n<p>\r\n	exit 1\r\n</p>\r\n<p>\r\n	esac\r\n</p>\r\n<p>\r\n	exit 0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	将lvs脚本加入开机自启动并启动lvs脚本\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# chmod +x /etc/init.d/realserver\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# echo \"/etc/init.d/realserver\" &gt;&gt; /etc/rc.d/rc.local\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# service realserver start\r\n</p>\r\n<p>\r\n	LVS-DR real server starts successfully.\\n\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:3B:33:8F\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.238  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe3b:338f/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:135305 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:11256 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:17338566 (16.5 MiB)  TX bytes:892363 (871.4 KiB)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lo        Link encap:Local Loopback\r\n</p>\r\n<p>\r\n	inet addr:127.0.0.1  Mask:255.0.0.0\r\n</p>\r\n<p>\r\n	inet6 addr: ::1/128 Scope:Host\r\n</p>\r\n<p>\r\n	UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:0 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:0\r\n</p>\r\n<p>\r\n	RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lo:0      Link encap:Local Loopback\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.239  Mask:255.255.255.255\r\n</p>\r\n<p>\r\n	UP LOOPBACK RUNNING  MTU:65536  Metric:1\r\n</p>\r\n<p>\r\n	f）配置iptables防火墙\r\n</p>\r\n<p>\r\n	1）后端两台机器MySQL1 Real Server和MySQL2 Real Server要在iptables里开放3306端口\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# vim /etc/sysconfig/iptables\r\n</p>\r\n<p>\r\n	......\r\n</p>\r\n<p>\r\n	-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@MySQL1 ~]# /etc/init.d/iptables restart\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）LVS_Master和LVS_Backup两台机器要在iptables开放VRRP组播地址的相关规则。\r\n</p>\r\n<p>\r\n	注意：这个一定要设置！！！否则会出现故障时的VIP资源漂移错乱问题！\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# vim /etc/sysconfig/iptables       //两台LVS机器都要设置\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	-A INPUT -s 182.148.15.0/24 -d 224.0.0.18 -j ACCEPT        //允许组播地址通信\r\n</p>\r\n<p>\r\n	-A INPUT -s 182.148.15.0/24 -p vrrp -j ACCEPT              //允许VRRP（虚拟路由器冗余协）通信\r\n</p>\r\n<p>\r\n	-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# /etc/init.d/iptables restart\r\n</p>\r\n<p>\r\n	3）接着配置LVS+Keepalived配置\r\n</p>\r\n<p>\r\n	1）LVS_Master上的操作\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	router_id LVS_Master\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state MASTER               #指定instance初始状态，实际根据优先级决定.backup节点不一样\r\n</p>\r\n<p>\r\n	interface eth0             #虚拟IP所在网\r\n</p>\r\n<p>\r\n	virtual_router_id 51       #VRID，相同VRID为一个组，决定多播MAC地址\r\n</p>\r\n<p>\r\n	priority 100               #优先级，另一台改为90.backup节点不一样\r\n</p>\r\n<p>\r\n	advert_int 1               #检查间隔\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS         #认证方式，可以是pass或ha\r\n</p>\r\n<p>\r\n	auth_pass 1111         #认证密码\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.148.15.239         #VIP\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	virtual_server 182.148.15.239 3306 {\r\n</p>\r\n<p>\r\n	delay_loop 6               #服务轮询的时间间隔\r\n</p>\r\n<p>\r\n	lb_algo wrr                #加权轮询调度，LVS调度算法 rr|wrr|lc|wlc|lblc|sh|sh\r\n</p>\r\n<p>\r\n	lb_kind DR                 #LVS集群模式 NAT|DR|TUN，其中DR模式要求负载均衡器网卡必须有一块与物理网卡在同一个网段\r\n</p>\r\n<p>\r\n	#nat_mask 255.255.255.0\r\n</p>\r\n<p>\r\n	persistence_timeout 50     #会话保持时间\r\n</p>\r\n<p>\r\n	protocol TCP              #健康检查协议\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	## Real Server设置，3306就是MySQL连接端口\r\n</p>\r\n<p>\r\n	real_server 182.148.15.233 3306 {\r\n</p>\r\n<p>\r\n	weight 3  ##权重\r\n</p>\r\n<p>\r\n	TCP_CHECK {\r\n</p>\r\n<p>\r\n	connect_timeout 3\r\n</p>\r\n<p>\r\n	nb_get_retry 3\r\n</p>\r\n<p>\r\n	delay_before_retry 3\r\n</p>\r\n<p>\r\n	connect_port 3306\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	real_server 182.148.15.238 3306 {\r\n</p>\r\n<p>\r\n	weight 3\r\n</p>\r\n<p>\r\n	TCP_CHECK {\r\n</p>\r\n<p>\r\n	connect_timeout 3\r\n</p>\r\n<p>\r\n	nb_get_retry 3\r\n</p>\r\n<p>\r\n	delay_before_retry 3\r\n</p>\r\n<p>\r\n	connect_port 3306\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动keepalived\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	Starting keepalived:                                       [  OK  ]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	注意此时网卡的变化，可以看到虚拟网卡已经分配到了realserver上。\r\n</p>\r\n<p>\r\n	此时查看LVS集群状态，可以看到集群下有两个Real Server，调度算法，权重等信息。ActiveConn代表当前Real Server的活跃连接数。\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ipvsadm -ln\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	TCP  182.148.15.239:3306 wrr persistent 50\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.233:3306          Route   3      1          0\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.238:3306          Route   3      0          0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2）LVS_Backup上的操作\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	router_id LVS_Backup\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface eth0\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 90\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.148.15.239\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	virtual_server 182.148.15.239 3306 {\r\n</p>\r\n<p>\r\n	delay_loop 6\r\n</p>\r\n<p>\r\n	lb_algo wrr\r\n</p>\r\n<p>\r\n	lb_kind DR\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	persistence_timeout 50\r\n</p>\r\n<p>\r\n	protocol TCP\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	real_server 182.148.15.233 3306 {\r\n</p>\r\n<p>\r\n	weight 3\r\n</p>\r\n<p>\r\n	TCP_CHECK {\r\n</p>\r\n<p>\r\n	connect_timeout 3\r\n</p>\r\n<p>\r\n	nb_get_retry 3\r\n</p>\r\n<p>\r\n	delay_before_retry 3\r\n</p>\r\n<p>\r\n	connect_port 3306\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	real_server 182.148.15.238 3306 {\r\n</p>\r\n<p>\r\n	weight 3\r\n</p>\r\n<p>\r\n	TCP_CHECK {\r\n</p>\r\n<p>\r\n	connect_timeout 3\r\n</p>\r\n<p>\r\n	nb_get_retry 3\r\n</p>\r\n<p>\r\n	delay_before_retry 3\r\n</p>\r\n<p>\r\n	connect_port 3306\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	启动keepalived\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	Starting keepalived:                                       [  OK  ]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# ipvsadm -ln\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	TCP  182.148.15.239:3306 wrr persistent 50\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.233:3306          Route   3      0          0\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.238:3306          Route   3      0          0\r\n</p>\r\n<p>\r\n	此时LVS+Keepalived+MySQL主主复制已经搭建完成。\r\n</p>\r\n<p>\r\n	4）最后进行测试验证\r\n</p>\r\n<p>\r\n	1）先进行功能性验证\r\n</p>\r\n<p>\r\n	a）关闭MySQL2 Real Server服务器上的mysql\r\n</p>\r\n<p>\r\n	[root@MySQL2 ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在LVS_Master查看/var/log/messages中关于keepalived日志，LVS_Master检测到了MySQL2 Real Server服务器宕机，同时LVS集群自动剔除了故障节点\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	Apr 26 15:22:19 test3-237 Keepalived_healthcheckers[4606]: TCP connection to [182.148.15.238]:3306 failed.\r\n</p>\r\n<p>\r\n	Apr 26 15:22:19 test3-237 Keepalived_vrrp[4608]: Sending gratuitous ARP on eth0 for 182.148.15.239\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ipvsadm -ln         //LVS已经将MySQL2 Real Server剔除\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	TCP  182.148.15.239:3306 wrr persistent 50\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.233:3306          Route   3      1          0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	从新启动MySQL2 Real Server后自动将故障节点自动加入LVS集群\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	Apr 26 15:23:49 test3-237 Keepalived_healthcheckers[4606]: TCP connection to [182.148.15.238]:3306 success.\r\n</p>\r\n<p>\r\n	Apr 26 15:23:49 test3-237 Keepalived_healthcheckers[4606]: Adding service [182.148.15.238]:3306 to VS [182.148.15.239]:3306\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ipvsadm -ln\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	TCP  182.148.15.239:3306 wrr persistent 50\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.233:3306          Route   3      1          0\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.238:3306          Route   3      1          0\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	b）关闭LVS_Master上的Keepalived（模拟宕机操作），查看LVS_Master上的日志，可以看到Keepalived移出了LVS1上的VIP\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# /etc/init.d/keepalived stop\r\n</p>\r\n<p>\r\n	Stopping keepalived:                                       [  OK  ]\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived[4976]: Stopping\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived_vrrp[4979]: VRRP_Instance(VI_1) sent 0 priority\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived_vrrp[4979]: VRRP_Instance(VI_1) removing protocol VIPs.\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived_healthcheckers[4977]: Removing service [182.148.15.233]:3306 from VS [182.148.15.239]:3306\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived_healthcheckers[4977]: Removing service [182.148.15.238]:3306 from VS [182.148.15.239]:3306\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 Keepalived_healthcheckers[4977]: Stopped\r\n</p>\r\n<p>\r\n	Apr 26 15:29:38 test3-237 kernel: IPVS: __ip_vs_del_service: enter\r\n</p>\r\n<p>\r\n	Apr 26 15:29:39 test3-237 Keepalived_vrrp[4979]: Stopped\r\n</p>\r\n<p>\r\n	Apr 26 15:29:39 test3-237 Keepalived[4976]: Stopped Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ip addr    //发现VIP资源已经不在本机了\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:68:dc:b6 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.239/27 brd 182.148.15.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe68:dcb6/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	同时查看LVS_Backup上日志，可以看到LVS_Backup成为了Master，并接管了VIP\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	.....\r\n</p>\r\n<p>\r\n	Apr 26 15:26:41 test4-236 Keepalived_vrrp[4711]: VRRP_Instance(VI_1) Transition to MASTER STATE\r\n</p>\r\n<p>\r\n	Apr 26 15:26:42 test4-236 Keepalived_vrrp[4711]: VRRP_Instance(VI_1) Entering MASTER STATE\r\n</p>\r\n<p>\r\n	Apr 26 15:26:42 test4-236 Keepalived_vrrp[4711]: VRRP_Instance(VI_1) setting protocol VIPs.\r\n</p>\r\n<p>\r\n	Apr 26 15:26:42 test4-236 Keepalived_vrrp[4711]: Sending gratuitous ARP on eth0 for 182.148.15.239\r\n</p>\r\n<p>\r\n	Apr 26 15:26:42 test4-236 Keepalived_vrrp[4711]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.239\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# ip addr         //发现VIP资源已经转移到LVS_Backup机器上了\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:90:ac:0f brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.239/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe90:ac0f/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	在LVS_Backup上查看LVS集群状态，一切正常。\r\n</p>\r\n<p>\r\n	[root@LVS_Backup ~]# ipvsadm -ln\r\n</p>\r\n<p>\r\n	IP Virtual Server version 1.2.1 (size=4096)\r\n</p>\r\n<p>\r\n	Prot LocalAddress:Port Scheduler Flags\r\n</p>\r\n<p>\r\n	-&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn\r\n</p>\r\n<p>\r\n	TCP  182.148.15.239:3306 wrr persistent 50\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.233:3306          Route   3      0          0\r\n</p>\r\n<p>\r\n	-&gt; 182.148.15.238:3306          Route   3      1          1\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	接着恢复LVS_Master上的Keepalived，发现VIP资源又会重新从LVS_Backup上转移回来。即LVS_Master重新接管服务。\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	Apr 26 15:37:14 test3-237 Keepalived_vrrp[5263]: VRRP_Instance(VI_1) Transition to MASTER STATE\r\n</p>\r\n<p>\r\n	Apr 26 15:37:15 test3-237 Keepalived_vrrp[5263]: VRRP_Instance(VI_1) Entering MASTER STATE\r\n</p>\r\n<p>\r\n	Apr 26 15:37:15 test3-237 Keepalived_vrrp[5263]: VRRP_Instance(VI_1) setting protocol VIPs.\r\n</p>\r\n<p>\r\n	Apr 26 15:37:15 test3-237 Keepalived_vrrp[5263]: Sending gratuitous ARP on eth0 for 182.148.15.239\r\n</p>\r\n<p>\r\n	Apr 26 15:37:15 test3-237 Keepalived_vrrp[5263]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.239\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	[root@LVS_Master ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:68:dc:b6 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.239/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.239/27 brd 182.148.15.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe68:dcb6/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	-----------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	2）接着进行mysql主主热备的高可用\r\n</p>\r\n<p>\r\n	在MySQL1 Real Server和MySQL2 Real Server两台机器的mysql里授权，使远程客户机能正常连接。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; grant all on *.* to test@\'%\' identified by \"123456\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.03 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	经测试发现，对于上面的功能验证，不管是LVS_Master的keepalived关闭（宕机）还是后端MySQL2 Real Serve的mysql关闭，在远程客户机上都能正常连接mysql（通过VIP进行连接）（LVS_Master的keepalived关闭时，如若远程客户机在连接mysql中，可以断开重新连接一次即可）\r\n</p>\r\n<p>\r\n	[root@bastion-IDC ~]# mysql -h182.148.15.239 -utest -p123456\r\n</p>\r\n<p>\r\n	Welcome to the MySQL monitor.  Commands end with ; or \\g.\r\n</p>\r\n<p>\r\n	Your MySQL connection id is 856\r\n</p>\r\n<p>\r\n	Server version: 5.6.34-log Source distribution\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Oracle is a registered trademark of Oracle Corporation and/or its\r\n</p>\r\n<p>\r\n	affiliates. Other names may be trademarks of their respective\r\n</p>\r\n<p>\r\n	owners.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Type \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | wangshibo |\r\n</p>\r\n<p>\r\n	|  2 | guohuihui |\r\n</p>\r\n<p>\r\n	| 22 | huihui    |\r\n</p>\r\n<p>\r\n	| 23 | bobo      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	总结几点：1）MySQL主主复制是集群的基础，组成Server Array，其中每个节点作为Real Server。2）LVS服务器提供了负载均衡的作用，将用户请求分发到Real Server，一台Real Server故障并不会影响整个集群的。3）Keepalived搭建主备LVS服务器，避免了LVS服务器的单点故障，出现故障时可以自动切换到正常的节点。4）VRRP虚拟IP地址和接口实际IP必须在同一个网段内，VRRP两个实际接口不在同一网段，是不能形成主备关系的。因为：\r\n</p>\r\n<p>\r\n	VRRP的形式是组播（多播），这个和广播基本一个原理，只不过缩小了范围，让几个服务器能收到，众所周知广播必须在2层里面实现，出3层就出了广播域了。\r\n</p>\r\n<p>\r\n	VRRP中的ip切换是靠arp欺骗实现的，否则vip从主切到备得断多少机器，arp欺骗也是没法在出了3层以外的2个机器直接做的。\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('e9ed0ea4-dd40-4a5b-bff3-169412864502','mysql数据库误删除后的数据恢复操作说明','mysql数据库误删除后的数据恢复操作说明','<p>\r\n	在日常运维工作中，对于mysql数据库的备份是至关重要的！数据库对于网站的重要性使得我们对mysql数据的管理不容有失！然后，是人总难免会犯错误，说不定哪天大脑短路了来个误操作把数据库给删除了，怎么办？？？\r\n</p>\r\n<p>\r\n	下面，就mysql数据库误删除后的恢复方案进行说明。\r\n</p>\r\n<p>\r\n	一、工作场景（1）MySQL数据库每晚12:00自动完全备份。（2）某天早上上班，9点的时候，一同事犯晕drop了一个数据库！（3）需要紧急恢复！可利用备份的数据文件以及增量的binlog文件进行数据恢复。\r\n</p>\r\n<p>\r\n	二、数据恢复思路（1）利用全备的sql文件中记录的CHANGE MASTER语句，binlog文件及其位置点信息，找出binlog文件中增量的那部分。（2）用mysqlbinlog命令将上述的binlog文件导出为sql文件，并剔除其中的drop语句。（3）通过全备文件和增量binlog文件的导出sql文件，就可以恢复到完整的数据。\r\n</p>\r\n<p>\r\n	三、实例说明----------------------------------------首先，要确保mysql开启了binlog日志功能在/etc/my.cnf文件里的[mysqld]区块添加：log-bin=mysql-bin然后重启mysql服务----------------------------------------\r\n</p>\r\n<p>\r\n	（1）在ops库下创建一张表customers\r\n</p>\r\n<p>\r\n	mysql&gt; use ops;mysql&gt; create table customers(    -&gt; id int not null auto_increment,    -&gt; name char(20) not null,    -&gt; age int not null,    -&gt; primary key(id)    -&gt; )engine=InnoDB;Query OK, 0 rows affected (0.09 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;+---------------+| Tables_in_ops |+---------------+| customers     |+---------------+1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; desc customers;+-------+----------+------+-----+---------+----------------+| Field | Type     | Null | Key | Default | Extra          |+-------+----------+------+-----+---------+----------------+| id    | int(11)  | NO   | PRI | NULL    | auto_increment || name  | char(20) | NO   |     | NULL    |                || age   | int(11)  | NO   |     | NULL    |                |+-------+----------+------+-----+---------+----------------+3 rows in set (0.02 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into customers values(1,\"wangbo\",\"24\");Query OK, 1 row affected (0.06 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into customers values(2,\"guohui\",\"22\");Query OK, 1 row affected (0.06 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into customers values(3,\"zhangheng\",\"27\");Query OK, 1 row affected (0.09 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from customers;+----+-----------+-----+| id | name      | age |+----+-----------+-----+|  1 | wangbo    |  24 ||  2 | guohui    |  22 ||  3 | zhangheng |  27 |+----+-----------+-----+3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	（2）现在进行全备份[root@vm-002 ~]# mysqldump -uroot -p -B -F -R -x --master-data=2 ops|gzip &gt;/opt/backup/ops_$(date +%F).sql.gzEnter password: [root@vm-002 ~]# ls /opt/backup/ops_2016-09-25.sql.gz\r\n</p>\r\n<p>\r\n	-----------------参数说明：-B：指定数据库-F：刷新日志-R：备份存储过程等-x：锁表--master-data：在备份语句里添加CHANGE MASTER语句以及binlog文件及位置点信息-----------------\r\n</p>\r\n<p>\r\n	（3）再次插入数据mysql&gt; insert into customers values(4,\"liupeng\",\"21\");Query OK, 1 row affected (0.06 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into customers values(5,\"xiaoda\",\"31\");Query OK, 1 row affected (0.07 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into customers values(6,\"fuaiai\",\"26\");Query OK, 1 row affected (0.06 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from customers;+----+-----------+-----+| id | name      | age |+----+-----------+-----+|  1 | wangbo    |  24 ||  2 | guohui    |  22 ||  3 | zhangheng |  27 ||  4 | liupeng   |  21 ||  5 | xiaoda    |  31 ||  6 | fuaiai    |  26 |+----+-----------+-----+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	（4）此时误操作，删除了test数据库mysql&gt; drop database ops;Query OK, 1 row affected (0.04 sec)\r\n</p>\r\n<p>\r\n	此时，全备之后到误操作时刻之间，用户写入的数据在binlog中，需要恢复出来!\r\n</p>\r\n<p>\r\n	(5)查看全备之后新增的binlog文件[root@vm-002 ~]# cd /opt/backup/[root@vm-002 backup]# lsops_2016-09-25.sql.gz[root@vm-002 backup]# gzip -d ops_2016-09-25.sql.gz [root@vm-002 backup]# lsops_2016-09-25.sql[root@vm-002 backup]# grep CHANGE ops_2016-09-25.sql -- CHANGE MASTER TO MASTER_LOG_FILE=\'mysql-bin.000002\', MASTER_LOG_POS=106;\r\n</p>\r\n<p>\r\n	这是全备时刻的binlog文件位置即mysql-bin.000002的106行，因此在该文件之前的binlog文件中的数据都已经包含在这个全备的sql文件中了\r\n</p>\r\n<p>\r\n	（6）移动binlog文件，并导出为sql文件，剔除其中的drop语句查看mysql的数据存放目录，有下面可知是在/var/lib/mysql下[root@vm-002 backup]# ps -ef|grep mysqlroot      9272     1  0 01:43 pts/1    00:00:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --socket=/var/lib/mysql/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysqlmysql     9377  9272  0 01:43 pts/1    00:00:00 /usr/libexec/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=mysql --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sock[root@vm-002 backup]# cd /var/lib/mysql/[root@vm-002 mysql]# lsibdata1  ib_logfile0  ib_logfile1  mysql  mysql-bin.000001  mysql-bin.000002  mysql-bin.index  mysql.sock  test[root@vm-002 mysql]# cp mysql-bin.000002 /opt/backup/\r\n</p>\r\n<p>\r\n	将binlog文件导出sql文件，并vim编辑它删除其中的drop语句[root@vm-002 backup]# mysqlbinlog -d ops mysql-bin.000002 &gt;002bin.sql[root@vm-002 backup]# ls002bin.sql  mysql-bin.000002  ops_2016-09-25.sql[root@vm-002 backup]# vim 002bin.sql                 #删除里面的drop语句\r\n</p>\r\n<p>\r\n	注意：在恢复全备数据之前必须将该binlog文件移出，否则恢复过程中，会继续写入语句到binlog，最终导致增量恢复数据部分变得比较混乱\r\n</p>\r\n<p>\r\n	（7）恢复数据[root@vm-002 backup]# mysql -uroot -p &lt; ops_2016-09-25.sql Enter password: [root@vm-002 backup]#\r\n</p>\r\n<p>\r\n	查看数据库，看看ops库在不在mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || ops                || test               |+--------------------+4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use ops;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changedmysql&gt; select * from customers;+----+-----------+-----+| id | name      | age |+----+-----------+-----+|  1 | wangbo    |   0 ||  2 | guohui    |   0 ||  3 | zhangheng |   0 |+----+-----------+-----+3 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	此时恢复了全备时刻的数据\r\n</p>\r\n<p>\r\n	接着，使用002bin.sql文件恢复全备时刻到删除数据库之间，新增的数据[root@vm-002 backup]#  mysql -uroot -p ops &lt;002bin.sqlEnter password: [root@vm-002 backup]#\r\n</p>\r\n<p>\r\n	再次查看数据库，发现全备份到删除数据库之间的那部分数据也恢复了！！mysql&gt; select * from customers;+----+-----------+-----+| id | name      | age |+----+-----------+-----+|  1 | wangbo    |  24 ||  2 | guohui    |  22 ||  3 | zhangheng |  27 ||  4 | liupeng   |  21 ||  5 | xiaoda    |  31 ||  6 | fuaiai    |  26 |+----+-----------+-----+6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	以上就是mysql数据库增量数据恢复的实例过程！\r\n</p>\r\n<p>\r\n	**********************************************最后，总结几点：1）本案例适用于人为SQL语句造成的误操作或者没有主从复制等的热备情况宕机时的修复2）恢复条件为mysql要开启binlog日志功能，并且要全备和增量的所有数据3）恢复时建议对外停止更新，即禁止更新数据库4）先恢复全量，然后把全备时刻点以后的增量日志，按顺序恢复成SQL文件，然后把文件中有问题的SQL语句删除（也可通过时间和位置点），再恢复到数据库。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('ed65e270-68c9-4bf5-9dff-cd6e441c4947','nginx限制上传大小和超时时间设置说明/php限制上传大小','nginx限制上传大小和超时时间设置说明/php限制上传大小','<p>\r\n	现象说明：在服务器上部署了一套后台环境，使用的是nginx反向代理tomcat架构，在后台里上传一个70M的视频文件，上传到一半就失效了！\r\n</p>\r\n<p>\r\n	原因是nginx配置里限制了上传文件的大小\r\n</p>\r\n<p>\r\n	client_max_body_size：这个参数的设置限制了上传文件的大小，可以在http、server、location三个区域里配置\r\n</p>\r\n<p>\r\n	[root@dev-huanqiu ~]# cat /Data/app/nginx/conf/nginx.conf\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	http {\r\n</p>\r\n<p>\r\n	include       mime.types;\r\n</p>\r\n<p>\r\n	default_type  application/octet-stream;\r\n</p>\r\n<p>\r\n	charset utf-8;\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	## http setting\r\n</p>\r\n<p>\r\n	#######\r\n</p>\r\n<p>\r\n	sendfile       on;\r\n</p>\r\n<p>\r\n	tcp_nopush     on;\r\n</p>\r\n<p>\r\n	tcp_nodelay    on;\r\n</p>\r\n<p>\r\n	keepalive_timeout  100;           #这个参数表示http连接超时时间，默认是65s。要是上传文件比较大，在规定时间内没有上传完成，就会自动断开连接！所以适当调大这个时间。\r\n</p>\r\n<p>\r\n	fastcgi_connect_timeout 6000;\r\n</p>\r\n<p>\r\n	fastcgi_send_timeout 6000;\r\n</p>\r\n<p>\r\n	fastcgi_read_timeout 6000;\r\n</p>\r\n<p>\r\n	fastcgi_buffer_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_buffers 8 256k;\r\n</p>\r\n<p>\r\n	fastcgi_busy_buffers_size 256k;\r\n</p>\r\n<p>\r\n	fastcgi_temp_file_write_size 256k;\r\n</p>\r\n<p>\r\n	##\r\n</p>\r\n<p>\r\n	client_header_timeout 120s;        #调大点\r\n</p>\r\n<p>\r\n	client_body_timeout 120s;          #调大点\r\n</p>\r\n<p>\r\n	client_max_body_size 100m;         #主要是这个参数，限制了上传文件大大小\r\n</p>\r\n<p>\r\n	client_body_buffer_size 256k;\r\n</p>\r\n<p>\r\n	## support more than 15 test environments\r\n</p>\r\n<p>\r\n	server_names_hash_max_size 512;\r\n</p>\r\n<p>\r\n	server_names_hash_bucket_size 128;\r\n</p>\r\n<p>\r\n	gzip  on;\r\n</p>\r\n<p>\r\n	gzip_min_length  1k;\r\n</p>\r\n<p>\r\n	gzip_buffers     4 16k;\r\n</p>\r\n<p>\r\n	gzip_http_version 1.1;\r\n</p>\r\n<p>\r\n	gzip_comp_level 9;\r\n</p>\r\n<p>\r\n	gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php;\r\n</p>\r\n<p>\r\n	gzip_vary on;\r\n</p>\r\n<p>\r\n	[root@dev-huanqiu ~]#  cat /Data/app/nginx/conf/vhosts/admin.wangshibo.conf\r\n</p>\r\n<p>\r\n	server {\r\n</p>\r\n<p>\r\n	listen       80;\r\n</p>\r\n<p>\r\n	server_name  admin.wangshibo.com;\r\n</p>\r\n<p>\r\n	#if ($http_x_forwarded_for !~ ^(14.165.97.54|123.110.186.128|123.110.186.68)) {\r\n</p>\r\n<p>\r\n	#   rewrite ^.*$  /maintence.php last;\r\n</p>\r\n<p>\r\n	#}\r\n</p>\r\n<p>\r\n	access_log  /var/log/wangshibo.log  main;\r\n</p>\r\n<p>\r\n	location   / {\r\n</p>\r\n<p>\r\n	proxy_pass http://127.0.0.1:8484/;\r\n</p>\r\n<p>\r\n	proxy_connect_timeout   300;         #这三个超时时间适量调大点\r\n</p>\r\n<p>\r\n	proxy_send_timeout      600;\r\n</p>\r\n<p>\r\n	proxy_read_timeout      600;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Real-IP $remote_addr;    # 获取客户端真实IP\r\n</p>\r\n<p>\r\n	proxy_set_header REMOTE-HOST $remote_addr;\r\n</p>\r\n<p>\r\n	proxy_set_header Host $host;\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   # 获取代理者的真实ip\r\n</p>\r\n<p>\r\n	proxy_set_header X-Forwarded-Scheme  $scheme;    # 解决getScheme，isSecure，sendRedirect\r\n</p>\r\n<p>\r\n	proxy_buffer_size       32k;\r\n</p>\r\n<p>\r\n	proxy_buffers           32 256k;\r\n</p>\r\n<p>\r\n	proxy_busy_buffers_size 512k;\r\n</p>\r\n<p>\r\n	proxy_temp_file_write_size 512k;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	location   /static/video {\r\n</p>\r\n<p>\r\n	root  /Data/app/tomcat-7-admin-wls/static/video;\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	} ##end server\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	另外，tomcat的server.xml配置文件中的connectionTimeout超时时间也可以适当调大点，默认是20000，可以改成60000.\r\n</p>\r\n<p>\r\n	Nginx代理请求超时时间可以参考：http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	-----------------注意一点：keepalive_timeout这个是nginx里关于http连接超时的一个设置，功能是使客户端到服务器端的连接在设定的时间内持续有效，当出现对服务器的后继请求时，该功能避免了建立或者重新建立连接。切记这个参数也不能设置过大！因为客户端接口访问其实是一个比较快速的过程，访问完成了就不需要继续使用http连接了，如果将该参数值设置过大，就会导致接口访问完成后http连接并没有被释放掉，所以导致连接数越来越大，最终nginx崩溃！\r\n</p>\r\n<p>\r\n	如果http连接数过大时，超过了nginx里对于连接数的配置，比如“worker_connections  65535”，那么对应的nginx报错日志里会有信息：（socket() failed (24: Too many open files) while connecting to upstream）时不时的出现。\r\n</p>\r\n<p>\r\n	所以，要严格控制keepalive_timeout超时时间的设置，调大点的话，就会导致许多无效的http连接占据着nginx的连接数。\r\n</p>\r\n<p>\r\n	总之：keepalive_timeout参数，对于提供静态内容的网站来说，这个功能通常是很有用的；但是对于负担较重的网站来说，存在一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，该功能对资源利用的影响尤其突出。\r\n</p>\r\n<p>\r\n	优点是:在请求大量小文件的时候,长连接的有效使用可以减少重建连接的开销.缺点是:当长连接时间过长,比如60s,即使是浏览器没有任何请求,服务器仍然会维护着该浏览器的连接,一旦用户很多,对apache而言,就是需要维护大量的空闲进程.而对使用线程的轻量级web服务器如nginx,会由于超时时间过长而使资源无效占有而引发的损失,已超过了由于重复连接而造成的损失..\r\n</p>\r\n<p>\r\n	------------------------------------------另外补充下php配置里对上传大小的限制：打开php.ini 文件中，主要修改以下几个参数\r\n</p>\r\n<p>\r\n	;This sets the maximum amount of memory in bytes that a script is allowed to allocatememory_limit = 32M ;The maximum size of an uploaded file.upload_max_filesize = 8M ;Sets max size of post data allowed. This setting also affects file upload. To upload large files, this value must be larger than upload_max_filesizepost_max_size = 16M\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('efad71e2-f0b0-4888-9f94-dd27b4334b6f','nginx访问报错：Too many open files accept:','nginx访问报错：Too many open files accept:','<p>\r\n	使用nginx作为web服务，访问的时候报错：accept() failed (24: Too many open files)\r\n</p>\r\n<p>\r\n	原因时：nginx的连接数超过了系统设定的最大值！\r\n</p>\r\n<p>\r\n	解决办法：（1）[root@kvm-server nginx]# ulimit -n1024\r\n</p>\r\n<p>\r\n	[root@kvm-server nginx]# ulimit -n 655360      #把打开文件数设置足够大，这是临时修改方案[root@kvm-server nginx]# ulimit -n655360\r\n</p>\r\n<p>\r\n	（2）同时修改nginx.conf文件,添加下面内容，然后重启nginxworker_rlimit_nofile 655350；\r\n</p>\r\n<p>\r\n	这样就可以解决Nginx连接过多的问题，Nginx就可以支持高并发。另外， ulimit -n 还会影响到mysql 的并发连接数。提高文件连接数设置，也能提高mysql并发。\r\n</p>\r\n<p>\r\n	（3）注意： 用ulimit -n 655360   修改只对当前的shell有效，退出后失效。所以，需要永久性修改\r\n</p>\r\n<p>\r\n	永久生效方法：修改/etc/security/limits.conf，在文件底部添加：* soft nofile 655360* hard nofile 655360\r\n</p>\r\n<p>\r\n	星号代表全局， soft为软件，hard为硬件，nofile为这里指可打开文件数。\r\n</p>\r\n<p>\r\n	（4）另外，要使limits.conf文件配置生效，必须要确保 pam_limits.so 文件被加入到启动文件中。查看 /etc/pam.d/login 文件中有：\r\n</p>\r\n<p>\r\n	session required /lib/security/pam_limits.so\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	这样，问题就迎刃而解了！\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('f16cf1db-a9cd-4a2c-9e38-b737310f625b','定时备份脚本分享（网站数据和数据库数据）','定时备份脚本分享（网站数据和数据库数据）','<p>\r\n	备份是我们运维人员最基本的日常工作，做好备份是稳定运维的一个重要环节。下面分享两个使用过的简单备份脚本：\r\n</p>\r\n<p>\r\n	1）网站数据备份将网站数据/var/www/vhost/www.hqsb.com和/var/www/vhost/www.huanqiu.com分别备份到：/Data/code-backup/www.hqsb.com和/Data/code-backup/www.huanqiu.com下。\r\n</p>\r\n<p>\r\n	[root@huanqiu_web5 code-backup]# cat web_code_backup.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	#备份网站数据\r\n</p>\r\n<p>\r\n	/bin/tar -zvcf /Data/code-backup/www.huanqiu.com/www.huanqiu.com_`date +%Y%m%d_%H%M%S`.tar.gz /var/www/vhosts/www.huanqiu.com\r\n</p>\r\n<p>\r\n	/bin/tar -zvcf /Data/code-backup/www.hqsb.com/www.hqsb.com_`date +%Y%m%d_%H%M%S`.tar.gz /var/www/vhosts/www.hqsb.com\r\n</p>\r\n<p>\r\n	#删除一周之前的备份文件\r\n</p>\r\n<p>\r\n	find /Data/code-backup/www.huanqiu.com -type f -mtime +7 -exec rm -f {} \\;\r\n</p>\r\n<p>\r\n	find /Data/code-backup/www.hqsb.com -type f -mtime +7 -exec rm -f {} \\;\r\n</p>\r\n<p>\r\n	[root@huanqiu_web5 ~]# crontab -l\r\n</p>\r\n<p>\r\n	#每天凌晨5点备份网站数据\r\n</p>\r\n<p>\r\n	0 5 * * * /bin/bash -x /Data/code-backup/web_code_backup.sh &gt; /dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	备份后的效果如下：\r\n</p>\r\n<p>\r\n	[root@huanqiu_web5 ~]# ls /Data/code-backup/www.huanqiu.com/\r\n</p>\r\n<p>\r\n	www.huanqiu.com_20170322_174328.tar.gz\r\n</p>\r\n<p>\r\n	[root@xqsj_web5 ~]# ls /Data/code-backup/www.hqsb.com/\r\n</p>\r\n<p>\r\n	www.hqsb.com_20170322_174409.tar.gz\r\n</p>\r\n<p>\r\n	2）数据库备份（自动删除10天前的备份文件）数据库服务使用的是阿里云的mysql，远程进行定时的全量备份，备份到本地，以防万一。mysql数据库远程备份的数据最好打包压缩\r\n</p>\r\n<p>\r\n	[root@huanqiuPC crontab]# pwd\r\n</p>\r\n<p>\r\n	/Data/Mysql_Bakup/crontab\r\n</p>\r\n<p>\r\n	[root@huanqiuPC crontab]# cat backup_db_wangshibo.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	MYSQL=\"/usr/bin/mysql\"\r\n</p>\r\n<p>\r\n	MYSQLDUMP=\"/usr/bin/mysqldump\"\r\n</p>\r\n<p>\r\n	BACKUP_DIR=\"/Data/Mysql_Bakup\"\r\n</p>\r\n<p>\r\n	#DB_SOCKET=\"/var/lib/mysql/mysql.sock\"\r\n</p>\r\n<p>\r\n	DB_hostname=\"110.120.11.9\"\r\n</p>\r\n<p>\r\n	DBNAME=\"wangshibo\"\r\n</p>\r\n<p>\r\n	DB_USER=\"db_wangshibo\"\r\n</p>\r\n<p>\r\n	DB_PASS=\"mhxzk3rfzh\"\r\n</p>\r\n<p>\r\n	TIME=`date +%Y%m%d%H%M%S`\r\n</p>\r\n<p>\r\n	LOCK_FILE=\"${BACKUP_DIR}/lock_file.tmp\"\r\n</p>\r\n<p>\r\n	BKUP_LOG=\"/Data/Mysql_Backup/${TIME}_bkup.log\"\r\n</p>\r\n<p>\r\n	DEL_BAK=`date -d \'10 days ago\' \'+%Y%m%d\'`\r\n</p>\r\n<p>\r\n	##To judge lock_file\r\n</p>\r\n<p>\r\n	if [[ -f $LOCK_FILE ]];then\r\n</p>\r\n<p>\r\n	exit 255\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	echo $$ &gt; $LOCK_FILE\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	##dump databases##\r\n</p>\r\n<p>\r\n	echo ${TIME} &gt;&gt; ${BKUP_LOG}\r\n</p>\r\n<p>\r\n	echo \"=======Start Bakup============\" &gt;&gt;${BKUP_LOG}\r\n</p>\r\n<p>\r\n	#${MYSQLDUMP} -h ${DB_hostname} -u${DB_USER} -p${DB_PASS} --databases ${DBNAME} | gzip -9 &gt; ${BACKUP_DIR}/${TIME}.${DBNAME}.gz\r\n</p>\r\n<p>\r\n	${MYSQLDUMP} -h ${DB_hostname} -u${DB_USER} -p${DB_PASS} --databases ${DBNAME} |gzip -9 &gt; ${BACKUP_DIR}/${TIME}.${DBNAME}.gz\r\n</p>\r\n<p>\r\n	echo \"=======Finished Bakup============\" &gt;&gt;${BKUP_LOG}\r\n</p>\r\n<p>\r\n	/bin/rm -f ${LOCK_FILE}\r\n</p>\r\n<p>\r\n	##del back 10 days before##\r\n</p>\r\n<p>\r\n	/bin/rm -f ${BACKUP_DIR}/${DEL_BAK}*.gz\r\n</p>\r\n<p>\r\n	定时进行备份\r\n</p>\r\n<p>\r\n	[root@huanqiuPC Mysql_Bakup]# crontab -l\r\n</p>\r\n<p>\r\n	10 0,6,12,18 * * * /bin/bash /Data/Mysql_Bakup/crontab/backup_db_wangshibo.sh &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	脚本执行后的备份效果如下\r\n</p>\r\n<p>\r\n	[root@huanqiuPC crontab]# cd /Data/Mysql_Bakup\r\n</p>\r\n<p>\r\n	[root@huanqiuPC Mysql_Bakup]# ls\r\n</p>\r\n<p>\r\n	20161202061001.wangshibo.gz\r\n</p>\r\n<p>\r\n	同步线上数据库到beta环境数据库（覆盖beta数据库）：将上面定时备份的数据包拷贝到beta机器上，然后解压，登陆mysql，source命令进行手动覆盖。\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('f1bf7b47-b8fa-4884-9c8a-de0b34f5ea01','Mysql备份系列（1）--备份方案总结性梳理','Mysql备份系列（1）--备份方案总结性梳理','<p>\r\n	mysql数据库备份有多么重要已不需过多赘述了，废话不多说！以下总结了mysql数据库的几种备份方案：\r\n</p>\r\n<p>\r\n	一、binlog二进制日志通常作为备份的重要资源，所以再说备份方案之前先总结一下binlog日志~~1.binlog日志内容1）引起mysql服务器改变的任何操作。2）复制功能依赖于此日志。3）slave服务器通过复制master服务器的二进制日志完成主从复制，在执行之前保存于中继日志(relay log)中。 4）slave服务器通常可以关闭二进制日志以提升性能。\r\n</p>\r\n<p>\r\n	2.binlog日志文件的文件表现形式1）默认在安装目录下，存在mysql-bin.00001, mysql-bin.00002的二进制文件（binlog日志文件名依据my.cnf配置中的log-bin参数后面的设置为准）2）还有mysql-bin.index用来记录被mysql管理的二进制文件列表3）如果需要删除二进制日志时，切勿直接删除二进制文件，这样会使得mysql管理混乱。\r\n</p>\r\n<p>\r\n	3.binlog日志文件查看相关mysql命令1）SHOW MASTER STATUS ; 查看正在使用的二进制文件 MariaDB [(none)]&gt; SHOW MASTER STATUS ;         +------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 |      245 |              |                  |+------------------+----------+--------------+------------------+2）FLUSH LOGS; 手动滚动二进制日志MariaDB [(none)]&gt; FLUSH LOGS;            MariaDB [(none)]&gt; SHOW MASTER STATUS ; +------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000004 |      245 |              |                  |+------------------+----------+--------------+------------------+滚动以后，mysql重新创建一个新的日志mysql-bin.0000043）SHOW BINARY LOGS 显示使用过的二进制日志文件MariaDB [(none)]&gt; SHOW BINARY LOGS ;            +------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000001 |     30373 || mysql-bin.000002 |   1038814 || mysql-bin.000003 |       288 || mysql-bin.000004 |       245 |4）SHOW BINLOG EVENTS 以表的形式查看二进制文件命令格式：SHOW BINLOG EVENTS [IN \'log_name\'] [FROM pos] [LIMIT [offset,] row_count]                MariaDB [(none)]&gt; SHOW BINLOG EVENTS IN \'mysql-bin.000001\' \\G;*************************** 99. row ***************************Log_name: mysql-bin.000001Pos: 30225Event_type: QueryServer_id: 1End_log_pos: 30354Info: use `mysql`; DROP TEMPORARY TABLE `tmp_proxies_priv` /* generated by server */\r\n</p>\r\n<p>\r\n	4.MySQL二进制文件读取工具mysqlbinlog 命令格式：mysqlbinlog [参数] log-files  有以下四种参数选择：          --start-datetime--stop-datetime--start-position--stop-position[root@test-huanqiu ~]# mysqlbinlog --start-position 30225 --stop-position 30254  mysql-bin.000001            截取一下结果： # at 30225#151130 12:43:35 server id 1  end_log_pos 30354 Querythread_id=1exec_time=0error_code=0use `mysql`/*!*/;SET TIMESTAMP=1448858615/*!*/;SET @@session.pseudo_thread_id=1/*!*/\r\n</p>\r\n<p>\r\n	根据以上截取结果第二行，进行解释二进制日志内容            1）时间点： 151130 12:43:352）服务器ID： server id 1服务器ID主要用于标记日志产生的服务器，主要用于双主模型中，互为主从，确保二进制文件不会被相互循环复制3）记录类型： Query  4) 线程号： thread_id = 1 5) 语句的时间戳和写入二进制日志文件的时间差； exec_time=0 6) 事件内容7）事件位置 #at 30225 8) 错误代码 error_code=0 9) 事件结束位置 end_log_pos也就是下一事件开始的位置\r\n</p>\r\n<p>\r\n	5.二进制日志格式由bin_log_format={statement|row|mixed}定义 1）statement: 基于语句，记录生成数据的语句 缺点在于如果当时插入信息为函数生成，有可能不同时间点执行结果不一样，例如： INSERT INTO t1 VALUE (CURRENT_DATE());2）row: 基于行数据缺点在于，有时候数据量会过大3）mixed： 混合模式，又mysql自行决定何时使用statement, 何时使用row 模式\r\n</p>\r\n<p>\r\n	6.二进制相关参数总结1）log_bin = {ON|OFF} 还可以是个文件路径，自定义binlog日志文件名，使用“log_bin=“或“log-bin=“都可以，主要用于控制全局binlog的存放位置和是否开启binlog日志功能。比如：log_bin=mysql-bin 或者 log-bin=mysql-bin，这样binlog日志默认会和mysql数据放在同一目录下。2） log_bin_trust_function_creators是否记录在3） sql_log_bin = {ON|OFF}会话级别是否关闭binlog， 如果关闭当前会话内的操作将不会记录4） sync_binlog 是否马上同步事务类操作到二进制日志中5） binlog_format = {statement|row|mixed} 二进制日志的格式，上面单独提到了6） max_binlog_cache_size = 二进制日志缓冲空间大小，仅用于缓冲事务类的语句；7） max_binlog_stmt_cache_size =语句缓冲，非事务类和事务类共用的空间大小8） max_binlog_size = 二进制日志文件上限，超过上限后则滚动9) 删除二进制日志 命令格式：PURGE { BINARY | MASTER } LOGS { TO \'log_name\' | BEFORE datetime_expr }MariaDB&gt; PURGE BINARY LOGS TO \'mysql-bin.010\';            MariaDB&gt; PURGE BINARY LOGS BEFORE \'2016-11-02 22:46:26\';建议：切勿将二进制日志与数据文件放在一同设备；可以将binlog日志实时备份到远程设备上，以防出现机器故障进行数据恢复；\r\n</p>\r\n<p>\r\n	二、接下来说下binlog二进制日志备份和恢复1.为什么做备份：（1）灾难恢复 （2）审计，数据库在过去某一个时间点是什么样的 （3）测试\r\n</p>\r\n<p>\r\n	2.备份的目的：（1）用于恢复数据（2）备份结束后，需要周期性的做恢复测试\r\n</p>\r\n<p>\r\n	3.备份类型： （1）根据备份时，服务器是否在线1）冷备(cold backup)： 服务器离线，读写操作都不能进行 2）温备份： 全局施加共享锁，只能读不能写3）热备(hot backup)：数据库在线，读写照样进行 （2）根据备份时的数据集分类 1）完全备份(full backup)2）部分备份(partial backup)（3）根据备份时的接口1）物理备份（physical backup）：直接复制数据文件 ，打包归档特点： 不需要额外工具，直接归档命令即可，但是跨平台能力比较差；如果数据量超过几十个G，则适用于物理备份2）逻辑备份(logical backup)： 把数据抽取出来保存在sql脚本中特点： 可以使用文本编辑器编辑；导入方便，直接读取sql语句即可；逻辑备份恢复时间慢，占据空间大；无法保证浮点数的精度；恢复完数据库后需要重建索引。（4）根据备份整个数据还是变化数据 1） 全量备份 full backup2） 增量备份 incremental backup 在不同时间点起始备份一段数据，比较节约空间；针对的是上一次备份后有变化的数据，备份数据少，备份快，恢复慢3） 差异备份  differential backup 备份从每个时间点到上一次全部备份之间的数据，随着时间增多二增多；比较容易恢复；对于很大的数据库，可以考虑主从模型，备份从服务器的内容。针对的是上一次全量备份后有变化的数据，备份数据多，备份慢，恢复快。（5）备份策略，需要考虑因素如下备份方式 备份实践备份成本锁时间时长性能开销恢复成本恢复时长所能够容忍丢失的数据量（6）备份内容 1）数据库中的数据2）配置文件 3）mysql中的代码： 存储过程，存储函数，触发器4）OS 相关的配置文件，chrontab 中的备份策略脚本5）如果是主从复制的场景中： 跟复制相关的信息6）二进制日志文件需要定期备份，一旦发现二进制文件出现问题，需马上对数据进行完全备份\r\n</p>\r\n<p>\r\n	(7)Mysql最常用的三种备份工具：1）mysqldump：通常为小数据情况下的备份innodb： 热备，温备MyISAM, Aria: 温备 单线程备份恢复比较慢2）Xtrabackup（通常用innobackupex工具）：备份mysql大数据InnoDB热备，增量备份；MyISAM温备，不支持增量，只有完全备份 属于物理备份，速度快；3）lvm-snapshot：接近于热备的工具：因为要先请求全局锁，而后创建快照，并在创建快照完成后释放全局锁；使用cp、tar等工具进行物理备份；备份和恢复速度较快；很难实现增量备份，并且请求全局需要等待一段时间，在繁忙的服务器上尤其如此；\r\n</p>\r\n<p>\r\n	除此之外，还有其他的几个备份工具：--&gt;mysqldumper: 多线程的mysqldump --&gt;SELECT clause INTO OUTFILE \'/path/to/somefile\' LOAD DATA INFILE \'/path/from/somefile\'部分备份工具， 不会备份关系定义，仅备份表中的数据；逻辑备份工具，快于mysqldump，因为不备份表格式信息--&gt;mysqlhotcopy: 接近冷备，基本没用\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mysqldump工具基本使用1. mysqldump [OPTIONS] database [tables…]还原时库必须存在，不存在需要手动创建&nbsp; &nbsp; --all-databases:　备份所有库    &nbsp; &nbsp; --databases db1 db2 ...: 备份指定的多个库，如果使用此命令，恢复时将不用手动创建库。或者是-B db1 db2 db3 ....&nbsp; &nbsp; --lock-all-tables：请求锁定所有表之后再备份，对MyISAM、InnoDB、Aria做温备&nbsp; &nbsp; --lock-table: 对正在备份的表加锁，但是不建议使用，如果其它表被修改，则备份后表与表之间将不同步&nbsp; &nbsp; --single-transaction: 能够对InnoDB存储引擎实现热备；启动一个很大的大事物，基于MOCC可以保证在事物内的表版本一致自动加锁不需要，再加--lock-table, 可以实现热备备份代码：&nbsp; &nbsp;--events: 备份事件调度器代码&nbsp; &nbsp;--routines: 备份存储过程和存储函数&nbsp; &nbsp;--triggers：备份触发器备份时滚动日志：&nbsp; &nbsp;--flush-logs: 备份前、请求到锁之后滚动日志；      方恢复备份时间点以后的内容复制时的同步位置标记：主从架构中的，主服务器数据。效果相当于标记一个时间点。&nbsp; &nbsp;--master-data=[0|1|2]&nbsp; &nbsp;0: 不记录&nbsp; &nbsp;1：记录为CHANGE MASTER语句&nbsp; &nbsp;2：记录为注释的CHANGE MASTER语句\r\n</p>\r\n<p>\r\n	2. 使用mysqldump备份大体过程：1) 请求锁：--lock-all-tables或使用–singe-transaction进行innodb热备；2) 滚动日志：--flush-logs3) 选定要备份的库：--databases4) 记录二进制日志文件及位置：--master-data=FLUSH TABLES5 WITH READ LOCK;\r\n</p>\r\n<p>\r\n	3. 恢复：恢复过程无需写到二进制日志中 建议：关闭二进制日志，关闭其它用户连接；\r\n</p>\r\n<p>\r\n	4. 备份策略：基于mysqldump备份：mysqldump+二进制日志文件；（“mysqldump &gt;”）周日做一次完全备份：备份的同时滚动日志周一至周六：备份二进制日志；恢复：（“mysql &lt; ”）或在mysql数据库中直接执行“source sql备份文件;”进行恢复。如果sql执行语句比较多，可以将sql语句放在一个文件内，将文件名命名为.sql结尾，然后在mysql数据库中使用\"source 文件.sql;\"命令进行执行即可！完全备份+各二进制日志文件中至此刻的事件\r\n</p>\r\n<p>\r\n	5. 实例说明：参考：Mysql备份系列（2）--mysqldump备份（全量+增量）方案操作记录\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	lvm-snapshot：基于LVM快照的备份1.关于快照：1）事务日志跟数据文件必须在同一个卷上；2）刚刚创立的快照卷，里面没有任何数据，所有数据均来源于原卷3）一旦原卷数据发生修改，修改的数据将复制到快照卷中，此时访问数据一部分来自于快照卷，一部分来自于原卷4）当快照使用过程中，如果修改的数据量大于快照卷容量，则会导致快照卷崩溃。 5）快照卷本身不是备份，只是提供一个时间一致性的访问目录。\r\n</p>\r\n<p>\r\n	2.基于快照备份几乎为热备： 1）创建快照卷之前，要请求MySQL的全局锁；在快照创建完成之后释放锁；2）如果是Inoodb引擎， 当flush tables 后会有一部分保存在事务日志中，却不在文件中。 因此恢复时候，需要事务日志和数据文件但释放锁以后，事务日志的内容会同步数据文件中，因此备份内容并不绝对是锁释放时刻的内容，由于有些为完成的事务已经完成，但在备份数据中因为没完成而回滚。 因此需要借助二进制日志往后走一段\r\n</p>\r\n<p>\r\n	3.基于快照备份注意事项： 1）事务日志跟数据文件必须在同一个卷上；2）创建快照卷之前，要请求MySQL的全局锁；在快照创建完成之后释放锁；3）请求全局锁完成之后，做一次日志滚动；做二进制日志文件及位置标记(手动进行)；\r\n</p>\r\n<p>\r\n	4.为什么基于MySQL快照的备份很好？原因如下几点：1）几乎是热备 在大多数情况下，可以在应用程序仍在运行的时候执行备份。无需关机，只需设置为只读或者类似只读的限制。2）支持所有基于本地磁盘的存储引擎 它支持MyISAM, Innodb, BDB，还支持 Solid, PrimeXT 和 Falcon。3）快速备份 只需拷贝二进制格式的文件，在速度方面无以匹敌。4）低开销 只是文件拷贝，因此对服务器的开销很细微。5）容易保持完整性 想要压缩备份文件吗？把它们备份到磁带上，FTP或者网络备份软件 -- 十分简单，因为只需要拷贝文件即可。6）快速恢复 恢复的时间和标准的MySQL崩溃恢复或数据拷贝回去那么快，甚至可能更快，将来会更快。7）免费 无需额外的商业软件，只需Innodb热备工具来执行备份。\r\n</p>\r\n<p>\r\n	快照备份mysql的缺点：1）需要兼容快照 -- 这是明显的。2）需要超级用户(root) 在某些组织，DBA和系统管理员来自不同部门不同的人，因此权限各不一样。3）停工时间无法预计，这个方法通常指热备，但是谁也无法预料到底是不是热备 -- FLUSH TABLES WITH READ LOCK 可能会需要执行很长时间才能完成。4）多卷上的数据问题 如果你把日志放在独立的设备上或者你的数据库分布在多个卷上，这就比较麻烦了，因为无法得到全部数据库的一致性快照。不过有些系统可能能自动做到多卷快照。\r\n</p>\r\n<p>\r\n	5.备份与恢复的大体步骤备份：1）请求全局锁，并滚动日志mysql&gt; FLUSH TABLES WITH READ LOCK;mysql&gt; FLUSH LOGS;2）做二进制日志文件及位置标记(手动进行)；[root@test-huanqiu ~]# mysql -e \'show master status\' &gt; /path/to/orignal_volume3）创建快照卷[root@test-huanqiu ~]# lvcreate -L   -s -n    -p r  /path/to/some_lv4）释放全局锁5）挂载快照卷并备份6）备份完成之后，删除快照卷\r\n</p>\r\n<p>\r\n	恢复：1）二进制日志保存好；提取备份之后的所有事件至某sql脚本中；2）还原数据，修改权限及属主属组等，并启动mysql3）做即时点还原4）生产环境下， 一次大型恢复后，需要马上进行一次完全备份。\r\n</p>\r\n<p>\r\n	备份与恢复实例说明： 环境， 实现创建了一个test_vg卷组，里面有个mylv1用来装mysql数据，挂载到/data/mysqldata\r\n</p>\r\n<p>\r\n	备份实例：1. 创建备份专用的用户，授予权限FLUSH LOGS 和 LOCK TABLES MariaDB &gt; GRANT RELOAD,LOCK TABLES,SUPER ON *.* TO \'lvm\'@\'192.168.1.%\' IDENTIFIED BY \'lvm\';    MariaDB &gt; FLUSH PRIVILEGES;\r\n</p>\r\n<p>\r\n	2. 记录备份点[root@test-huanqiu ~]# mysql -ulvm -h192.168.1.10 -plvm -e \'SHOW MASTER STATUS\' &gt; /tmp/backup_point.txt\r\n</p>\r\n<p>\r\n	3. 创建快照卷并挂载快照卷[root@test-huanqiu ~]# lvcreate -L 1G -s -n lvmbackup -p r /dev/test_vg/mylv1    [root@test-huanqiu ~]# mount  -t ext4  /dev/test_vg/lvmbackup /mnt/\r\n</p>\r\n<p>\r\n	4. 释放锁[root@test-huanqiu ~]# mysql -ulvm -h192.168.98.10 -plvm -e \'UNLOCK TABLES\'    做一些模拟写入工作 MariaDB [test]&gt; create database testdb2\r\n</p>\r\n<p>\r\n	5. 复制文件[root@test-huanqiu ~]# cp /data/mysqldata /tmp/backup_mysqldata -r\r\n</p>\r\n<p>\r\n	6. 备份完成卸载，删除快照卷 [root@test-huanqiu ~]# umount /mnt     [root@test-huanqiu ~]# lvmremove /dev/test_vg/lvmbackup\r\n</p>\r\n<p>\r\n	还原实例： 假如整个mysql服务器崩溃，并且目录全部被删除\r\n</p>\r\n<p>\r\n	1. 数据文件复制回源目录[root@test-huanqiu ~]# cp -r /tmp/backup_mysqldata/*  /data/mysqldata/     MariaDB [test]&gt; show databases ;+--------------------+| Database           |+--------------------+| information_schema || hellodb            || mysql              || mysqldata          || openstack          || performance_schema || test               |+--------------------+此时还没有testdb2， 因为这个是备份之后创建的，因此需要通过之前记录的二进制日志\r\n</p>\r\n<p>\r\n	2. 查看之前记录的记录点。向后还原[root@test-huanqiu ~]# cat /tmp/backup_point.txt FilePositionBinlog_Do_DBBinlog_Ignore_DBmysql-bin.000001245[root@test-huanqiu ~]# mysqlbinlog /data/binlog/mysql-bin.000001 --start-position 245 &gt; tmp.sqlMariaDB [test]&gt; source /data/mysqldata/tmp.sql MariaDB [test]&gt; show databases ; +--------------------+| Database           |+--------------------+| information_schema || hellodb            || mysql              || mysqldata          || openstack          || performance_schema || test               || testdb2            |+--------------------+8 rows in set (0.00 sec)testdb2 已经被还原回来。\r\n</p>\r\n<p>\r\n	具体实例说明，参考：Mysql备份系列（4）--lvm-snapshot备份mysql数据(全量+增量）操作记录\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	使用Xtrabackup进行MySQL备份：\r\n</p>\r\n<p>\r\n	参考：Mysql备份系列（3）--innobackupex备份mysql大数据(全量+增量）操作记录\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	--------------------------------------------------------------------------------------关于备份和恢复的几点经验之谈\r\n</p>\r\n<p>\r\n	备份注意：1. 将数据和备份放在不同的磁盘设备上；异机或异地备份存储较为理想；2. 备份的数据应该周期性地进行还原测试；3. 每次灾难恢复后都应该立即做一次完全备份；4. 针对不同规模或级别的数据量，要定制好备份策略；5. 二进制日志应该跟数据文件在不同磁盘上，并周期性地备份好二进制日志文件；\r\n</p>\r\n<p>\r\n	从备份中恢复应该遵循步骤：1. 停止MySQL服务器；2. 记录服务器的配置和文件权限；3. 将数据从备份移到MySQL数据目录；其执行方式依赖于工具；4. 改变配置和文件权限；5. 以限制访问模式重启服务器；mysqld的--skip-networking选项可跳过网络功能；方法：编辑my.cnf配置文件，添加如下项：skip-networkingsocket=/tmp/mysql-recovery.sock6. 载入逻辑备份（如果有）；而后检查和重放二进制日志；7. 检查已经还原的数据；8. 重新以完全访问模式重启服务器；注释前面第5步中在my.cnf中添加的选项，并重启；\r\n</p>','2017-07-31 17:32:24',3,1,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('f3cc614a-8478-4981-ba81-3a2678368f96','Mysql+Keepalived双主热备高可用操作记录','Mysql+Keepalived双主热备高可用操作记录','<p>\r\n	我们通常说的双机热备是指两台机器都在运行，但并不是两台机器都同时在提供服务。当提供服务的一台出现故障的时候，另外一台会马上自动接管并且提供服务，而且切换的时间非常短。MySQL双主复制，即互为Master-Slave(只有一个Master提供写操作)，可以实现数据库服务器的热备，但是一个Master宕机后不能实现动态切换。使用Keepalived，可以通过虚拟IP，实现双主对外的统一接口以及自动检查、失败切换机制，从而实现MySQL数据库的高可用方案。之前梳理了Mysql主从/主主同步，下面说下Mysql+keeoalived双主热备高可用方案的实施。\r\n</p>\r\n<p>\r\n	Keepalived看名字就知道，保持存活，在网络里面就是保持在线了，也就是所谓的高可用或热备，用来防止单点故障（单点故障是指一旦某一点出现故障就会导致整个系统架构的不可用）的发生，那说到keepalived不得不说的一个协议不是VRRP协议，可以说这个协议就是keepalived实现的基础。\r\n</p>\r\n<p>\r\n	1）Keepalived的工作原理是VRRP（Virtual Router Redundancy Protocol）虚拟路由冗余协议。在VRRP中有两组重要的概念：VRRP路由器和虚拟路由器，主控路由器和备份路由器。\r\n</p>\r\n<p>\r\n	2）VRRP路由器是指运行VRRP的路由器，是物理实体，虚拟路由器是指VRRP协议创建的，是逻辑概念。一组VRRP路由器协同工作，共同构成一台虚拟路由器。 Vrrp中存在着一种选举机制，用以选出提供服务的路由即主控路由，其他的则成了备份路由。当主控路由失效后，备份路由中会重新选举出一个主控路由，来继续工作，来保障不间断服务。\r\n</p>\r\n<p>\r\n	过多内容在这里就不做详细介绍了，下面详细记录下Mysql+Keepalived双主热备的高可用方案的操作记录\r\n</p>\r\n<p>\r\n	1）先实施Master-&gt;Slave的主主同步。主主是数据双向同步，主从是数据单向同步。一般情况下，主库宕机后，需要手动将连接切换到从库上。（但是用keepalived就可以自动切换）\r\n</p>\r\n<p>\r\n	2）再结合Keepalived的使用，通过VIP实现Mysql双主对外连接的统一接口。即客户端通过Vip连接数据库；当其中一台宕机后，VIP会漂移到另一台上，这个过程对于客户端的数据连接来说几乎无感觉，从而实现高可用。\r\n</p>\r\n<p>\r\n	环境描述：\r\n</p>\r\n<p>\r\n	mysql的安装可以参考：http://www.cnblogs.com/kevingrace/p/6109679.html\r\n</p>\r\n<p>\r\n	Centos6.8版本\r\n</p>\r\n<p>\r\n	Master1：182.148.15.238        安装mysql和keepalived\r\n</p>\r\n<p>\r\n	Master2: 182.148.15.237        安装mysql和keepalived\r\n</p>\r\n<p>\r\n	VIP：182.148.15.236\r\n</p>\r\n<p>\r\n	要实现主主同步，可以先实现主从同步，即master1-&gt;master2的主从同步，然后master2-&gt;master1的主从同步.\r\n</p>\r\n<p>\r\n	这样，双方就完成了主主同步。\r\n</p>\r\n<p>\r\n	注意下面几点：\r\n</p>\r\n<p>\r\n	1）要保证同步服务期间之间的网络联通。即能相互ping通，能使用对方授权信息连接到对方数据库（防火墙开放3306端口）。\r\n</p>\r\n<p>\r\n	2）关闭selinux。\r\n</p>\r\n<p>\r\n	3）同步前，双方数据库中需要同步的数据要保持一致。这样，同步环境实现后，再次更新的数据就会如期同步了。\r\n</p>\r\n<p>\r\n	一、Mysql主主同步环境部署\r\n</p>\r\n<p>\r\n	---------------master1服务器操作记录---------------\r\n</p>\r\n<p>\r\n	在my.cnf文件的[mysqld]配置区域添加下面内容：\r\n</p>\r\n<p>\r\n	[root@master1 ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	server-id = 1\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db = mysql,information_schema\r\n</p>\r\n<p>\r\n	sync_binlog = 1\r\n</p>\r\n<p>\r\n	binlog_checksum = none\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 1\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/mysql restart\r\n</p>\r\n<p>\r\n	Shutting down MySQL. SUCCESS!\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	数据同步授权（iptables防火墙开启3306端口）这样I/O线程就可以以这个用户的身份连接到主服务器，并且读取它的二进制日志。\r\n</p>\r\n<p>\r\n	mysql&gt; grant replication slave,replication client on *.* to wang@\'182.148.15.%\' identified by \"wang@123\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	最好将库锁住，仅仅允许读，以保证数据一致性；待主主同步环境部署后再解锁；\r\n</p>\r\n<p>\r\n	锁住后，就不能往表里写数据，但是重启mysql服务后就会自动解锁！\r\n</p>\r\n<p>\r\n	mysql&gt; flush tables with read lock;  //注意该参数设置后，如果自己同步对方数据，同步前一定要记得先解锁！\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	查看下log bin日志和pos值位置\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	| mysql-bin.000004 |      430 |              | mysql,information_schema |                   |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	---------------master2服务器操作记录---------------\r\n</p>\r\n<p>\r\n	在my.cnf文件的[mysqld]配置区域添加下面内容：\r\n</p>\r\n<p>\r\n	[root@master2 ~]# vim /usr/local/mysql/my.cnf\r\n</p>\r\n<p>\r\n	server-id = 2\r\n</p>\r\n<p>\r\n	log-bin = mysql-bin\r\n</p>\r\n<p>\r\n	binlog-ignore-db = mysql,information_schema\r\n</p>\r\n<p>\r\n	sync_binlog = 1\r\n</p>\r\n<p>\r\n	binlog_checksum = none\r\n</p>\r\n<p>\r\n	binlog_format = mixed\r\n</p>\r\n<p>\r\n	auto-increment-increment = 2\r\n</p>\r\n<p>\r\n	auto-increment-offset = 2\r\n</p>\r\n<p>\r\n	slave-skip-errors = all\r\n</p>\r\n<p>\r\n	[root@master2 ~]# /etc/init.d/mysql restart\r\n</p>\r\n<p>\r\n	Shutting down MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	mysql&gt; grant replication slave,replication client on *.* to wang@\'182.148.15.%\' identified by \"wang@123\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush tables with read lock;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show master status;\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	| mysql-bin.000003 |      430 |              | mysql,information_schema |                   |\r\n</p>\r\n<p>\r\n	+------------------+----------+--------------+--------------------------+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	---------------master1服务器做同步操作---------------\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;     //先解锁，将对方数据同步到自己的数据库中\r\n</p>\r\n<p>\r\n	mysql&gt; slave stop；\r\n</p>\r\n<p>\r\n	mysql&gt; change  master to master_host=\'182.148.15.237\',master_user=\'wang\',master_password=\'wang@123\',master_log_file=\'mysql-bin.000003\',master_log_pos=430;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected, 2 warnings (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	查看同步状态，如下出现两个“Yes”，表明同步成功！\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 182.148.15.237\r\n</p>\r\n<p>\r\n	Master_User: wang\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000003\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 430\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000002\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 279\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000003\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	.........................\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	.........................\r\n</p>\r\n<p>\r\n	这样，master1就和master2实现了主从同步，即master1同步master2的数据。\r\n</p>\r\n<p>\r\n	---------------master2服务器做同步操作---------------\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;     //先解锁，将对方数据同步到自己的数据库中\r\n</p>\r\n<p>\r\n	mysql&gt; slave stop；\r\n</p>\r\n<p>\r\n	mysql&gt; change  master to master_host=\'182.148.15.238\',master_user=\'wang\',master_password=\'wang@123\',master_log_file=\'mysql-bin.000004\',master_log_pos=430;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected, 2 warnings (0.06 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; start slave;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status \\G;\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 182.148.15.238\r\n</p>\r\n<p>\r\n	Master_User: wang\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000004\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 430\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000002\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 279\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000004\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	........................\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	........................\r\n</p>\r\n<p>\r\n	这样，master2就和master1实现了主从同步，即master2也同步master1的数据。\r\n</p>\r\n<p>\r\n	以上表明双方已经实现了mysql主主同步。\r\n</p>\r\n<p>\r\n	当运行一段时间后，要是发现同步有问题，比如只能单向同步，双向同步失效。可以重新执行下上面的change master同步操作，只不过这样同步后，只能同步在此之后的更新数据。下面开始进行数据验证：\r\n</p>\r\n<p>\r\n	-----------------主主同步效果验证---------------------\r\n</p>\r\n<p>\r\n	1）在master1数据库上写入新数据\r\n</p>\r\n<p>\r\n	mysql&gt; unlock tables;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; create database huanqiu;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.01 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; create table if not exists haha (\r\n</p>\r\n<p>\r\n	-&gt; id int(10) PRIMARY KEY AUTO_INCREMENT,\r\n</p>\r\n<p>\r\n	-&gt; name varchar(50) NOT NULL);\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.04 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into haha values(1,\"王士博\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into haha values(2,\"郭慧慧\");\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | 王士博    |\r\n</p>\r\n<p>\r\n	|  2 | 郭慧慧    |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	然后在master2数据库上查看，发现数据已经同步过来了!\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| huanqiu            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	5 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; use huanqiu;\r\n</p>\r\n<p>\r\n	Reading table information for completion of table and column names\r\n</p>\r\n<p>\r\n	You can turn off this feature to get a quicker startup with -A\r\n</p>\r\n<p>\r\n	Database changed\r\n</p>\r\n<p>\r\n	mysql&gt; show tables;\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| Tables_in_huanqiu |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	| haha              |\r\n</p>\r\n<p>\r\n	+-------------------+\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | 王士博    |\r\n</p>\r\n<p>\r\n	|  2 | 郭慧慧    |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	2 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）在master2数据库上写入新数据\r\n</p>\r\n<p>\r\n	mysql&gt; create database hehe;\r\n</p>\r\n<p>\r\n	Query OK, 1 row affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; insert into huanqiu.haha values(3,\"周正\"),(4,\"李敏\");\r\n</p>\r\n<p>\r\n	Query OK, 2 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	Records: 2  Duplicates: 0  Warnings: 0\r\n</p>\r\n<p>\r\n	然后在master1数据库上查看，发现数据也已经同步过来了!\r\n</p>\r\n<p>\r\n	mysql&gt; show databases;\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| Database           |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	| information_schema |\r\n</p>\r\n<p>\r\n	| hehe               |\r\n</p>\r\n<p>\r\n	| huanqiu            |\r\n</p>\r\n<p>\r\n	| mysql              |\r\n</p>\r\n<p>\r\n	| performance_schema |\r\n</p>\r\n<p>\r\n	| test               |\r\n</p>\r\n<p>\r\n	+--------------------+\r\n</p>\r\n<p>\r\n	6 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | 王士博    |\r\n</p>\r\n<p>\r\n	|  2 | 郭慧慧    |\r\n</p>\r\n<p>\r\n	|  3 | 周正      |\r\n</p>\r\n<p>\r\n	|  4 | 李敏      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	至此，Mysql主主同步环境已经实现。\r\n</p>\r\n<p>\r\n	二、配置Mysql+Keepalived故障转移的高可用环境\r\n</p>\r\n<p>\r\n	1）安装keepalived并将其配置成系统服务。master1和master2两台机器上同样进行如下操作：\r\n</p>\r\n<p>\r\n	[root@master1 ~]# yum install -y openssl-devel\r\n</p>\r\n<p>\r\n	[root@master1 ~]# cd /usr/local/src/\r\n</p>\r\n<p>\r\n	[root@master1 src]# wget http://www.keepalived.org/software/keepalived-1.3.5.tar.gz\r\n</p>\r\n<p>\r\n	[root@master1 src]# tar -zvxf keepalived-1.3.5.tar.gz\r\n</p>\r\n<p>\r\n	[root@master1 src]# cd keepalived-1.3.5\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# ./configure --prefix=/usr/local/keepalived\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# make &amp;&amp; make install\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# cp /usr/local/src/keepalived-1.3.5/keepalived/etc/init.d/keepalived /etc/rc.d/init.d/\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# mkdir /etc/keepalived/\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# cp /usr/local/keepalived/sbin/keepalived /usr/sbin/\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# echo \"/etc/init.d/keepalived start\" &gt;&gt; /etc/rc.local\r\n</p>\r\n<p>\r\n	2）绑定虚拟IP（VIP），这个只在master1机器上绑定即可。如下配置好keepalived后，当master1机器出现故障时，VIP资源就会被master2机器自动接管！（这一步其实可以不用这么直接在外部使用ifconfig绑定，VIP就直接在 Keepalived 的配置文件里配置就好，使用命令 ip addr 就能看出 vip；只有LVS+Keepalived 四层负载均衡的高可用环境中， vip是要在外面单独设置的（即ifconfig eth0:0 ....的方式创建vip），通过 ifconfig 可以查看出来 vip。）\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:3C:25:42\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.238  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe3c:2542/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:585898 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:105970 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:277903669 (265.0 MiB)  TX bytes:13625898 (12.9 MiB)\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	broadcast和netmask信息参考上面eth0网卡配置信息。（删除虚拟ip命令：ip addr del 182.148.15.236 dev eth0 &nbsp;以及 route del -host 182.148.15.236 dev eth0:0 ）\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# ifconfig eth0:0 182.148.15.236 broadcast 182.148.15.255 netmask 255.255.255.224 up\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# route add -host 182.148.15.236 dev eth0:0\r\n</p>\r\n<p>\r\n	[root@master1 keepalived-1.3.5]# ifconfig\r\n</p>\r\n<p>\r\n	eth0      Link encap:Ethernet  HWaddr 52:54:00:3C:25:42\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.238  Bcast:182.148.15.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	inet6 addr: fe80::5054:ff:fe3c:2542/64 Scope:Link\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	RX packets:587026 errors:0 dropped:0 overruns:0 frame:0\r\n</p>\r\n<p>\r\n	TX packets:106178 errors:0 dropped:0 overruns:0 carrier:0\r\n</p>\r\n<p>\r\n	collisions:0 txqueuelen:1000\r\n</p>\r\n<p>\r\n	RX bytes:278047550 (265.1 MiB)  TX bytes:13651009 (13.0 MiB)\r\n</p>\r\n<p>\r\n	eth0:0    Link encap:Ethernet  HWaddr 52:54:00:3C:25:42\r\n</p>\r\n<p>\r\n	inet addr:182.148.15.236  Bcast:82.48.115.255  Mask:255.255.255.224\r\n</p>\r\n<p>\r\n	UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	.......\r\n</p>\r\n<p>\r\n	3）master1机器上的keepalived.conf配置。（下面配置中没有使用lvs的负载均衡功能，所以不需要配置虚拟服务器virtual server）\r\n</p>\r\n<p>\r\n	[root@master1 ~]# cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak\r\n</p>\r\n<p>\r\n	[root@master1 ~]# vim /etc/keepalived/keepalived.conf       ＃清空默认内容，直接采用下面配置：\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id MASTER-HA\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_mysql_port {     #检测mysql服务是否在运行。有很多方式，比如进程，用脚本检测等等\r\n</p>\r\n<p>\r\n	script \"/opt/chk_mysql.sh\"   #这里通过脚本监测\r\n</p>\r\n<p>\r\n	interval 2                   #脚本执行间隔，每2s检测一次\r\n</p>\r\n<p>\r\n	weight -5                    #脚本结果导致的优先级变更，检测失败（脚本返回非0）则优先级 -5\r\n</p>\r\n<p>\r\n	fall 2                    #检测连续2次失败才算确定是真失败。会用weight减少优先级（1-255之间）\r\n</p>\r\n<p>\r\n	rise 1                    #检测1次成功就算成功。但不修改优先级\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state MASTER\r\n</p>\r\n<p>\r\n	interface eth0      #指定虚拟ip的网卡接口\r\n</p>\r\n<p>\r\n	mcast_src_ip 182.148.15.238\r\n</p>\r\n<p>\r\n	virtual_router_id 51    #路由器标识，MASTER和BACKUP必须是一致的\r\n</p>\r\n<p>\r\n	priority 101            #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级。这样MASTER故障恢复后，就可以将VIP资源再次抢回来\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.148.15.236\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_mysql_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	编写切换脚本。KeepAlived做心跳检测，如果Master的MySQL服务挂了(3306端口挂了),那么它就会选择自杀。Slave的KeepAlived通过心跳检测发现这个情况，就会将VIP的请求接管\r\n</p>\r\n<p>\r\n	[root@master1 ~]# vim /opt/chk_mysql.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	counter=$(netstat -na|grep \"LISTEN\"|grep \"3306\"|awk -F[:\" \"]+ \'{print $5}\')\r\n</p>\r\n<p>\r\n	if [ \"${counter}\" != \"3306\" ]; then\r\n</p>\r\n<p>\r\n	/usr/bin/killall -9 keepalived\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master1 ~]# chmod 755 /opt/chk_mysql.sh\r\n</p>\r\n<p>\r\n	启动keepalived服务\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	4）master2机器上的keepalived配置。master2机器上的keepalived.conf文件只修改priority为90、nopreempt不设置、real_server设置本地IP。\r\n</p>\r\n<p>\r\n	[root@master2 ~]# cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak\r\n</p>\r\n<p>\r\n	[root@master2 ~]# &gt;/etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	[root@master2 ~]# vim /etc/keepalived/keepalived.conf\r\n</p>\r\n<p>\r\n	! Configuration File for keepalived\r\n</p>\r\n<p>\r\n	global_defs {\r\n</p>\r\n<p>\r\n	notification_email {\r\n</p>\r\n<p>\r\n	ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	tech@wangshibo.cn\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	notification_email_from ops@wangshibo.cn\r\n</p>\r\n<p>\r\n	smtp_server 127.0.0.1\r\n</p>\r\n<p>\r\n	smtp_connect_timeout 30\r\n</p>\r\n<p>\r\n	router_id MASTER-HA\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_script chk_mysql_port {\r\n</p>\r\n<p>\r\n	script \"/opt/chk_mysql.sh\"\r\n</p>\r\n<p>\r\n	interval 2\r\n</p>\r\n<p>\r\n	weight -5\r\n</p>\r\n<p>\r\n	fall 2\r\n</p>\r\n<p>\r\n	rise 1\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	vrrp_instance VI_1 {\r\n</p>\r\n<p>\r\n	state BACKUP\r\n</p>\r\n<p>\r\n	interface eth0\r\n</p>\r\n<p>\r\n	mcast_src_ip 182.148.15.237\r\n</p>\r\n<p>\r\n	virtual_router_id 51\r\n</p>\r\n<p>\r\n	priority 99\r\n</p>\r\n<p>\r\n	advert_int 1\r\n</p>\r\n<p>\r\n	authentication {\r\n</p>\r\n<p>\r\n	auth_type PASS\r\n</p>\r\n<p>\r\n	auth_pass 1111\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	virtual_ipaddress {\r\n</p>\r\n<p>\r\n	182.148.15.236\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	track_script {\r\n</p>\r\n<p>\r\n	chk_mysql_port\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	[root@master2 ~]# cat /opt/chk_mysql.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	counter=$(netstat -na|grep \"LISTEN\"|grep \"3306\"|awk -F[:\" \"]+ \'{print $5}\')\r\n</p>\r\n<p>\r\n	if [ \"${counter}\" != \"3306\" ]; then\r\n</p>\r\n<p>\r\n	/usr/bin/killall -9 keepalived\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	[root@master2 ~]# chmod 755 /opt/chk_mysql.sh\r\n</p>\r\n<p>\r\n	[root@master2 ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	5）master1和master2两台服务器都要授权允许root用户远程登录，用于在客户端登陆测试！\r\n</p>\r\n<p>\r\n	mysql&gt; grant all on *.* to root@\'%\' identified by \"1234567\";\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.00 sec)\r\n</p>\r\n<p>\r\n	mysql&gt; flush privileges;\r\n</p>\r\n<p>\r\n	Query OK, 0 rows affected (0.01 sec)\r\n</p>\r\n<p>\r\n	6）在master1和master2两台机器上设置iptables防火墙规则，如下：\r\n</p>\r\n<p>\r\n	[root@master1 ~]# cat /etc/sysconfig/iptables\r\n</p>\r\n<p>\r\n	........\r\n</p>\r\n<p>\r\n	-A INPUT -s 182.148.15.0/24 -d 224.0.0.18 -j ACCEPT       #允许组播地址通信\r\n</p>\r\n<p>\r\n	-A INPUT -s 182.148.15.0/24 -p vrrp -j ACCEPT             #允许VRRP（虚拟路由器冗余协）通信\r\n</p>\r\n<p>\r\n	-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT    #开放mysql的3306端口\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/iptables restart\r\n</p>\r\n<p>\r\n	三、Mysql＋keepalived故障转移的高可用测试\r\n</p>\r\n<p>\r\n	1）通过Mysql客户端通过VIP连接，看是否连接成功。\r\n</p>\r\n<p>\r\n	比如，在远程一台测试机上连接，通过vip地址可以正常连接（下面的连接权限要是在服务端提前授权的）\r\n</p>\r\n<p>\r\n	[root@dev-new-test ~]# mysql -h182.148.15.236 -uroot -p123456\r\n</p>\r\n<p>\r\n	Welcome to the MySQL monitor.  Commands end with ; or \\g.\r\n</p>\r\n<p>\r\n	Your MySQL connection id is 60\r\n</p>\r\n<p>\r\n	Server version: 5.6.35-log Source distribution\r\n</p>\r\n<p>\r\n	Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.\r\n</p>\r\n<p>\r\n	Oracle is a registered trademark of Oracle Corporation and/or its\r\n</p>\r\n<p>\r\n	affiliates. Other names may be trademarks of their respective\r\n</p>\r\n<p>\r\n	owners.\r\n</p>\r\n<p>\r\n	Type \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n</p>\r\n<p>\r\n	mysql&gt; select * from huanqiu.haha;\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	| id | name      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	|  1 | 王士博    |\r\n</p>\r\n<p>\r\n	|  2 | 郭慧慧    |\r\n</p>\r\n<p>\r\n	|  3 | 周正      |\r\n</p>\r\n<p>\r\n	|  4 | 李敏      |\r\n</p>\r\n<p>\r\n	+----+-----------+\r\n</p>\r\n<p>\r\n	4 rows in set (0.00 sec)\r\n</p>\r\n<p>\r\n	2）默认情况下，vip是在master1上的。使用\"ip addr\"命令查看vip切换情况\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:3c:25:42 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.238/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/32 scope global eth0                              //这个32位子网掩码的vip地址表示该资源目前还在master1机器上\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 82.48.115.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe3c:2542/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	停止master1机器上的mysql服务，根据配置中的脚本，mysql服务停了，keepalived也会停，从而vip资源将会切换到master2机器上。\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/mysql stop\r\n</p>\r\n<p>\r\n	Shutting down MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ps -ef|grep mysql\r\n</p>\r\n<p>\r\n	root     25812 21588  0 17:30 pts/0    00:00:00 grep mysql\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ps -ef|grep keepalived\r\n</p>\r\n<p>\r\n	root     25814 21588  0 17:30 pts/0    00:00:00 grep keepalived\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:3c:25:42 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.238/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 82.48.115.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe3c:2542/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	如上结果，发现32位子网掩码的vip没有了，说明此时vip资源已不在master1机器上了\r\n</p>\r\n<p>\r\n	查看下master1的系统日志，如下，会发现vip资源已经切换走了\r\n</p>\r\n<p>\r\n	[root@master1 ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	Apr 15 17:17:43 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:17:48 localhost Keepalived_vrrp[23037]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:39 localhost Keepalived_healthcheckers[23036]: Stopped\r\n</p>\r\n<p>\r\n	Apr 15 17:30:39 localhost Keepalived_vrrp[23037]: VRRP_Instance(VI_1) sent 0 priority\r\n</p>\r\n<p>\r\n	Apr 15 17:30:39 localhost Keepalived_vrrp[23037]: VRRP_Instance(VI_1) removing protocol VIPs.\r\n</p>\r\n<p>\r\n	再到master2机器上，发现vip资源的确切换过来了\r\n</p>\r\n<p>\r\n	[root@master2 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:95:1f:6d brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe95:1f6d/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	查看master2的系统日志\r\n</p>\r\n<p>\r\n	[root@master2 ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	Apr 15 17:30:41 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:41 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:41 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:41 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	3）再次启动master1的mysql和keepalived服务。（注意：如果restart重启mysql，那么还要启动下keepalived，因为mysql重启，根据脚本会造成keepalived关闭）\r\n</p>\r\n<p>\r\n	注意：一定要先启动mysql服务，然后再启动keepalived服务。如果先启动keepalived服务，按照上面的配置，mysql没有起来，就会自动关闭keepalived。\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/mysql start\r\n</p>\r\n<p>\r\n	Starting MySQL.. SUCCESS!\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	启动这两个服务器后，稍微等过一会儿，注意观察会发现vip资源再次从master2机器上切换回来了。\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:3c:25:42 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.238/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 82.48.115.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe3c:2542/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	[root@master1 ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:46 localhost Keepalived_vrrp[27002]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	再看看master2机器，发现vip资源又被恢复后的master1抢过去了\r\n</p>\r\n<p>\r\n	[root@master2 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:95:1f:6d brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe95:1f6d/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	[root@master2 ~]# tail -f /var/log/messages\r\n</p>\r\n<p>\r\n	Apr 15 17:30:41 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:30:46 localhost Keepalived_vrrp[8731]: Sending gratuitous ARP on eth0 for 182.148.15.236\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[8731]: VRRP_Instance(VI_1) Received advert with higher priority 101, ours 99\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[8731]: VRRP_Instance(VI_1) Entering BACKUP STATE\r\n</p>\r\n<p>\r\n	Apr 15 17:40:41 localhost Keepalived_vrrp[8731]: VRRP_Instance(VI_1) removing protocol VIPs.\r\n</p>\r\n<p>\r\n	4）同样，关闭master1机器的keepalived服务，vip资源会自动切换到master2机器上。当master1的keepalived服务恢复后，会将vip资源再次切回来。\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/keepalived stop\r\n</p>\r\n<p>\r\n	停止 keepalived：                                          [确定]\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:3c:25:42 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.238/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 82.48.115.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe3c:2542/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	查看master2，发现vip切过来了\r\n</p>\r\n<p>\r\n	[root@master2 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:95:1f:6d brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe95:1f6d/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	再次恢复master1的keepalived服务，发现vip资源很快油切回来了。\r\n</p>\r\n<p>\r\n	[root@master1 ~]# /etc/init.d/keepalived start\r\n</p>\r\n<p>\r\n	正在启动 keepalived：                                      [确定]\r\n</p>\r\n<p>\r\n	[root@master1 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:3c:25:42 brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.238/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/32 scope global eth0\r\n</p>\r\n<p>\r\n	inet 182.148.15.236/27 brd 82.48.115.255 scope global secondary eth0:0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe3c:2542/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	在此查看master2，发现vip资源被切走了\r\n</p>\r\n<p>\r\n	[root@master2 ~]# ip addr\r\n</p>\r\n<p>\r\n	1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state UNKNOWN</loopback,up,lower_up>\r\n</p>\r\n<p>\r\n	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n</p>\r\n<p>\r\n	inet 127.0.0.1/8 scope host lo\r\n</p>\r\n<p>\r\n	inet6 ::1/128 scope host\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	2: eth0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc pfifo_fast state UP qlen 1000</broadcast,multicast,up,lower_up>\r\n</p>\r\n<p>\r\n	link/ether 52:54:00:95:1f:6d brd ff:ff:ff:ff:ff:ff\r\n</p>\r\n<p>\r\n	inet 182.148.15.237/27 brd 182.148.15.255 scope global eth0\r\n</p>\r\n<p>\r\n	inet6 fe80::5054:ff:fe95:1f6d/64 scope link\r\n</p>\r\n<p>\r\n	valid_lft forever preferred_lft forever\r\n</p>\r\n<p>\r\n	以上在vip资源切换过程中，对于客户端连接mysql（使用vip连接）来说几乎是没有任何影响的。\r\n</p>\r\n<p>\r\n	------------------------------------温馨提示（Keepalived的抢占和非抢占模式）---------------------------------------\r\n</p>\r\n<p>\r\n	keepalive是基于vrrp协议在linux主机上以守护进程方式，根据配置文件实现健康检查。\r\n</p>\r\n<p>\r\n	VRRP是一种选择协议，它可以把一个虚拟路由器的责任动态分配到局域网上的VRRP路由器中的一台。\r\n</p>\r\n<p>\r\n	控制虚拟路由器IP地址的VRRP路由器称为主路由器，它负责转发数据包到这些虚拟IP地址。\r\n</p>\r\n<p>\r\n	一旦主路由器不可用，这种选择过程就提供了动态的故障转移机制，这就允许虚拟路由器的IP地址可以作为终端主机的默认第一跳路由器。\r\n</p>\r\n<p>\r\n	keepalive通过组播，单播等方式（自定义），实现keepalive主备推选。工作模式分为抢占和非抢占（通过参数nopreempt来控制）。\r\n</p>\r\n<p>\r\n	1）抢占模式：\r\n</p>\r\n<p>\r\n	主服务正常工作时，虚拟IP会在主上，备不提供服务，当主服务优先级低于备的时候，备会自动抢占虚拟IP，这时，主不提供服务，备提供服务。\r\n</p>\r\n<p>\r\n	也就是说，工作在抢占模式下，不分主备，只管优先级。\r\n</p>\r\n<p>\r\n	如上配置，不管keepalived.conf里的state配置成master还是backup，只看谁的priority优先级高（一般而言，state为MASTER的优先级要高于BACKUP）。\r\n</p>\r\n<p>\r\n	priority优先级高的那一个在故障恢复后，会自动将VIP资源再次抢占回来！！\r\n</p>\r\n<p>\r\n	2）非抢占模式：\r\n</p>\r\n<p>\r\n	这种方式通过参数nopreempt（一般设置在advert_int的那一行下面）来控制。不管priority优先级，只要MASTER机器发生故障，VIP资源就会被切换到BACKUP上。\r\n</p>\r\n<p>\r\n	并且当MASTER机器恢复后，也不会去将VIP资源抢占回来，直至BACKUP机器发生故障时，才能自动切换回来。\r\n</p>\r\n<p>\r\n	千万注意：\r\n</p>\r\n<p>\r\n	nopreempt这个参数只能用于state为backup的情况，所以在配置的时候要把master和backup的state都设置成backup，这样才会实现keepalived的非抢占模式！\r\n</p>\r\n<p>\r\n	也就是说：\r\n</p>\r\n<p>\r\n	a）当state状态一个为master，一个为backup的时候，加不加nopreempt这个参数都是一样的效果。即都是根据priority优先级来决定谁抢占vip资源的，是抢占模式！\r\n</p>\r\n<p>\r\n	b）当state状态都设置成backup，如果不配置nopreempt参数，那么也是看priority优先级决定谁抢占vip资源，即也是抢占模式。\r\n</p>\r\n<p>\r\n	c）当state状态都设置成backup，如果配置nopreempt参数，那么就不会去考虑priority优先级了，是非抢占模式！即只有vip当前所在机器发生故障，另一台机器才能接管vip。即使优先级高的那一台机器恢复  后也不会主动抢回vip，只能等到对方发生故障，才会将vip切回来。\r\n</p>\r\n<p>\r\n	---------------------------------mysql状态检测脚本优化---------------------------------\r\n</p>\r\n<p>\r\n	上面的mysql监测脚本有点过于简单且粗暴，即脚本一旦监测到Master的mysql服务关闭，就立刻把keepalived服务关闭，从而实现vip转移！\r\n</p>\r\n<p>\r\n	下面对该脚本进行优化，优化后，当监测到Master的mysql服务关闭后，就会将vip切换到Backup上（但此时Master的keepalived服务不会被暴力kill）\r\n</p>\r\n<p>\r\n	当Master的mysql服务恢复后，就会再次将VIP资源切回来！\r\n</p>\r\n<p>\r\n	[root@master ~]# cat /opt/chk_mysql.sh\r\n</p>\r\n<p>\r\n	#!/bin/bash\r\n</p>\r\n<p>\r\n	MYSQL=/usr/local/mysql/bin/mysql\r\n</p>\r\n<p>\r\n	MYSQL_HOST=localhost\r\n</p>\r\n<p>\r\n	MYSQL_USER=root\r\n</p>\r\n<p>\r\n	MYSQL_PASSWORD=123456\r\n</p>\r\n<p>\r\n	CHECK_TIME=3\r\n</p>\r\n<p>\r\n	#mysql  is working MYSQL_OK is 1 , mysql down MYSQL_OK is 0\r\n</p>\r\n<p>\r\n	MYSQL_OK=1\r\n</p>\r\n<p>\r\n	function check_mysql_helth (){\r\n</p>\r\n<p>\r\n	$MYSQL -h $MYSQL_HOST -u $MYSQL_USER -p${MYSQL_PASSWORD} -e \"show status;\" &gt;/dev/null 2&gt;&amp;1\r\n</p>\r\n<p>\r\n	if [ $? = 0 ] ;then\r\n</p>\r\n<p>\r\n	MYSQL_OK=1\r\n</p>\r\n<p>\r\n	else\r\n</p>\r\n<p>\r\n	MYSQL_OK=0\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	return $MYSQL_OK\r\n</p>\r\n<p>\r\n	}\r\n</p>\r\n<p>\r\n	while [ $CHECK_TIME -ne 0 ]\r\n</p>\r\n<p>\r\n	do\r\n</p>\r\n<p>\r\n	let \"CHECK_TIME -= 1\"\r\n</p>\r\n<p>\r\n	check_mysql_helth\r\n</p>\r\n<p>\r\n	if [ $MYSQL_OK = 1 ] ; then\r\n</p>\r\n<p>\r\n	CHECK_TIME=0\r\n</p>\r\n<p>\r\n	exit 0\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	if [ $MYSQL_OK -eq 0 ] &amp;&amp;  [ $CHECK_TIME -eq 0 ]\r\n</p>\r\n<p>\r\n	then\r\n</p>\r\n<p>\r\n	pkill keepalived\r\n</p>\r\n<p>\r\n	exit 1\r\n</p>\r\n<p>\r\n	fi\r\n</p>\r\n<p>\r\n	sleep 1\r\n</p>\r\n<p>\r\n	done\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('f4ab71c4-bd3c-4921-abcf-90d0291cfae3','mysql主从同步(4)-Slave延迟状态监控','mysql主从同步(4)-Slave延迟状态监控','<p>\r\n	之前部署了mysql主从同步环境（Mysql主从同步(1)-主从/主主环境部署梳理），针对主从同步过程中slave延迟状态的监控梳理如下：\r\n</p>\r\n<p>\r\n	在mysql日常维护工作中，对于主从复制的监控主要体现在：1）检查数据是否一致；主从数据不同步时，参考下面两篇文档记录进行数据修复：mysql主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理利用mk-table-checksum监测Mysql主从数据一致性操作记录\r\n</p>\r\n<p>\r\n	2）监控主从同步延迟，同步延迟的检查工作主要从下面两方面着手： 1.一般的做法就是根据Seconds_Behind_Master的值来判断slave的延迟状态。      可以通过监控show slave status\\G命令输出的Seconds_Behind_Master参数的值来判断，是否有发生主从延时。\r\n</p>\r\n<p>\r\n	mysql&gt; show slave status\\G;\r\n</p>\r\n<p>\r\n	*************************** 1. row ***************************\r\n</p>\r\n<p>\r\n	Slave_IO_State: Waiting for master to send event\r\n</p>\r\n<p>\r\n	Master_Host: 192.168.1.101\r\n</p>\r\n<p>\r\n	Master_User: slave\r\n</p>\r\n<p>\r\n	Master_Port: 3306\r\n</p>\r\n<p>\r\n	Connect_Retry: 60\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000004\r\n</p>\r\n<p>\r\n	Read_Master_Log_Pos: 761249\r\n</p>\r\n<p>\r\n	Relay_Log_File: mysql-relay-bin.000008\r\n</p>\r\n<p>\r\n	Relay_Log_Pos: 761408\r\n</p>\r\n<p>\r\n	Relay_Master_Log_File: mysql-bin.000004\r\n</p>\r\n<p>\r\n	Slave_IO_Running: Yes\r\n</p>\r\n<p>\r\n	Slave_SQL_Running: Yes\r\n</p>\r\n<p>\r\n	Replicate_Do_DB: huanqiu,huanpc\r\n</p>\r\n<p>\r\n	Replicate_Ignore_DB: mysql\r\n</p>\r\n<p>\r\n	Replicate_Do_Table:\r\n</p>\r\n<p>\r\n	Replicate_Ignore_Table:\r\n</p>\r\n<p>\r\n	Replicate_Wild_Do_Table:\r\n</p>\r\n<p>\r\n	Replicate_Wild_Ignore_Table:\r\n</p>\r\n<p>\r\n	Last_Errno: 0\r\n</p>\r\n<p>\r\n	Last_Error:\r\n</p>\r\n<p>\r\n	Skip_Counter: 0\r\n</p>\r\n<p>\r\n	Exec_Master_Log_Pos: 761249\r\n</p>\r\n<p>\r\n	Relay_Log_Space: 761620\r\n</p>\r\n<p>\r\n	Until_Condition: None\r\n</p>\r\n<p>\r\n	Until_Log_File:\r\n</p>\r\n<p>\r\n	Until_Log_Pos: 0\r\n</p>\r\n<p>\r\n	Master_SSL_Allowed: No\r\n</p>\r\n<p>\r\n	Master_SSL_CA_File:\r\n</p>\r\n<p>\r\n	Master_SSL_CA_Path:\r\n</p>\r\n<p>\r\n	Master_SSL_Cert:\r\n</p>\r\n<p>\r\n	Master_SSL_Cipher:\r\n</p>\r\n<p>\r\n	Master_SSL_Key:\r\n</p>\r\n<p>\r\n	Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	Master_SSL_Verify_Server_Cert: No\r\n</p>\r\n<p>\r\n	Last_IO_Errno: 0\r\n</p>\r\n<p>\r\n	Last_IO_Error:\r\n</p>\r\n<p>\r\n	Last_SQL_Errno: 0\r\n</p>\r\n<p>\r\n	Last_SQL_Error:\r\n</p>\r\n<p>\r\n	Replicate_Ignore_Server_Ids:\r\n</p>\r\n<p>\r\n	Master_Server_Id: 101\r\n</p>\r\n<p>\r\n	Master_UUID: b667a58f-d6e0-11e6-8c0a-fa163e2d66ac\r\n</p>\r\n<p>\r\n	Master_Info_File: /data/mysql/data/master.info\r\n</p>\r\n<p>\r\n	SQL_Delay: 0\r\n</p>\r\n<p>\r\n	SQL_Remaining_Delay: NULL\r\n</p>\r\n<p>\r\n	Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\r\n</p>\r\n<p>\r\n	Master_Retry_Count: 86400\r\n</p>\r\n<p>\r\n	Master_Bind:\r\n</p>\r\n<p>\r\n	Last_IO_Error_Timestamp:\r\n</p>\r\n<p>\r\n	Last_SQL_Error_Timestamp:\r\n</p>\r\n<p>\r\n	Master_SSL_Crl:\r\n</p>\r\n<p>\r\n	Master_SSL_Crlpath:\r\n</p>\r\n<p>\r\n	Retrieved_Gtid_Set:\r\n</p>\r\n<p>\r\n	Executed_Gtid_Set:\r\n</p>\r\n<p>\r\n	Auto_Position: 0\r\n</p>\r\n<p>\r\n	1 row in set (0.00 sec)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ERROR:\r\n</p>\r\n<p>\r\n	No query specified\r\n</p>\r\n<p>\r\n	以上是show slave status\\G的输出结果，需要监控下面三个参数：&nbsp; &nbsp;1）Slave_IO_Running：该参数可作为io_thread的监控项，Yes表示io_thread的和主库连接正常并能实施复制工作，No则说明与主库通讯异常，多数情况是由主从间网络引起的问题；&nbsp; &nbsp;2）Slave_SQL_Running：该参数代表sql_thread是否正常，YES表示正常，NO表示执行失败，具体就是语句是否执行通过，常会遇到主键重复或是某个表不存在。&nbsp; &nbsp;3）Seconds_Behind_Master：是通过比较sql_thread执行的event的timestamp和io_thread复制好的event的timestamp(简写为ts)进行比较，而得到的这么一个差值；&nbsp; &nbsp; &nbsp; &nbsp; NULL—表示io_thread或是sql_thread有任何一个发生故障，也就是该线程的Running状态是No，而非Yes。&nbsp; &nbsp; &nbsp; &nbsp; 0 — 该值为零，是我们极为渴望看到的情况，表示主从复制良好，可以认为lag不存在。&nbsp; &nbsp; &nbsp; &nbsp; 正值 — 表示主从已经出现延时，数字越大表示从库落后主库越多。&nbsp; &nbsp; &nbsp; &nbsp; 负值 — 几乎很少见，我只是听一些资深的DBA说见过，其实，这是一个BUG值，该参数是不支持负值的，也就是不应该出现。-----------------------------------------------------------------------------------------------------------------------------Seconds_Behind_Master的计算方式可能带来的问题：relay-log和主库的bin-log里面的内容完全一样，在记录sql语句的同时会被记录上当时的ts，所以比较参考的值来自于binlog，其实主从没有必要与NTP进行同步，也就是说无需保证主从时钟的一致。其实比较动作真正是发生在io_thread与sql_thread之间，而io_thread才真正与主库有关联，于是，问题就出来了，当主库I/O负载很大或是网络阻塞，io_thread不能及时复制binlog（没有中断，也在复制），而sql_thread一直都能跟上io_thread的脚本，这时Seconds_Behind_Master的值是0，也就是我们认为的无延时，但是，实际上不是，你懂得。这也就是为什么大家要批判用这个参数来监控数据库是否发生延时不准的原因，但是这个值并不是总是不准，如果当io_thread与master网络很好的情况下，那么该值也是很有价值的。之前，提到Seconds_Behind_Master这个参数会有负值出现，我们已经知道该值是io_thread的最近跟新的ts与sql_thread执行到的ts差值，前者始终是大于后者的，唯一的肯能就是某个event的ts发生了错误，比之前的小了，那么当这种情况发生时，负值出现就成为可能。-----------------------------------------------------------------------------------------------------------------------------\r\n</p>\r\n<p>\r\n	简单来说，就是监控slave同步状态中的：1）Slave_IO_Running、Slave_SQL_Running状态值，如果都为YES，则表示主从同步；反之，主从不同步。2）Seconds_Behind_Master的值，如果为0，则表示主从同步不延时，反之同步延时。\r\n</p>\r\n<p>\r\n	2.上面根据Seconds_Behind_Master的值来判断slave的延迟状态，这么做在大部分情况下尚可接受，但其实是并不够准确的。对于Slave延迟状态的监控，还应该做到下面的考虑：首先，我们先看下slave的状态：mysql&gt; show slave status\\G;*************************** 1. row ***************************slave_IO_State: Waiting for master to send event***Master_Log_File: mysql-bin.000327Read_Master_Log_Pos: 668711237Relay_Log_File: mysql-relay-bin.002999Relay_Log_Pos: 214736858Relay_Master_Log_File: mysql-bin.000327slave_IO_Running: Yesslave_SQL_Running: Yes***Skip_Counter: 0Exec_Master_Log_Pos: 654409041Relay_Log_Space: 229039311***Seconds_Behind_Master: 3296***可以看到 Seconds_Behind_Master 的值是 3296，也就是slave至少延迟了 3296 秒。\r\n</p>\r\n<p>\r\n	我们再来看下slave上的2个REPLICATION进程状态：mysql&gt; show full processlist\\G;*************************** 1. row ***************************Id: 6User: system userHost:db: NULLCommand: ConnectTime: 22005006State: Waiting for master to send eventInfo: NULL*************************** 2. row ***************************Id: 7User: system userHost:db: NULLCommand: ConnectTime: 3293State: UpdatingInfo: UPDATE ** SET ** WHERE **\r\n</p>\r\n<p>\r\n	可以看到SQL线程一直在执行UPDATE操作，注意到 Time 的值是 3293，看起来像是这个UPDATE操作执行了3293秒，一个普通的SQL而已，肯定不至于需要这么久。实际上，在REPLICATION进程中，Time 这列的值可能有几种情况：&nbsp; &nbsp;1）SQL线程当前执行的binlog（实际上是relay log）中的timestamp和IO线程最新的timestamp的差值，这就是通常大家认为的 Seconds_Behind_Master 值，并不是某个SQL的实际执行耗时；&nbsp; &nbsp;2）SQL线程当前如果没有活跃SQL在执行的话，Time值就是SQL线程的idle time；而IO线程的Time值则是该线程自从启动以来的总时长（多少秒），如果系统时间在IO线程启动后发生修改的话，可能会导致该Time值异常，比如变成负数，或者非常大。来看下面几个状态：设置pager，只查看关注的几个status值mysql&gt; pager cat | egrep -i \'system user|Exec_Master_Log_Pos|Seconds_Behind_Master|Read_Master_Log_Pos\';\r\n</p>\r\n<p>\r\n	这是没有活跃SQL的情况，Time值是idle time，并且 Seconds_Behind_Master 为 0mysql&gt; show processlist; show slave status\\G;| 6 | system user | | NULL | Connect | 22004245 | Waiting for master to send event | NULL || 7 | system user | | NULL | Connect | 13 | Has read all relay log;**Read_Master_Log_Pos: 445167889Exec_Master_Log_Pos: 445167889Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	多执行几次，看下是否有活跃的SQLmysql&gt; show processlist; show slave status\\G;| 6 | system user | | NULL | Connect | 22004248 | Waiting for master to send event | NULL || 7 | system user | | NULL | Connect | 16 | Has read all relay log;**Read_Master_Log_Pos: 445167889Exec_Master_Log_Pos: 445167889Seconds_Behind_Master: 0\r\n</p>\r\n<p>\r\n	发现有活跃SQL了，Time值是和 Seconds_Behind_Master 一样，即SQL线程比IO线程“慢”了1秒mysql&gt; show processlist; show slave status\\G;| 6 | system user | | NULL | Connect | 22004252 | Waiting for master to send event | NULL || 7 | system user | | floweradmin | Connect | 1 | Updating | update **Read_Master_Log_Pos: 445182239Exec_Master_Log_Pos: 445175263Seconds_Behind_Master: 1\r\n</p>\r\n<p>\r\n	再次查看下状态mysql&gt; show processlist; show slave status\\G;| 6 | system user | | NULL | Connect | 22004254 | Waiting for master to send event | NULL || 7 | system user | | floweradmin | Connect | 1 | Updating | update **Read_Master_Log_Pos: 445207174Exec_Master_Log_Pos: 445196837Seconds_Behind_Master: 1检查到此，可以说下如何正确判断slave的延迟情况：1）首先看 Relay_Master_Log_File 和 Master_Log_File 是否有差异；2）如果Relay_Master_Log_File 和 Master_Log_File 是一样的话，再来看Exec_Master_Log_Pos 和 Read_Master_Log_Pos 的差异，对比SQL线程比IO线程慢了多少个binlog事件；3）如果Relay_Master_Log_File 和 Master_Log_File 不一样，那说明延迟可能较大，需要从MASTER上取得binlog status，判断当前的binlog和MASTER上的差距；\r\n</p>\r\n<p>\r\n	因此，相对更加严谨的做法是：在第三方监控节点上，对MASTER和slave同时发起SHOW BINARY LOGS和SHOW slave STATUS\\G的请求，最后判断二者binlog的差异，以及 Exec_Master_Log_Pos 和Read_Master_Log_Pos 的差异。\r\n</p>\r\n<p>\r\n	例如：在MASTER上执行SHOW BINARY LOGS 的结果是：+------------------+--------------+| Log_name | File_size |+------------------+--------------+| mysql-bin.000009 | 1073742063 || mysql-bin.000010 | 107374193 |+------------------+--------------+而在slave上执行SHOW slave STATUS\\G 的结果是：\r\n</p>\r\n<p>\r\n	Master_Log_File: mysql-bin.000009Read_Master_Log_Pos: 668711237Relay_Master_Log_File: mysql-bin.000009slave_IO_Running: Yesslave_SQL_Running: Yes***Exec_Master_Log_Pos: 654409041\r\n</p>\r\n<p>\r\n	***Seconds_Behind_Master: 3296***这时候，slave实际的延迟应该是：mysql-bin.000009 这个binlog中的binlog position 1073742063 和 slave上读取到的binlog position之间的差异延迟，即：1073742063 - 654409041 = 419333022 个binlog event并且还要加上 mysql-bin.000010这个binlog已经产生的107374193个binlog event，共107374193 + 419333022 = 526707215 个binlog event\r\n</p>','2017-07-31 17:32:24',3,0,'images/mysql.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),('fe69ab82-9b9d-498d-ad77-9d347045af54','nginx域名访问的白名单配置梳理','nginx域名访问的白名单配置梳理','<p>在日常运维工作中，会碰到这样的需求：设置网站访问只对某些ip开放，其他ip的客户端都不能访问。可以通过下面四种方法来达到这种效果：1）针对nginx域名配置所启用的端口(比如80端口)在iptables里做白名单，比如只允许100.110.15.16、100.110.15.17、100.110.15.18访问.但是这样就把nginx的所有80端口的域名访问都做了限制，范围比较大！</p><p></p><p>[root@china ~]# vim /etc/sysconfig/iptables</p><p>......</p><p>-A INPUT -s 100.110.15.16 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</p><p>-A INPUT -s 100.110.15.17 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</p><p>-A INPUT -s 100.110.15.18 -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</p><p></p><p></p><p>2）如果只是针对nginx下的某一个域名进行访问的白名单限制，那么可以在nginx的配置文件里进行设置，利用$remote_addr参数进行访问的分发限制，如下：</p><p></p><p>[root@china vhosts]# cat testwww.wangshibo.com.conf </p><p>server {</p><p>        listen       80;</p><p>        server_name  testwww.wangshibo.com;</p><p>        root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main;</p><p></p><p></p><p>        access_log  /var/www/vhosts/testwww.wangshibo.com/logs/access.log  main;</p><p>        error_log  /var/www/vhosts/testwww.wangshibo.com/logs/error.log;</p><p></p><p></p><p>        ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。主要是下面这三行</p><p>        if ($remote_addr !~ ^(100.110.15.16|100.110.15.17|100.110.15.18|127.0.0.1)) {</p><p>         rewrite ^.*$ /maintence.php last;</p><p>        }</p><p></p><p>        location / {</p><p>            try_files $uri $uri/ @router;</p><p>            index  index.php;</p><p>        }</p><p>    </p><p></p><p>        error_page   500 502 503 504  /50x.html;</p><p></p><p>        location @router {</p><p>            rewrite ^.*$ /index.php last;</p><p>        }</p><p></p><p></p><p>        location ~ \\.php$ {</p><p>            fastcgi_pass   127.0.0.1:9001;</p><p>            fastcgi_read_timeout 30;</p><p>            fastcgi_index  index.php;</p><p>            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</p><p>            #include        fastcgi_params;</p><p>            include        fastcgi.conf;</p><p>        }</p><p></p><p>    } </p><p></p><p></p><p>错误页面内容设置：</p><p>[root@china vhosts]# cat /var/www/vhosts/testwww.wangshibo.com/main/maintence.html </p><p><html></p><p><head></p><p><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"></p><p><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"></p><p></head></p><p><body></p><p>网站临时维护中，请稍后访问...</p><p></body></p><p></html></p><p></p><p>3）也可以使用$http_x_forwarded_for参数进行访问的分发限制，如下：</p><p></p><p>server {</p><p>        listen       80;</p><p>        server_name  testwww.wangshibo.com;</p><p>        root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main;</p><p></p><p></p><p>        access_log  /var/www/vhosts/testwww.wangshibo.com/logs/access.log  main;</p><p>        error_log  /var/www/vhosts/testwww.wangshibo.com/logs/error.log;</p><p></p><p></p><p>  ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。</p><p>       if ($http_x_forwarded_for !~ ^(100.110.15.16|100.110.15.17|100.110.15.18|127.0.0.1)) {</p><p>           rewrite ^.*$  /maintence.php last;</p><p>        }</p><p>        </p><p>        </p><p>        location / {</p><p>            try_files $uri $uri/ @router;</p><p>            index  index.php;</p><p>        }</p><p>    </p><p></p><p>        error_page   500 502 503 504  /50x.html;</p><p></p><p>        location @router {</p><p>            rewrite ^.*$ /index.php last;</p><p>        }</p><p></p><p></p><p>        location ~ \\.php$ {</p><p>            fastcgi_pass   127.0.0.1:9001;</p><p>            fastcgi_read_timeout 30;</p><p>            fastcgi_index  index.php;</p><p>            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</p><p>            #include        fastcgi_params;</p><p>            include        fastcgi.conf;</p><p>        }</p><p></p><p>    } </p><p></p><p></p><p>4）还可以利用nginx的allow、deny参数进行访问限制</p><p></p><p>[root@china vhosts]# cat testwww.wangshibo.com.conf </p><p>server {</p><p>        listen       80;</p><p>        server_name  testwww.wangshibo.com;</p><p>        root /var/www/vhosts/testwww.wangshibo.com/httpdocs/main;</p><p></p><p></p><p>        access_log  /var/www/vhosts/testwww.wangshibo.com/logs/access.log  main;</p><p>        error_log  /var/www/vhosts/testwww.wangshibo.com/logs/error.log;</p><p></p><p>        ##白名单设置，只允许下面三个来源ip的客户端以及本地能访问该站。</p><p>        allow 100.110.15.16;</p><p>        allow 100.110.15.17;</p><p>        allow 100.110.15.18;</p><p>        allow 127.0.0.1;</p><p>        deny all;</p><p></p><p>        location / {</p><p>            try_files $uri $uri/ @router;</p><p>            index  index.php;</p><p>        }</p><p>    </p><p></p><p>        error_page   500 502 503 504  /50x.html;</p><p></p><p>        location @router {</p><p>            rewrite ^.*$ /index.php last;</p><p>        }</p><p></p><p></p><p>        location ~ \\.php$ {</p><p>            fastcgi_pass   127.0.0.1:9001;</p><p>            fastcgi_read_timeout 30;</p><p>            fastcgi_index  index.php;</p><p>            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</p><p>            #include        fastcgi_params;</p><p>            include        fastcgi.conf;</p><p>        }</p><p></p><p>    } </p><p></p><p></p><p>---------------------------------nginx中remote_addr和x_forwarded_for参数使用说明---------------------------------</p><p></p><p>做网站时经常会用到remote_addr和x_forwarded_for这两个头信息来获取客户端的IP，然而当有反向代理或者CDN的情况下，这两个值就不够准确了，需要调整一些配置。</p><p></p><p>1）什么是remote_addr</p><p>remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的</p><p>web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web</p><p>服务器就会把remote_addr设为这台代理机器的IP。</p><p></p><p>2）什么是x_forwarded_for</p><p>正如上面所述，当你使用了代理时，web服务器就不知道你的真实IP了，为了避免这个情况，代理服务器通常会增加一个叫做x_forwarded_for的头信息，把连接它的客户</p><p>端IP（即你的上网机器IP）加到这个头信息里，这样就能保证网站的web服务器能获取到真实IP</p><p></p><p></p><p>-------------------使用HAProxy做反向代理----------------------</p><p>通常网站为了支撑更大的访问量，会增加很多web服务器，并在这些服务器前面增加一个反向代理（如HAProxy），它可以把负载均匀的分布到这些机器上。你的浏览器访</p><p>问的首先是这台反向代理，它再把你的请求转发到后面的web服务器，这就使得web服务器会把remote_addr设为这台反向代理的IP，为了能让你的程序获取到真实的客户端</p><p>IP，你需要给HAProxy增加以下配置：</p><p></p><p>option forwardfor</p><p>它的作用就像上面说的，增加一个x_forwarded_for的头信息，把你上网机器的ip添加进去</p><p></p><p></p><p></p><p>------------------使用Nginx的realip模块--------------------</p><p>当Nginx处在HAProxy后面时，就会把remote_addr设为HAProxy的IP，这个值其实是毫无意义的，你可以通过nginx的realip模块，让它使用x_forwarded_for里的值。使用这</p><p>个模块需要重新编译Nginx，增加--with-http_realip_module参数</p><p></p><p>set_real_ip_from   10.1.10.0/24;</p><p>real_ip_header     X-Forwarded-For;</p><p>上面的配置就是把从10.1.10这一网段过来的请求全部使用X-Forwarded-For里的头信息作为remote_addr</p><p></p><p></p><p>------------------将Nginx架在HAProxy前面做HTTPS代理---------------</p><p>网站为了安全考虑通常会使用https连接来传输敏感信息，https使用了ssl加密，HAProxy没法直接解析，所以要在HAProxy前面先架台Nginx解密，再转发到HAProxy做负载均</p><p>衡。这样在Web服务器前面就存在了两个代理，为了能让它获取到真实的客户端IP，需要做以下配置。</p><p></p><p>首先要在Nginx的代理规则里设定：</p><p>proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</p><p>这样会让Nginx的https代理增加x_forwarded_for头信息，保存客户的真实IP。</p><p></p><p>其次修改HAProxy的配置：</p><p>option     forwardfor except 10.1.10.0/24</p><p>这个配置和之前设定的差不多，只是多了个内网的IP段，表示如果HAProxy收到的请求是由内网传过来的话（https代理机器），就不会设定x_forwarded_for的值，保证后面的</p><p>web服务器拿到的就是前面https代理传过来的。</p><p></p><p></p><p></p><p>-----------------为什么PHP里的HTTP_X_FORWARDED_FOR和Nginx的不一样------------------</p><p>当你的网站使用了CDN后，用户会先访问CDN，如果CDN没有缓存，则回源站（即你的反向代理）取数据。CDN在回源站时，会先添加x_forwarded_for头信息，保存用户的真实IP，</p><p>而你的反向代理也会设定这个值，不过它不会覆盖，而是把CDN服务器的IP（即当前remote_addr）添加到x_forwarded_for的后面，这样x_forwarded_for里就会存在两个值。</p><p>Nginx会使用这些值里的第一个，即客户的真实IP，而PHP则会使用第二个，即CDN的地址。为了能让PHP也使用第一个值，你需要添加以下fastcgi的配置。</p><p></p><p>fastcgi_param HTTP_X_FORWARDED_FOR $http_x_forwarded_for;</p><p>它会把nginx使用的值（即第一个IP）传给PHP，这样PHP拿到的x_forwarded_for里其实就只有一个值了，也就不会用第二个CDN的IP了。</p><p></p><p>忽略x_forwarded_for</p><p></p><p>其实，当你使用了Nginx的realip模块后，就已经保证了remote_addr里设定的就是客户端的真实IP，再看下这个配置</p><p></p><p>set_real_ip_from   10.1.10.0/24;</p><p>real_ip_header     X-Forwarded-For;</p><p>它就是把x_forwarded_for设为remote_addr，而nginx里的x_forwarded_for取的就是其中第一个IP。</p><p></p><p>使用这些设置就能保证你的remote_addr里设定的一直都是客户端的真实IP，而x_forwarded_for则可以忽略了:)</p><p></p><p>---------------------------------下面简单说明下nginx location匹配规则-------------------------------------------</p><p></p><p>location匹配命令</p><p>~   表示执行一个正则匹配，区分大小写</p><p>~* 表示执行一个正则匹配，不区分大小写</p><p>^~ 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</p><p>=    进行普通字符精确匹配</p><p>@   定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</p><p></p><p>=前缀的指令严格匹配这个查询。如果找到，停止搜索。</p><p>所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。</p><p>正则表达式，在配置文件中定义的顺序。</p><p>如果第3条规则产生匹配的话，结果被使用。否则，如同从第2条规则被使用。</p><p></p><p>location 匹配的优先级(与location在配置文件中的顺序无关)</p><p>= 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。</p><p>普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。</p><p>^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。</p><p>最后匹配理带有\"~\"和\"~*\"的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。 </p><p>location = / {                     # 只匹配\"/\".</p><p>[ configuration A ] </p><p>}</p><p></p><p>location / {                        # 匹配任何请求，因为所有请求都是以\"/\"开始，但是更长字符匹配或者正则表达式匹配会优先匹配</p><p>[ configuration B ] </p><p>}</p><p></p><p>location ^~ /images/ {           # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location</p><p>[ configuration C ] </p><p>}</p><p></p><p>location ~* \\.(gif|jpg|jpeg)$ {         # 匹配以 gif, jpg, or jpeg结尾的请求. 但是所有 /images/ 目录的请求将由 [Configuration C]处理. </p><p>[ configuration D ] </p><p>}</p>','2017-07-31 17:16:48',1,0,'images/nginx.png','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_comment`
--

DROP TABLE IF EXISTS `article_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_comment` (
  `id` varchar(40) NOT NULL,
  `content` text,
  `date` varchar(30) DEFAULT NULL,
  `article_id` varchar(40) DEFAULT NULL,
  `user_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `article_id` (`article_id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `article_comment_ibfk_1` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`),
  CONSTRAINT `article_comment_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_comment`
--

LOCK TABLES `article_comment` WRITE;
/*!40000 ALTER TABLE `article_comment` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_tag`
--

DROP TABLE IF EXISTS `article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_tag` (
  `article_id` varchar(40) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`article_id`,`tag_id`),
  KEY `tag_id` (`tag_id`),
  CONSTRAINT `article_tag_ibfk_1` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`),
  CONSTRAINT `article_tag_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_tag`
--

LOCK TABLES `article_tag` WRITE;
/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
INSERT INTO `article_tag` VALUES ('2d2a2e6b-0f52-40e8-ae76-6ff0d9ec4f37',1),('34172740-c531-483c-9955-3283b48597c8',1),('3c5cc265-a5e6-4493-bc83-70ff9b3ebb44',1),('5e96b3f9-4cc5-4eca-b370-9203de3e5afe',1),('a975e623-6824-4f4e-a2e8-f366ae0ac77f',1),('de610ef4-aac4-422e-b7c4-ed69665bbb3c',1),('019037c1-901f-466d-9039-29ca381789aa',2),('0bb7bfcd-b787-4f94-88ac-988d89c3f237',2),('0f1c4ebe-06c5-4aba-b11a-3463aa1bcf13',2),('16c3d5fc-24e4-4234-a41c-74058779c986',2),('1816487c-64cd-4fff-a6ec-b91b1055638e',2),('30e9081d-fc4e-4b99-8941-d321c216c5b0',2),('311ce9c7-b1bc-44a5-a4cd-95e529c5a783',2),('358afe84-a3a4-4d1c-90b4-3ab10257d907',2),('40de8c0c-2e2a-4e22-b47b-8e2083658857',2),('4a46066e-89c0-4b3a-998a-d319dc2a5978',2),('4bb7f15b-a496-4216-8b99-83d839e1deb5',2),('5a41abe2-f0d8-479d-a4be-fe1eff408633',2),('661d7925-ab55-4631-b67a-29fd5cf11072',2),('6e51ecf5-cb8d-4f7d-a9af-9710685fed33',2),('77b28eb6-bd8c-4990-9cb5-bd5fbd9a2cfa',2),('79338532-9b51-4e8a-9010-dbf52242be37',2),('7fa6083b-d62b-463f-87f1-4f285c7a6cf5',2),('7ff63c80-255f-4093-91c7-592b4b01eb5d',2),('80c93bc1-fa9b-45f5-95ec-b708985ad8a6',2),('902dba53-097a-4659-a0a3-0b295fa3039f',2),('98fd382c-bdd3-4a10-a1a9-c59ad8febc09',2),('9d45b00b-cbbe-40ed-8c30-d00e5e816eb4',2),('a0ebea49-33b2-42b4-ba84-94b5b88cee1d',2),('bc941170-81ff-4df4-af2a-0c7bfae57540',2),('cda6334f-1b08-418d-807b-1c021a1ade88',2),('d215d9a3-40a1-4bc6-81a5-4fa6616a83cc',2),('d7a04a46-b70c-4542-b3ef-aa00455da34d',2),('dd7b8efd-3689-44d0-bc5e-e7d88207dd12',2),('de6ec6af-3748-4677-8e2c-461561e2c9f6',2),('ed65e270-68c9-4bf5-9dff-cd6e441c4947',2),('efad71e2-f0b0-4888-9f94-dd27b4334b6f',2),('05109d93-27e8-4c30-9221-78eef40758b6',3),('132da9a5-a269-4114-8322-54c3f784727d',3),('16c3d5fc-24e4-4234-a41c-74058779c986',3),('19799513-1631-4d18-a754-6a6044d51bfe',3),('1cd0b5d6-aa79-40e4-a0de-bc8819894593',3),('1e3029f1-63f9-4808-b6b4-738943f52c67',3),('218bb56e-9bd3-4d44-9a00-e319b4480e0f',3),('231614c2-c158-4c49-b0f9-1d4db0b4406c',3),('255173d6-c27c-4467-bda4-fdc0c67cd7e3',3),('25d2c0cd-bc4f-4e51-afab-433440fe0127',3),('2d16455f-ec12-4b5d-9763-469cc5355d3d',3),('2e7b7ad6-4424-40a8-b4ff-2c5f9a9ab061',3),('3027a190-d2fc-4b6f-8a9e-073b6fe8480d',3),('37fca21a-b447-4151-849e-6c530c5307d3',3),('399eaec8-78d3-4146-b1ad-b5febfe50e9c',3),('39a221e9-4145-4ccd-b51d-7a1479f9fc60',3),('40de8c0c-2e2a-4e22-b47b-8e2083658857',3),('556d5142-cf47-4698-ba1a-5839e823761c',3),('585f5df1-88d8-407a-bbb5-e21d9018b16f',3),('5d253e75-45ab-4755-8832-2fd602381dfd',3),('5f969033-b9c1-4e5a-9d08-c5ca4556c164',3),('653207d6-af61-4cfc-af74-0ec0d3aec8b8',3),('684c2e8e-bc90-4c73-853a-f3c7c948582c',3),('7006a19c-fbb0-440f-86a5-fd7110d0c8a7',3),('71ff3fc8-b4dc-4a13-a933-ccdcff6fd013',3),('7ffc0961-7e84-4994-b110-bfc75a020e93',3),('8bd3b1b0-50bd-4b31-9b09-367a89828a92',3),('9ef4b265-6cfb-40bd-8216-5baaffcb78bf',3),('a46e2605-fe12-421a-adcc-aa9c7a93259b',3),('a6aa7897-f076-4d8f-8008-c8562024a7f9',3),('ae755cad-5608-4bcb-85fe-a94df6ace095',3),('ae8ab1a5-2c73-490b-9ed3-e6b71e61deef',3),('b7551b01-91a7-4f90-b162-a857abc951b1',3),('bc31c768-9a4d-4ae6-94e6-c6c407c66373',3),('c429a60f-025d-4030-823f-e9c5f97d7428',3),('c90ff560-d2b1-4b89-bbe1-167592e7465a',3),('caa5312a-bcb7-4982-90dc-f4ce64949244',3),('ce6ac140-9766-47b8-aecc-0fe38c5694e6',3),('de94c6bd-874e-4a8c-b8a0-d5febd65a29d',3),('df0a93b9-d6c9-4809-88f1-d1fb54dc508e',3),('e2aa5c7e-bd0b-406f-91be-5a4a32fc0269',3),('e9ed0ea4-dd40-4a5b-bff3-169412864502',3),('f16cf1db-a9cd-4a2c-9e38-b737310f625b',3),('f1bf7b47-b8fa-4884-9c8a-de0b34f5ea01',3),('f3cc614a-8478-4981-ba81-3a2678368f96',3),('f4ab71c4-bd3c-4921-abcf-90d0291cfae3',3),('897c1211-2993-4a1b-99d8-38c9e898e617',6);
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) DEFAULT NULL,
  `urlname` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (1,'系统','os'),(2,'编程','deve'),(3,'数据库','database'),(4,'监控','monitor'),(5,'自动化','auto');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lognote`
--

DROP TABLE IF EXISTS `lognote`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `lognote` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) DEFAULT NULL,
  `brief` text,
  `content` text,
  `date` varchar(30) DEFAULT NULL,
  `user_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `lognote_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lognote`
--

LOCK TABLES `lognote` WRITE;
/*!40000 ALTER TABLE `lognote` DISABLE KEYS */;
INSERT INTO `lognote` VALUES (1,'python版本判断','python版本判断','<p>\r\n	import sys\r\n</p>\r\n<p>\r\n	PY3=sys.version_info&gt;=(3,)结果 为true或flase\r\n</p>','2017-07-26 14:09:13','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5');
/*!40000 ALTER TABLE `lognote` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) DEFAULT NULL,
  `description` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'Python',''),(2,'Nginx',''),(3,'MySQL',''),(4,'Apache',''),(5,'Tomcat',''),(6,'Zabbix','');
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `uploadfile`
--

DROP TABLE IF EXISTS `uploadfile`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `uploadfile` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `filename` varchar(50) DEFAULT NULL,
  `file_type` varchar(50) NOT NULL,
  `filesize` int(11) NOT NULL,
  `_file_hash` varchar(50) DEFAULT NULL,
  `date` varchar(30) DEFAULT NULL,
  `user_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `_file_hash` (`_file_hash`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `uploadfile_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `uploadfile`
--

LOCK TABLES `uploadfile` WRITE;
/*!40000 ALTER TABLE `uploadfile` DISABLE KEYS */;
INSERT INTO `uploadfile` VALUES (2,'640.png','image/png',48499,'40e4f6986a579fe8ed1a1327deb6078b4da4d7b9','2017-07-24 13:33:34','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(3,'641.png','image/png',53999,'db4b9c44c9920d26b15c7ec29c5a17daccd37e2e','2017-07-24 13:33:34','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(4,'itchat.png','image/png',95327,'b30ea81a5a026f6f9f8dd360016893d02d2b9836','2017-07-24 14:28:02','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(7,'642.png','image/png',573878,'dc54f48f595e333ceba4f4ef40ee7f8792d76465','2017-07-24 16:26:38','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(8,'free -m.txt','text/plain',1096,'81c5527df54a182391a73730461a96aad1348331','2017-07-26 13:25:34','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(9,'tornado_nginx.tar.gz','application/gzip',1656,'a87d7e1b9a5939d730fe85def505b1f9f3bd7880','2017-07-26 13:43:57','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(10,'supervisord.conf','application/octet-stream',1336,'5244e3e6843f208aa6c8dbcd5f7897e3fce3ce2d','2017-07-26 14:09:13','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(11,'MySQlinstall.zip','application/octet-stream',1731,'3bcacdeb6727a6db2289f089a953f020123a7b02','2017-07-26 14:09:13','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(12,'scrapy_cnblog.txt','text/plain',1080,'f0b937d8add3bdc4135e7d176c906448bb72264d','2017-07-27 14:03:59','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5');
/*!40000 ALTER TABLE `uploadfile` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `id` varchar(40) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `password` varchar(80) DEFAULT NULL,
  `email` varchar(30) NOT NULL,
  `enrolltime` varchar(30) DEFAULT NULL,
  `logintime` varchar(30) DEFAULT NULL,
  `image` varchar(30) DEFAULT NULL,
  `islock` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('9ffc41d2-e63e-401f-9a19-8cb45bccd2a5','howhy11','966358de9055696bdda874110bcaab7f','admin@howhy11.com','2017-07-24 13:33:34','2017-08-15 13:38:48','images/head1.jpg',0),('af72426f-edfb-4949-8229-2ccab59142eb','hz123456','736109fd7d76a93e1ffb15178c896983','123456789@qq.com','2017-08-01 10:55:29','2017-08-01 17:29:49','images/head3.jpg',0),('d6fcba47-caf3-4b34-acce-fddedfa38cbb','dfsda122','f68ec39c6dd80bfd6c70d43b9eefbb3b','sdf@qq.com','2017-07-26 20:51:01','2017-07-26 20:51:01','images/head2.jpg',0);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `weblink`
--

DROP TABLE IF EXISTS `weblink`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `weblink` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) DEFAULT NULL,
  `weburl` varchar(100) DEFAULT NULL,
  `description` varchar(200) DEFAULT NULL,
  `date` varchar(30) DEFAULT NULL,
  `user_id` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `weburl` (`weburl`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `weblink_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `weblink`
--

LOCK TABLES `weblink` WRITE;
/*!40000 ALTER TABLE `weblink` DISABLE KEYS */;
INSERT INTO `weblink` VALUES (1,'devdocs','http://devdocs.io/','devdocs','2017-07-26 14:09:13','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5'),(2,'开始Python之旅','http://www.cnblogs.com/adc8868/','开始Python之旅','2017-07-26 14:09:13','9ffc41d2-e63e-401f-9a19-8cb45bccd2a5');
/*!40000 ALTER TABLE `weblink` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-08-15 13:49:18
